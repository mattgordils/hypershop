/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Autoplay)\n/* harmony export */ });\nconst defaultOptions = {\n  active: true,\n  breakpoints: {},\n  delay: 4e3,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n};\nfunction normalizeDelay(emblaApi, delay) {\n  const scrollSnaps = emblaApi.scrollSnapList();\n  if (typeof delay === \"number\") {\n    return scrollSnaps.map(() => delay);\n  }\n  return delay(scrollSnaps, emblaApi);\n}\nfunction getAutoplayRootNode(emblaApi, rootNode) {\n  const emblaRootNode = emblaApi.rootNode();\n  return rootNode && rootNode(emblaRootNode) || emblaRootNode;\n}\nfunction Autoplay(userOptions = {}) {\n  let options;\n  let emblaApi;\n  let destroyed;\n  let delay;\n  let timerStartTime = null;\n  let timerId = 0;\n  let autoplayActive = false;\n  let mouseIsOver = false;\n  let playOnDocumentVisible = false;\n  let jump = false;\n  function init(emblaApiInstance, optionsHandler) {\n    emblaApi = emblaApiInstance;\n    const {\n      mergeOptions,\n      optionsAtMedia\n    } = optionsHandler;\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions);\n    const allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    if (emblaApi.scrollSnapList().length <= 1)\n      return;\n    jump = options.jump;\n    destroyed = false;\n    delay = normalizeDelay(emblaApi, options.delay);\n    const {\n      eventStore,\n      ownerDocument\n    } = emblaApi.internalEngine();\n    const isDraggable = !!emblaApi.internalEngine().options.watchDrag;\n    const root = getAutoplayRootNode(emblaApi, options.rootNode);\n    eventStore.add(ownerDocument, \"visibilitychange\", visibilityChange);\n    if (isDraggable) {\n      emblaApi.on(\"pointerDown\", pointerDown);\n    }\n    if (isDraggable && !options.stopOnInteraction) {\n      emblaApi.on(\"pointerUp\", pointerUp);\n    }\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, \"mouseenter\", mouseEnter);\n    }\n    if (options.stopOnMouseEnter && !options.stopOnInteraction) {\n      eventStore.add(root, \"mouseleave\", mouseLeave);\n    }\n    if (options.stopOnFocusIn) {\n      emblaApi.on(\"slideFocusStart\", stopAutoplay);\n    }\n    if (options.stopOnFocusIn && !options.stopOnInteraction) {\n      eventStore.add(emblaApi.containerNode(), \"focusout\", startAutoplay);\n    }\n    if (options.playOnInit)\n      startAutoplay();\n  }\n  function destroy() {\n    emblaApi.off(\"pointerDown\", pointerDown).off(\"pointerUp\", pointerUp).off(\"slideFocusStart\", stopAutoplay);\n    stopAutoplay();\n    destroyed = true;\n    autoplayActive = false;\n  }\n  function setTimer() {\n    const {\n      ownerWindow\n    } = emblaApi.internalEngine();\n    ownerWindow.clearTimeout(timerId);\n    timerId = ownerWindow.setTimeout(next, delay[emblaApi.selectedScrollSnap()]);\n    timerStartTime = new Date().getTime();\n    emblaApi.emit(\"autoplay:timerset\");\n  }\n  function clearTimer() {\n    const {\n      ownerWindow\n    } = emblaApi.internalEngine();\n    ownerWindow.clearTimeout(timerId);\n    timerId = 0;\n    timerStartTime = null;\n    emblaApi.emit(\"autoplay:timerstopped\");\n  }\n  function startAutoplay() {\n    if (destroyed)\n      return;\n    if (documentIsHidden()) {\n      playOnDocumentVisible = true;\n      return;\n    }\n    if (!autoplayActive)\n      emblaApi.emit(\"autoplay:play\");\n    setTimer();\n    autoplayActive = true;\n  }\n  function stopAutoplay() {\n    if (destroyed)\n      return;\n    if (autoplayActive)\n      emblaApi.emit(\"autoplay:stop\");\n    clearTimer();\n    autoplayActive = false;\n  }\n  function visibilityChange() {\n    if (documentIsHidden()) {\n      playOnDocumentVisible = autoplayActive;\n      return stopAutoplay();\n    }\n    if (playOnDocumentVisible)\n      startAutoplay();\n  }\n  function documentIsHidden() {\n    const {\n      ownerDocument\n    } = emblaApi.internalEngine();\n    return ownerDocument.visibilityState === \"hidden\";\n  }\n  function pointerDown() {\n    if (!mouseIsOver)\n      stopAutoplay();\n  }\n  function pointerUp() {\n    if (!mouseIsOver)\n      startAutoplay();\n  }\n  function mouseEnter() {\n    mouseIsOver = true;\n    stopAutoplay();\n  }\n  function mouseLeave() {\n    mouseIsOver = false;\n    startAutoplay();\n  }\n  function play(jumpOverride) {\n    if (typeof jumpOverride !== \"undefined\")\n      jump = jumpOverride;\n    startAutoplay();\n  }\n  function stop() {\n    if (autoplayActive)\n      stopAutoplay();\n  }\n  function reset() {\n    if (autoplayActive)\n      startAutoplay();\n  }\n  function isPlaying() {\n    return autoplayActive;\n  }\n  function next() {\n    const {\n      index\n    } = emblaApi.internalEngine();\n    const nextIndex = index.clone().add(1).get();\n    const lastIndex = emblaApi.scrollSnapList().length - 1;\n    const kill = options.stopOnLastSnap && nextIndex === lastIndex;\n    if (emblaApi.canScrollNext()) {\n      emblaApi.scrollNext(jump);\n    } else {\n      emblaApi.scrollTo(0, jump);\n    }\n    emblaApi.emit(\"autoplay:select\");\n    if (kill)\n      return stopAutoplay();\n    startAutoplay();\n  }\n  function timeUntilNext() {\n    if (!timerStartTime)\n      return null;\n    const currentDelay = delay[emblaApi.selectedScrollSnap()];\n    const timePastSinceStart = new Date().getTime() - timerStartTime;\n    return currentDelay - timePastSinceStart;\n  }\n  const self = {\n    name: \"autoplay\",\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying,\n    timeUntilNext\n  };\n  return self;\n}\nAutoplay.globalOptions = void 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtYXV0b3BsYXkvZXNtL2VtYmxhLWNhcm91c2VsLWF1dG9wbGF5LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTSxpQkFBaUI7QUFBQSxFQUNyQixRQUFRO0FBQUEsRUFDUixhQUFhLENBQUM7QUFBQSxFQUNkLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLGVBQWU7QUFBQSxFQUNmLG1CQUFtQjtBQUFBLEVBQ25CLGtCQUFrQjtBQUFBLEVBQ2xCLGdCQUFnQjtBQUFBLEVBQ2hCLFVBQVU7QUFDWjtBQUVBLFNBQVMsZUFBZSxVQUFVLE9BQU87QUFDdkMsUUFBTSxjQUFjLFNBQVMsZUFBZTtBQUM1QyxNQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLFdBQU8sWUFBWSxJQUFJLE1BQU0sS0FBSztBQUFBLEVBQ3BDO0FBQ0EsU0FBTyxNQUFNLGFBQWEsUUFBUTtBQUNwQztBQUNBLFNBQVMsb0JBQW9CLFVBQVUsVUFBVTtBQUMvQyxRQUFNLGdCQUFnQixTQUFTLFNBQVM7QUFDeEMsU0FBTyxZQUFZLFNBQVMsYUFBYSxLQUFLO0FBQ2hEO0FBRUEsU0FBUyxTQUFTLGNBQWMsQ0FBQyxHQUFHO0FBQ2xDLE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSTtBQUNKLE1BQUk7QUFDSixNQUFJLGlCQUFpQjtBQUNyQixNQUFJLFVBQVU7QUFDZCxNQUFJLGlCQUFpQjtBQUNyQixNQUFJLGNBQWM7QUFDbEIsTUFBSSx3QkFBd0I7QUFDNUIsTUFBSSxPQUFPO0FBQ1gsV0FBUyxLQUFLLGtCQUFrQixnQkFBZ0I7QUFDOUMsZUFBVztBQUNYLFVBQU07QUFBQSxNQUNKO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSTtBQUNKLFVBQU0sY0FBYyxhQUFhLGdCQUFnQixTQUFTLGFBQWE7QUFDdkUsVUFBTSxhQUFhLGFBQWEsYUFBYSxXQUFXO0FBQ3hELGNBQVUsZUFBZSxVQUFVO0FBQ25DLFFBQUksU0FB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U0FBUyxnQkFBZ0I7QUFFTSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpZnktc3RhcnRlci8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC1hdXRvcGxheS9lc20vZW1ibGEtY2Fyb3VzZWwtYXV0b3BsYXkuZXNtLmpzP2ZmNjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFjdGl2ZTogdHJ1ZSxcbiAgYnJlYWtwb2ludHM6IHt9LFxuICBkZWxheTogNDAwMCxcbiAganVtcDogZmFsc2UsXG4gIHBsYXlPbkluaXQ6IHRydWUsXG4gIHN0b3BPbkZvY3VzSW46IHRydWUsXG4gIHN0b3BPbkludGVyYWN0aW9uOiB0cnVlLFxuICBzdG9wT25Nb3VzZUVudGVyOiBmYWxzZSxcbiAgc3RvcE9uTGFzdFNuYXA6IGZhbHNlLFxuICByb290Tm9kZTogbnVsbFxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGVsYXkoZW1ibGFBcGksIGRlbGF5KSB7XG4gIGNvbnN0IHNjcm9sbFNuYXBzID0gZW1ibGFBcGkuc2Nyb2xsU25hcExpc3QoKTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gc2Nyb2xsU25hcHMubWFwKCgpID0+IGRlbGF5KTtcbiAgfVxuICByZXR1cm4gZGVsYXkoc2Nyb2xsU25hcHMsIGVtYmxhQXBpKTtcbn1cbmZ1bmN0aW9uIGdldEF1dG9wbGF5Um9vdE5vZGUoZW1ibGFBcGksIHJvb3ROb2RlKSB7XG4gIGNvbnN0IGVtYmxhUm9vdE5vZGUgPSBlbWJsYUFwaS5yb290Tm9kZSgpO1xuICByZXR1cm4gcm9vdE5vZGUgJiYgcm9vdE5vZGUoZW1ibGFSb290Tm9kZSkgfHwgZW1ibGFSb290Tm9kZTtcbn1cblxuZnVuY3Rpb24gQXV0b3BsYXkodXNlck9wdGlvbnMgPSB7fSkge1xuICBsZXQgb3B0aW9ucztcbiAgbGV0IGVtYmxhQXBpO1xuICBsZXQgZGVzdHJveWVkO1xuICBsZXQgZGVsYXk7XG4gIGxldCB0aW1lclN0YXJ0VGltZSA9IG51bGw7XG4gIGxldCB0aW1lcklkID0gMDtcbiAgbGV0IGF1dG9wbGF5QWN0aXZlID0gZmFsc2U7XG4gIGxldCBtb3VzZUlzT3ZlciA9IGZhbHNlO1xuICBsZXQgcGxheU9uRG9jdW1lbnRWaXNpYmxlID0gZmFsc2U7XG4gIGxldCBqdW1wID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGlJbnN0YW5jZSwgb3B0aW9uc0hhbmRsZXIpIHtcbiAgICBlbWJsYUFwaSA9IGVtYmxhQXBpSW5zdGFuY2U7XG4gICAgY29uc3Qge1xuICAgICAgbWVyZ2VPcHRpb25zLFxuICAgICAgb3B0aW9uc0F0TWVkaWFcbiAgICB9ID0gb3B0aW9uc0hhbmRsZXI7XG4gICAgY29uc3Qgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIEF1dG9wbGF5Lmdsb2JhbE9wdGlvbnMpO1xuICAgIGNvbnN0IGFsbE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UsIHVzZXJPcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9uc0F0TWVkaWEoYWxsT3B0aW9ucyk7XG4gICAgaWYgKGVtYmxhQXBpLnNjcm9sbFNuYXBMaXN0KCkubGVuZ3RoIDw9IDEpIHJldHVybjtcbiAgICBqdW1wID0gb3B0aW9ucy5qdW1wO1xuICAgIGRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIGRlbGF5ID0gbm9ybWFsaXplRGVsYXkoZW1ibGFBcGksIG9wdGlvbnMuZGVsYXkpO1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50U3RvcmUsXG4gICAgICBvd25lckRvY3VtZW50XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIWVtYmxhQXBpLmludGVybmFsRW5naW5lKCkub3B0aW9ucy53YXRjaERyYWc7XG4gICAgY29uc3Qgcm9vdCA9IGdldEF1dG9wbGF5Um9vdE5vZGUoZW1ibGFBcGksIG9wdGlvbnMucm9vdE5vZGUpO1xuICAgIGV2ZW50U3RvcmUuYWRkKG93bmVyRG9jdW1lbnQsICd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgaWYgKGlzRHJhZ2dhYmxlKSB7XG4gICAgICBlbWJsYUFwaS5vbigncG9pbnRlckRvd24nLCBwb2ludGVyRG93bik7XG4gICAgfVxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiAhb3B0aW9ucy5zdG9wT25JbnRlcmFjdGlvbikge1xuICAgICAgZW1ibGFBcGkub24oJ3BvaW50ZXJVcCcsIHBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0b3BPbk1vdXNlRW50ZXIpIHtcbiAgICAgIGV2ZW50U3RvcmUuYWRkKHJvb3QsICdtb3VzZWVudGVyJywgbW91c2VFbnRlcik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0b3BPbk1vdXNlRW50ZXIgJiYgIW9wdGlvbnMuc3RvcE9uSW50ZXJhY3Rpb24pIHtcbiAgICAgIGV2ZW50U3RvcmUuYWRkKHJvb3QsICdtb3VzZWxlYXZlJywgbW91c2VMZWF2ZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0b3BPbkZvY3VzSW4pIHtcbiAgICAgIGVtYmxhQXBpLm9uKCdzbGlkZUZvY3VzU3RhcnQnLCBzdG9wQXV0b3BsYXkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdG9wT25Gb2N1c0luICYmICFvcHRpb25zLnN0b3BPbkludGVyYWN0aW9uKSB7XG4gICAgICBldmVudFN0b3JlLmFkZChlbWJsYUFwaS5jb250YWluZXJOb2RlKCksICdmb2N1c291dCcsIHN0YXJ0QXV0b3BsYXkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wbGF5T25Jbml0KSBzdGFydEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBlbWJsYUFwaS5vZmYoJ3BvaW50ZXJEb3duJywgcG9pbnRlckRvd24pLm9mZigncG9pbnRlclVwJywgcG9pbnRlclVwKS5vZmYoJ3NsaWRlRm9jdXNTdGFydCcsIHN0b3BBdXRvcGxheSk7XG4gICAgc3RvcEF1dG9wbGF5KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBhdXRvcGxheUFjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHNldFRpbWVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyV2luZG93XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgb3duZXJXaW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIHRpbWVySWQgPSBvd25lcldpbmRvdy5zZXRUaW1lb3V0KG5leHQsIGRlbGF5W2VtYmxhQXBpLnNlbGVjdGVkU2Nyb2xsU25hcCgpXSk7XG4gICAgdGltZXJTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBlbWJsYUFwaS5lbWl0KCdhdXRvcGxheTp0aW1lcnNldCcpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJXaW5kb3dcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBvd25lcldpbmRvdy5jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgdGltZXJJZCA9IDA7XG4gICAgdGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgIGVtYmxhQXBpLmVtaXQoJ2F1dG9wbGF5OnRpbWVyc3RvcHBlZCcpO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0QXV0b3BsYXkoKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGlmIChkb2N1bWVudElzSGlkZGVuKCkpIHtcbiAgICAgIHBsYXlPbkRvY3VtZW50VmlzaWJsZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghYXV0b3BsYXlBY3RpdmUpIGVtYmxhQXBpLmVtaXQoJ2F1dG9wbGF5OnBsYXknKTtcbiAgICBzZXRUaW1lcigpO1xuICAgIGF1dG9wbGF5QWN0aXZlID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wQXV0b3BsYXkoKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGlmIChhdXRvcGxheUFjdGl2ZSkgZW1ibGFBcGkuZW1pdCgnYXV0b3BsYXk6c3RvcCcpO1xuICAgIGNsZWFyVGltZXIoKTtcbiAgICBhdXRvcGxheUFjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKGRvY3VtZW50SXNIaWRkZW4oKSkge1xuICAgICAgcGxheU9uRG9jdW1lbnRWaXNpYmxlID0gYXV0b3BsYXlBY3RpdmU7XG4gICAgICByZXR1cm4gc3RvcEF1dG9wbGF5KCk7XG4gICAgfVxuICAgIGlmIChwbGF5T25Eb2N1bWVudFZpc2libGUpIHN0YXJ0QXV0b3BsYXkoKTtcbiAgfVxuICBmdW5jdGlvbiBkb2N1bWVudElzSGlkZGVuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyRG9jdW1lbnRcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJEb3duKCkge1xuICAgIGlmICghbW91c2VJc092ZXIpIHN0b3BBdXRvcGxheSgpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJVcCgpIHtcbiAgICBpZiAoIW1vdXNlSXNPdmVyKSBzdGFydEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gbW91c2VFbnRlcigpIHtcbiAgICBtb3VzZUlzT3ZlciA9IHRydWU7XG4gICAgc3RvcEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gbW91c2VMZWF2ZSgpIHtcbiAgICBtb3VzZUlzT3ZlciA9IGZhbHNlO1xuICAgIHN0YXJ0QXV0b3BsYXkoKTtcbiAgfVxuICBmdW5jdGlvbiBwbGF5KGp1bXBPdmVycmlkZSkge1xuICAgIGlmICh0eXBlb2YganVtcE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJykganVtcCA9IGp1bXBPdmVycmlkZTtcbiAgICBzdGFydEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoYXV0b3BsYXlBY3RpdmUpIHN0b3BBdXRvcGxheSgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmIChhdXRvcGxheUFjdGl2ZSkgc3RhcnRBdXRvcGxheSgpO1xuICB9XG4gIGZ1bmN0aW9uIGlzUGxheWluZygpIHtcbiAgICByZXR1cm4gYXV0b3BsYXlBY3RpdmU7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmRleFxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IGluZGV4LmNsb25lKCkuYWRkKDEpLmdldCgpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGVtYmxhQXBpLnNjcm9sbFNuYXBMaXN0KCkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBraWxsID0gb3B0aW9ucy5zdG9wT25MYXN0U25hcCAmJiBuZXh0SW5kZXggPT09IGxhc3RJbmRleDtcbiAgICBpZiAoZW1ibGFBcGkuY2FuU2Nyb2xsTmV4dCgpKSB7XG4gICAgICBlbWJsYUFwaS5zY3JvbGxOZXh0KGp1bXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWJsYUFwaS5zY3JvbGxUbygwLCBqdW1wKTtcbiAgICB9XG4gICAgZW1ibGFBcGkuZW1pdCgnYXV0b3BsYXk6c2VsZWN0Jyk7XG4gICAgaWYgKGtpbGwpIHJldHVybiBzdG9wQXV0b3BsYXkoKTtcbiAgICBzdGFydEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gdGltZVVudGlsTmV4dCgpIHtcbiAgICBpZiAoIXRpbWVyU3RhcnRUaW1lKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjdXJyZW50RGVsYXkgPSBkZWxheVtlbWJsYUFwaS5zZWxlY3RlZFNjcm9sbFNuYXAoKV07XG4gICAgY29uc3QgdGltZVBhc3RTaW5jZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aW1lclN0YXJ0VGltZTtcbiAgICByZXR1cm4gY3VycmVudERlbGF5IC0gdGltZVBhc3RTaW5jZVN0YXJ0O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbmFtZTogJ2F1dG9wbGF5JyxcbiAgICBvcHRpb25zOiB1c2VyT3B0aW9ucyxcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgcGxheSxcbiAgICBzdG9wLFxuICAgIHJlc2V0LFxuICAgIGlzUGxheWluZyxcbiAgICB0aW1lVW50aWxOZXh0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuQXV0b3BsYXkuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgQXV0b3BsYXkgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1ibGEtY2Fyb3VzZWwtYXV0b3BsYXkuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js\n\n}");

/***/ }),

/***/ "./node_modules/embla-carousel-class-names/esm/embla-carousel-class-names.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/embla-carousel-class-names/esm/embla-carousel-class-names.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ClassNames)\n/* harmony export */ });\nconst defaultOptions = {\n  active: true,\n  breakpoints: {},\n  snapped: \"is-snapped\",\n  inView: \"is-in-view\",\n  draggable: \"is-draggable\",\n  dragging: \"is-dragging\",\n  loop: \"is-loop\"\n};\nfunction normalizeClassNames(classNames) {\n  const normalized = Array.isArray(classNames) ? classNames : [classNames];\n  return normalized.filter(Boolean);\n}\nfunction removeClass(node, classNames) {\n  if (!node || !classNames.length)\n    return;\n  node.classList.remove(...classNames);\n}\nfunction addClass(node, classNames) {\n  if (!node || !classNames.length)\n    return;\n  node.classList.add(...classNames);\n}\nfunction ClassNames(userOptions = {}) {\n  let options;\n  let emblaApi;\n  let root;\n  let slides;\n  let snappedIndexes = [];\n  let inViewIndexes = [];\n  const selectedEvents = [\"select\"];\n  const draggingEvents = [\"pointerDown\", \"pointerUp\"];\n  const inViewEvents = [\"slidesInView\"];\n  const classNames = {\n    snapped: [],\n    inView: [],\n    draggable: [],\n    dragging: [],\n    loop: []\n  };\n  function init(emblaApiInstance, optionsHandler) {\n    emblaApi = emblaApiInstance;\n    const {\n      mergeOptions,\n      optionsAtMedia\n    } = optionsHandler;\n    const optionsBase = mergeOptions(defaultOptions, ClassNames.globalOptions);\n    const allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    root = emblaApi.rootNode();\n    slides = emblaApi.slideNodes();\n    const {\n      watchDrag,\n      loop\n    } = emblaApi.internalEngine().options;\n    const isDraggable = !!watchDrag;\n    if (options.loop && loop) {\n      classNames.loop = normalizeClassNames(options.loop);\n      addClass(root, classNames.loop);\n    }\n    if (options.draggable && isDraggable) {\n      classNames.draggable = normalizeClassNames(options.draggable);\n      addClass(root, classNames.draggable);\n    }\n    if (options.dragging) {\n      classNames.dragging = normalizeClassNames(options.dragging);\n      draggingEvents.forEach((evt) => emblaApi.on(evt, toggleDraggingClass));\n    }\n    if (options.snapped) {\n      classNames.snapped = normalizeClassNames(options.snapped);\n      selectedEvents.forEach((evt) => emblaApi.on(evt, toggleSnappedClasses));\n      toggleSnappedClasses();\n    }\n    if (options.inView) {\n      classNames.inView = normalizeClassNames(options.inView);\n      inViewEvents.forEach((evt) => emblaApi.on(evt, toggleInViewClasses));\n      toggleInViewClasses();\n    }\n  }\n  function destroy() {\n    draggingEvents.forEach((evt) => emblaApi.off(evt, toggleDraggingClass));\n    selectedEvents.forEach((evt) => emblaApi.off(evt, toggleSnappedClasses));\n    inViewEvents.forEach((evt) => emblaApi.off(evt, toggleInViewClasses));\n    removeClass(root, classNames.loop);\n    removeClass(root, classNames.draggable);\n    removeClass(root, classNames.dragging);\n    toggleSlideClasses([], snappedIndexes, classNames.snapped);\n    toggleSlideClasses([], inViewIndexes, classNames.inView);\n    Object.keys(classNames).forEach((classNameKey) => {\n      const key = classNameKey;\n      classNames[key] = [];\n    });\n  }\n  function toggleDraggingClass(_, evt) {\n    const toggleClass = evt === \"pointerDown\" ? addClass : removeClass;\n    toggleClass(root, classNames.dragging);\n  }\n  function toggleSlideClasses(addClassIndexes = [], removeClassIndexes = [], classNames2) {\n    const removeClassSlides = removeClassIndexes.map((index) => slides[index]);\n    const addClassSlides = addClassIndexes.map((index) => slides[index]);\n    removeClassSlides.forEach((slide) => removeClass(slide, classNames2));\n    addClassSlides.forEach((slide) => addClass(slide, classNames2));\n    return addClassIndexes;\n  }\n  function toggleSnappedClasses() {\n    const {\n      slideRegistry\n    } = emblaApi.internalEngine();\n    const newSnappedIndexes = slideRegistry[emblaApi.selectedScrollSnap()];\n    snappedIndexes = toggleSlideClasses(newSnappedIndexes, snappedIndexes, classNames.snapped);\n  }\n  function toggleInViewClasses() {\n    const newInViewIndexes = emblaApi.slidesInView();\n    inViewIndexes = toggleSlideClasses(newInViewIndexes, inViewIndexes, classNames.inView);\n  }\n  const self = {\n    name: \"classNames\",\n    options: userOptions,\n    init,\n    destroy\n  };\n  return self;\n}\nClassNames.globalOptions = void 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtY2xhc3MtbmFtZXMvZXNtL2VtYmxhLWNhcm91c2VsLWNsYXNzLW5hbWVzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTSxpQkFBaUI7QUFBQSxFQUNyQixRQUFRO0FBQUEsRUFDUixhQUFhLENBQUM7QUFBQSxFQUNkLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFdBQVc7QUFBQSxFQUNYLFVBQVU7QUFBQSxFQUNWLE1BQU07QUFDUjtBQUVBLFNBQVMsb0JBQW9CLFlBQVk7QUFDdkMsUUFBTSxhQUFhLE1BQU0sUUFBUSxVQUFVLElBQUksYUFBYSxDQUFDLFVBQVU7QUFDdkUsU0FBTyxXQUFXLE9BQU8sT0FBTztBQUNsQztBQUNBLFNBQVMsWUFBWSxNQUFNLFlBQVk7QUFDckMsTUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXO0FBQVE7QUFDakMsT0FBSyxVQUFVLE9BQU8sR0FBRyxVQUFVO0FBQ3JDO0FBQ0EsU0FBUyxTQUFTLE1BQU0sWUFBWTtBQUNsQyxNQUFJLENBQUMsUUFBUSxDQUFDLFdBQVc7QUFBUTtBQUNqQyxPQUFLLFVBQVUsSUFBSSxHQUFHLFVBQVU7QUFDbEM7QUFFQSxTQUFTLFdBQVcsY0FBYyxDQUFDLEdBQUc7QUFDcEMsTUFBSTtBQUNKLE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSTtBQUNKLE1BQUksaUJBQWlCLENBQUM7QUFDdEIsTUFBSSxnQkFBZ0IsQ0FBQztBQUNyQixRQUFNLGlCQUFpQixDQUFDLFFBQVE7QUFDaEMsUUFBTSxpQkFBaUIsQ0FBQyxlQUFlLFdBQVc7QUFDbEQsUUFBTSxlQUFlLENBQUMsY0FBYztBQUNwQyxRQUFNLGFBQWE7QUFBQSxJQUNqQixTQUFTLENBQUM7QUFBQSxJQUNWLFFBQVEsQ0FBQztBQUFBLElBQ1QsV0FBVyxDQUFDO0FBQUEsSUFDWixVQUFVLENBQUM7QUFBQSxJQUNYLE1BQU0sQ0FBQztBQUFBLEVBQ1Q7QUFDQSxXQUFTLEtBQUssa0JB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QzNGO0FBQ0EsV0FBUyxzQkFBc0I7QUFDN0IsVUFBTSxtQkFBbUIsU0FBUyxhQUFhO0FBQy9DLG9CQUFnQixtQkFBbUIsa0JBQWtCLGVBQWUsV0FBVyxNQUFNO0FBQUEsRUFDdkY7QUFDQSxRQUFNLE9BQU87QUFBQSxJQUNYLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNUO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxXQUFXLGdCQUFnQjtBQUVNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hvcGlmeS1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL2VtYmxhLWNhcm91c2VsLWNsYXNzLW5hbWVzL2VzbS9lbWJsYS1jYXJvdXNlbC1jbGFzcy1uYW1lcy5lc20uanM/ZWNjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWN0aXZlOiB0cnVlLFxuICBicmVha3BvaW50czoge30sXG4gIHNuYXBwZWQ6ICdpcy1zbmFwcGVkJyxcbiAgaW5WaWV3OiAnaXMtaW4tdmlldycsXG4gIGRyYWdnYWJsZTogJ2lzLWRyYWdnYWJsZScsXG4gIGRyYWdnaW5nOiAnaXMtZHJhZ2dpbmcnLFxuICBsb29wOiAnaXMtbG9vcCdcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoY2xhc3NOYW1lcykge1xuICBjb25zdCBub3JtYWxpemVkID0gQXJyYXkuaXNBcnJheShjbGFzc05hbWVzKSA/IGNsYXNzTmFtZXMgOiBbY2xhc3NOYW1lc107XG4gIHJldHVybiBub3JtYWxpemVkLmZpbHRlcihCb29sZWFuKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZXMpIHtcbiAgaWYgKCFub2RlIHx8ICFjbGFzc05hbWVzLmxlbmd0aCkgcmV0dXJuO1xuICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG59XG5mdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbGFzc05hbWVzKSB7XG4gIGlmICghbm9kZSB8fCAhY2xhc3NOYW1lcy5sZW5ndGgpIHJldHVybjtcbiAgbm9kZS5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xufVxuXG5mdW5jdGlvbiBDbGFzc05hbWVzKHVzZXJPcHRpb25zID0ge30pIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGxldCBlbWJsYUFwaTtcbiAgbGV0IHJvb3Q7XG4gIGxldCBzbGlkZXM7XG4gIGxldCBzbmFwcGVkSW5kZXhlcyA9IFtdO1xuICBsZXQgaW5WaWV3SW5kZXhlcyA9IFtdO1xuICBjb25zdCBzZWxlY3RlZEV2ZW50cyA9IFsnc2VsZWN0J107XG4gIGNvbnN0IGRyYWdnaW5nRXZlbnRzID0gWydwb2ludGVyRG93bicsICdwb2ludGVyVXAnXTtcbiAgY29uc3QgaW5WaWV3RXZlbnRzID0gWydzbGlkZXNJblZpZXcnXTtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IHtcbiAgICBzbmFwcGVkOiBbXSxcbiAgICBpblZpZXc6IFtdLFxuICAgIGRyYWdnYWJsZTogW10sXG4gICAgZHJhZ2dpbmc6IFtdLFxuICAgIGxvb3A6IFtdXG4gIH07XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGlJbnN0YW5jZSwgb3B0aW9uc0hhbmRsZXIpIHtcbiAgICBlbWJsYUFwaSA9IGVtYmxhQXBpSW5zdGFuY2U7XG4gICAgY29uc3Qge1xuICAgICAgbWVyZ2VPcHRpb25zLFxuICAgICAgb3B0aW9uc0F0TWVkaWFcbiAgICB9ID0gb3B0aW9uc0hhbmRsZXI7XG4gICAgY29uc3Qgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIENsYXNzTmFtZXMuZ2xvYmFsT3B0aW9ucyk7XG4gICAgY29uc3QgYWxsT3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zQmFzZSwgdXNlck9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zQXRNZWRpYShhbGxPcHRpb25zKTtcbiAgICByb290ID0gZW1ibGFBcGkucm9vdE5vZGUoKTtcbiAgICBzbGlkZXMgPSBlbWJsYUFwaS5zbGlkZU5vZGVzKCk7XG4gICAgY29uc3Qge1xuICAgICAgd2F0Y2hEcmFnLFxuICAgICAgbG9vcFxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpLm9wdGlvbnM7XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXdhdGNoRHJhZztcbiAgICBpZiAob3B0aW9ucy5sb29wICYmIGxvb3ApIHtcbiAgICAgIGNsYXNzTmFtZXMubG9vcCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy5sb29wKTtcbiAgICAgIGFkZENsYXNzKHJvb3QsIGNsYXNzTmFtZXMubG9vcCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRyYWdnYWJsZSAmJiBpc0RyYWdnYWJsZSkge1xuICAgICAgY2xhc3NOYW1lcy5kcmFnZ2FibGUgPSBub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICAgIGFkZENsYXNzKHJvb3QsIGNsYXNzTmFtZXMuZHJhZ2dhYmxlKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZHJhZ2dpbmcpIHtcbiAgICAgIGNsYXNzTmFtZXMuZHJhZ2dpbmcgPSBub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuZHJhZ2dpbmcpO1xuICAgICAgZHJhZ2dpbmdFdmVudHMuZm9yRWFjaChldnQgPT4gZW1ibGFBcGkub24oZXZ0LCB0b2dnbGVEcmFnZ2luZ0NsYXNzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNuYXBwZWQpIHtcbiAgICAgIGNsYXNzTmFtZXMuc25hcHBlZCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy5zbmFwcGVkKTtcbiAgICAgIHNlbGVjdGVkRXZlbnRzLmZvckVhY2goZXZ0ID0+IGVtYmxhQXBpLm9uKGV2dCwgdG9nZ2xlU25hcHBlZENsYXNzZXMpKTtcbiAgICAgIHRvZ2dsZVNuYXBwZWRDbGFzc2VzKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluVmlldykge1xuICAgICAgY2xhc3NOYW1lcy5pblZpZXcgPSBub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuaW5WaWV3KTtcbiAgICAgIGluVmlld0V2ZW50cy5mb3JFYWNoKGV2dCA9PiBlbWJsYUFwaS5vbihldnQsIHRvZ2dsZUluVmlld0NsYXNzZXMpKTtcbiAgICAgIHRvZ2dsZUluVmlld0NsYXNzZXMoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBkcmFnZ2luZ0V2ZW50cy5mb3JFYWNoKGV2dCA9PiBlbWJsYUFwaS5vZmYoZXZ0LCB0b2dnbGVEcmFnZ2luZ0NsYXNzKSk7XG4gICAgc2VsZWN0ZWRFdmVudHMuZm9yRWFjaChldnQgPT4gZW1ibGFBcGkub2ZmKGV2dCwgdG9nZ2xlU25hcHBlZENsYXNzZXMpKTtcbiAgICBpblZpZXdFdmVudHMuZm9yRWFjaChldnQgPT4gZW1ibGFBcGkub2ZmKGV2dCwgdG9nZ2xlSW5WaWV3Q2xhc3NlcykpO1xuICAgIHJlbW92ZUNsYXNzKHJvb3QsIGNsYXNzTmFtZXMubG9vcCk7XG4gICAgcmVtb3ZlQ2xhc3Mocm9vdCwgY2xhc3NOYW1lcy5kcmFnZ2FibGUpO1xuICAgIHJlbW92ZUNsYXNzKHJvb3QsIGNsYXNzTmFtZXMuZHJhZ2dpbmcpO1xuICAgIHRvZ2dsZVNsaWRlQ2xhc3NlcyhbXSwgc25hcHBlZEluZGV4ZXMsIGNsYXNzTmFtZXMuc25hcHBlZCk7XG4gICAgdG9nZ2xlU2xpZGVDbGFzc2VzKFtdLCBpblZpZXdJbmRleGVzLCBjbGFzc05hbWVzLmluVmlldyk7XG4gICAgT2JqZWN0LmtleXMoY2xhc3NOYW1lcykuZm9yRWFjaChjbGFzc05hbWVLZXkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gY2xhc3NOYW1lS2V5O1xuICAgICAgY2xhc3NOYW1lc1trZXldID0gW107XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRHJhZ2dpbmdDbGFzcyhfLCBldnQpIHtcbiAgICBjb25zdCB0b2dnbGVDbGFzcyA9IGV2dCA9PT0gJ3BvaW50ZXJEb3duJyA/IGFkZENsYXNzIDogcmVtb3ZlQ2xhc3M7XG4gICAgdG9nZ2xlQ2xhc3Mocm9vdCwgY2xhc3NOYW1lcy5kcmFnZ2luZyk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlU2xpZGVDbGFzc2VzKGFkZENsYXNzSW5kZXhlcyA9IFtdLCByZW1vdmVDbGFzc0luZGV4ZXMgPSBbXSwgY2xhc3NOYW1lcykge1xuICAgIGNvbnN0IHJlbW92ZUNsYXNzU2xpZGVzID0gcmVtb3ZlQ2xhc3NJbmRleGVzLm1hcChpbmRleCA9PiBzbGlkZXNbaW5kZXhdKTtcbiAgICBjb25zdCBhZGRDbGFzc1NsaWRlcyA9IGFkZENsYXNzSW5kZXhlcy5tYXAoaW5kZXggPT4gc2xpZGVzW2luZGV4XSk7XG4gICAgcmVtb3ZlQ2xhc3NTbGlkZXMuZm9yRWFjaChzbGlkZSA9PiByZW1vdmVDbGFzcyhzbGlkZSwgY2xhc3NOYW1lcykpO1xuICAgIGFkZENsYXNzU2xpZGVzLmZvckVhY2goc2xpZGUgPT4gYWRkQ2xhc3Moc2xpZGUsIGNsYXNzTmFtZXMpKTtcbiAgICByZXR1cm4gYWRkQ2xhc3NJbmRleGVzO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZVNuYXBwZWRDbGFzc2VzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNsaWRlUmVnaXN0cnlcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBuZXdTbmFwcGVkSW5kZXhlcyA9IHNsaWRlUmVnaXN0cnlbZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCldO1xuICAgIHNuYXBwZWRJbmRleGVzID0gdG9nZ2xlU2xpZGVDbGFzc2VzKG5ld1NuYXBwZWRJbmRleGVzLCBzbmFwcGVkSW5kZXhlcywgY2xhc3NOYW1lcy5zbmFwcGVkKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVJblZpZXdDbGFzc2VzKCkge1xuICAgIGNvbnN0IG5ld0luVmlld0luZGV4ZXMgPSBlbWJsYUFwaS5zbGlkZXNJblZpZXcoKTtcbiAgICBpblZpZXdJbmRleGVzID0gdG9nZ2xlU2xpZGVDbGFzc2VzKG5ld0luVmlld0luZGV4ZXMsIGluVmlld0luZGV4ZXMsIGNsYXNzTmFtZXMuaW5WaWV3KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG5hbWU6ICdjbGFzc05hbWVzJyxcbiAgICBvcHRpb25zOiB1c2VyT3B0aW9ucyxcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5DbGFzc05hbWVzLmdsb2JhbE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7IENsYXNzTmFtZXMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1ibGEtY2Fyb3VzZWwtY2xhc3MtbmFtZXMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNsYXNzTmFtZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/embla-carousel-class-names/esm/embla-carousel-class-names.esm.js\n\n}");

/***/ }),

/***/ "./node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fade)\n/* harmony export */ });\nfunction clampNumber(number, min, max) {\n  return Math.min(Math.max(number, min), max);\n}\nfunction isNumber(value) {\n  return typeof value === \"number\" && !isNaN(value);\n}\nfunction Fade(userOptions = {}) {\n  const fullOpacity = 1;\n  const noOpacity = 0;\n  const fadeFriction = 0.68;\n  let emblaApi;\n  let opacities = [];\n  let fadeToNextDistance;\n  let distanceFromPointerDown = 0;\n  let fadeVelocity = 0;\n  let progress = 0;\n  let shouldFadePair = false;\n  let defaultSettledBehaviour;\n  let defaultProgressBehaviour;\n  function init(emblaApiInstance) {\n    emblaApi = emblaApiInstance;\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    const {\n      scrollBody,\n      containerRect,\n      axis\n    } = emblaApi.internalEngine();\n    const containerSize = axis.measureSize(containerRect);\n    fadeToNextDistance = clampNumber(containerSize * 0.75, 200, 500);\n    shouldFadePair = false;\n    opacities = emblaApi.scrollSnapList().map((_, index) => index === selectedSnap ? fullOpacity : noOpacity);\n    defaultSettledBehaviour = scrollBody.settled;\n    defaultProgressBehaviour = emblaApi.scrollProgress;\n    scrollBody.settled = settled;\n    emblaApi.scrollProgress = scrollProgress;\n    emblaApi.on(\"select\", select).on(\"slideFocus\", fadeToSelectedSnapInstantly).on(\"pointerDown\", pointerDown).on(\"pointerUp\", pointerUp);\n    disableScroll();\n    fadeToSelectedSnapInstantly();\n  }\n  function destroy() {\n    const {\n      scrollBody\n    } = emblaApi.internalEngine();\n    scrollBody.settled = defaultSettledBehaviour;\n    emblaApi.scrollProgress = defaultProgressBehaviour;\n    emblaApi.off(\"select\", select).off(\"slideFocus\", fadeToSelectedSnapInstantly).off(\"pointerDown\", pointerDown).off(\"pointerUp\", pointerUp);\n    emblaApi.slideNodes().forEach((slideNode) => {\n      const slideStyle = slideNode.style;\n      slideStyle.opacity = \"\";\n      slideStyle.transform = \"\";\n      slideStyle.pointerEvents = \"\";\n      if (!slideNode.getAttribute(\"style\"))\n        slideNode.removeAttribute(\"style\");\n    });\n  }\n  function fadeToSelectedSnapInstantly() {\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    setOpacities(selectedSnap, fullOpacity);\n  }\n  function pointerUp() {\n    shouldFadePair = false;\n  }\n  function pointerDown() {\n    shouldFadePair = false;\n    distanceFromPointerDown = 0;\n    fadeVelocity = 0;\n  }\n  function select() {\n    const duration = emblaApi.internalEngine().scrollBody.duration();\n    fadeVelocity = duration ? 0 : fullOpacity;\n    shouldFadePair = true;\n    if (!duration)\n      fadeToSelectedSnapInstantly();\n  }\n  function getSlideTransform(position) {\n    const {\n      axis\n    } = emblaApi.internalEngine();\n    const translateAxis = axis.scroll.toUpperCase();\n    return `translate${translateAxis}(${axis.direction(position)}px)`;\n  }\n  function disableScroll() {\n    const {\n      translate,\n      slideLooper\n    } = emblaApi.internalEngine();\n    translate.clear();\n    translate.toggleActive(false);\n    slideLooper.loopPoints.forEach(({\n      translate: translate2\n    }) => {\n      translate2.clear();\n      translate2.toggleActive(false);\n    });\n  }\n  function lockExcessiveScroll(fadeIndex) {\n    const {\n      scrollSnaps,\n      location,\n      target\n    } = emblaApi.internalEngine();\n    if (!isNumber(fadeIndex) || opacities[fadeIndex] < 0.5)\n      return;\n    location.set(scrollSnaps[fadeIndex]);\n    target.set(location);\n  }\n  function setOpacities(fadeIndex, velocity) {\n    const scrollSnaps = emblaApi.scrollSnapList();\n    scrollSnaps.forEach((_, indexA) => {\n      const absVelocity = Math.abs(velocity);\n      const currentOpacity = opacities[indexA];\n      const isFadeIndex = indexA === fadeIndex;\n      const nextOpacity = isFadeIndex ? currentOpacity + absVelocity : currentOpacity - absVelocity;\n      const clampedOpacity = clampNumber(nextOpacity, noOpacity, fullOpacity);\n      opacities[indexA] = clampedOpacity;\n      const fadePair = isFadeIndex && shouldFadePair;\n      const indexB = emblaApi.previousScrollSnap();\n      if (fadePair)\n        opacities[indexB] = 1 - clampedOpacity;\n      if (isFadeIndex)\n        setProgress(fadeIndex, clampedOpacity);\n      setOpacity(indexA);\n    });\n  }\n  function setOpacity(index) {\n    const slidesInSnap = emblaApi.internalEngine().slideRegistry[index];\n    const {\n      scrollSnaps,\n      containerRect\n    } = emblaApi.internalEngine();\n    const opacity = opacities[index];\n    slidesInSnap.forEach((slideIndex) => {\n      const slideStyle = emblaApi.slideNodes()[slideIndex].style;\n      const roundedOpacity = parseFloat(opacity.toFixed(2));\n      const hasOpacity = roundedOpacity > noOpacity;\n      const position = hasOpacity ? scrollSnaps[index] : containerRect.width + 2;\n      const transform = getSlideTransform(position);\n      if (hasOpacity)\n        slideStyle.transform = transform;\n      slideStyle.opacity = roundedOpacity.toString();\n      slideStyle.pointerEvents = opacity > 0.5 ? \"auto\" : \"none\";\n      if (!hasOpacity)\n        slideStyle.transform = transform;\n    });\n  }\n  function setProgress(fadeIndex, opacity) {\n    const {\n      index,\n      dragHandler,\n      scrollSnaps\n    } = emblaApi.internalEngine();\n    const pointerDown2 = dragHandler.pointerDown();\n    const snapFraction = 1 / (scrollSnaps.length - 1);\n    let indexA = fadeIndex;\n    let indexB = pointerDown2 ? emblaApi.selectedScrollSnap() : emblaApi.previousScrollSnap();\n    if (pointerDown2 && indexA === indexB) {\n      const reverseSign = Math.sign(distanceFromPointerDown) * -1;\n      indexA = indexB;\n      indexB = index.clone().set(indexB).add(reverseSign).get();\n    }\n    const currentPosition = indexB * snapFraction;\n    const diffPosition = (indexA - indexB) * snapFraction;\n    progress = currentPosition + diffPosition * opacity;\n  }\n  function getFadeIndex() {\n    const {\n      dragHandler,\n      index,\n      scrollBody\n    } = emblaApi.internalEngine();\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    if (!dragHandler.pointerDown())\n      return selectedSnap;\n    const directionSign = Math.sign(scrollBody.velocity());\n    const distanceSign = Math.sign(distanceFromPointerDown);\n    const nextSnap = index.clone().set(selectedSnap).add(directionSign * -1).get();\n    if (!directionSign || !distanceSign)\n      return null;\n    return distanceSign === directionSign ? nextSnap : selectedSnap;\n  }\n  function fade(emblaApi2) {\n    const {\n      dragHandler,\n      scrollBody\n    } = emblaApi2.internalEngine();\n    const pointerDown2 = dragHandler.pointerDown();\n    const velocity = scrollBody.velocity();\n    const duration = scrollBody.duration();\n    const fadeIndex = getFadeIndex();\n    const noFadeIndex = !isNumber(fadeIndex);\n    if (pointerDown2) {\n      if (!velocity)\n        return;\n      distanceFromPointerDown += velocity;\n      fadeVelocity = Math.abs(velocity / fadeToNextDistance);\n      lockExcessiveScroll(fadeIndex);\n    }\n    if (!pointerDown2) {\n      if (!duration || noFadeIndex)\n        return;\n      fadeVelocity += (fullOpacity - opacities[fadeIndex]) / duration;\n      fadeVelocity *= fadeFriction;\n    }\n    if (noFadeIndex)\n      return;\n    setOpacities(fadeIndex, fadeVelocity);\n  }\n  function settled() {\n    const {\n      target,\n      location\n    } = emblaApi.internalEngine();\n    const diffToTarget = target.get() - location.get();\n    const notReachedTarget = Math.abs(diffToTarget) >= 1;\n    const fadeIndex = getFadeIndex();\n    const noFadeIndex = !isNumber(fadeIndex);\n    fade(emblaApi);\n    if (noFadeIndex || notReachedTarget)\n      return false;\n    return opacities[fadeIndex] > 0.999;\n  }\n  function scrollProgress() {\n    return progress;\n  }\n  const self = {\n    name: \"fade\",\n    options: userOptions,\n    init,\n    destroy\n  };\n  return self;\n}\nFade.globalOptions = void 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtZmFkZS9lc20vZW1ibGEtY2Fyb3VzZWwtZmFkZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVMsWUFBWSxRQUFRLEtBQUssS0FBSztBQUNyQyxTQUFPLEtBQUssSUFBSSxLQUFLLElBQUksUUFBUSxHQUFHLEdBQUcsR0FBRztBQUM1QztBQUNBLFNBQVMsU0FBUyxPQUFPO0FBQ3ZCLFNBQU8sT0FBTyxVQUFVLFlBQVksQ0FBQyxNQUFNLEtBQUs7QUFDbEQ7QUFFQSxTQUFTLEtBQUssY0FBYyxDQUFDLEdBQUc7QUFDOUIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sWUFBWTtBQUNsQixRQUFNLGVBQWU7QUFDckIsTUFBSTtBQUNKLE1BQUksWUFBWSxDQUFDO0FBQ2pCLE1BQUk7QUFDSixNQUFJLDBCQUEwQjtBQUM5QixNQUFJLGVBQWU7QUFDbkIsTUFBSSxXQUFXO0FBQ2YsTUFBSSxpQkFBaUI7QUFDckIsTUFBSTtBQUNKLE1BQUk7QUFDSixXQUFTLEtBQUssa0JBQWtCO0FBQzlCLGVBQVc7QUFDWCxVQUFNLGVBQWUsU0FBUyxtQkFBbUI7QUFDakQsVUFBTTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSSxTQUFTLGVBQWU7QUFDNUIsVUFBTSxnQkFBZ0IsS0FBSyxZQUFZLGFBQWE7QUFDcEQseUJBQXFCLFlBQVksZ0JBQWdCLE1BQU0sS0FBSyxHQUFHO0FBQy9ELHFCQUFpQjtBQUNqQixnQkFBWSxTQUFTLGVBQWUsRUFBRSxJQUFJLENBQUMsR0FBRyxVQUFVLFVBQVUsZUFBZSxjQUFjLFNBQVM7QUFDeEcsOEJBQTBCLFdBQVc7QUFDckMsK0JBQTJCLFNBQVM7QUFDcEMsZUFBVyxVQUFVO0FBQ3JCLGFBQVMsaUJBQWlCO0FBQzFCLGFBQVMsR0FBRyxVQUFVLE1BQU0sRUFBRSxHQUFHLGNBQWMsMkJBQTJCLEVBQUUsR0FBRyxlQUFlLFdBQVcsRUFBRSxHQUFHLGFBQWEsU0FB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QU0sZUFBZSxPQUFPLElBQUksSUFBSSxTQUFTLElBQUk7QUFDakQsVUFBTSxtQkFBbUIsS0FBSyxJQUFJLFlBQVksS0FBSztBQUNuRCxVQUFNLFlBQVksYUFBYTtBQUMvQixVQUFNLGNBQWMsQ0FBQyxTQUFTLFNBQVM7QUFDdkMsU0FBSyxRQUFRO0FBQ2IsUUFBSSxlQUFlO0FBQWtCLGFBQU87QUFDNUMsV0FBTyxVQUFVLFNBQVMsSUFBSTtBQUFBLEVBQ2hDO0FBQ0EsV0FBUyxpQkFBaUI7QUFDeEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLE9BQU87QUFBQSxJQUNYLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNUO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxLQUFLLGdCQUFnQjtBQUVNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hvcGlmeS1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL2VtYmxhLWNhcm91c2VsLWZhZGUvZXNtL2VtYmxhLWNhcm91c2VsLWZhZGUuZXNtLmpzPzBiNjgiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY2xhbXBOdW1iZXIobnVtYmVyLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtYmVyLCBtaW4pLCBtYXgpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gRmFkZSh1c2VyT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZ1bGxPcGFjaXR5ID0gMTtcbiAgY29uc3Qgbm9PcGFjaXR5ID0gMDtcbiAgY29uc3QgZmFkZUZyaWN0aW9uID0gMC42ODtcbiAgbGV0IGVtYmxhQXBpO1xuICBsZXQgb3BhY2l0aWVzID0gW107XG4gIGxldCBmYWRlVG9OZXh0RGlzdGFuY2U7XG4gIGxldCBkaXN0YW5jZUZyb21Qb2ludGVyRG93biA9IDA7XG4gIGxldCBmYWRlVmVsb2NpdHkgPSAwO1xuICBsZXQgcHJvZ3Jlc3MgPSAwO1xuICBsZXQgc2hvdWxkRmFkZVBhaXIgPSBmYWxzZTtcbiAgbGV0IGRlZmF1bHRTZXR0bGVkQmVoYXZpb3VyO1xuICBsZXQgZGVmYXVsdFByb2dyZXNzQmVoYXZpb3VyO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpSW5zdGFuY2UpIHtcbiAgICBlbWJsYUFwaSA9IGVtYmxhQXBpSW5zdGFuY2U7XG4gICAgY29uc3Qgc2VsZWN0ZWRTbmFwID0gZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsQm9keSxcbiAgICAgIGNvbnRhaW5lclJlY3QsXG4gICAgICBheGlzXG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGF4aXMubWVhc3VyZVNpemUoY29udGFpbmVyUmVjdCk7XG4gICAgZmFkZVRvTmV4dERpc3RhbmNlID0gY2xhbXBOdW1iZXIoY29udGFpbmVyU2l6ZSAqIDAuNzUsIDIwMCwgNTAwKTtcbiAgICBzaG91bGRGYWRlUGFpciA9IGZhbHNlO1xuICAgIG9wYWNpdGllcyA9IGVtYmxhQXBpLnNjcm9sbFNuYXBMaXN0KCkubWFwKChfLCBpbmRleCkgPT4gaW5kZXggPT09IHNlbGVjdGVkU25hcCA/IGZ1bGxPcGFjaXR5IDogbm9PcGFjaXR5KTtcbiAgICBkZWZhdWx0U2V0dGxlZEJlaGF2aW91ciA9IHNjcm9sbEJvZHkuc2V0dGxlZDtcbiAgICBkZWZhdWx0UHJvZ3Jlc3NCZWhhdmlvdXIgPSBlbWJsYUFwaS5zY3JvbGxQcm9ncmVzcztcbiAgICBzY3JvbGxCb2R5LnNldHRsZWQgPSBzZXR0bGVkO1xuICAgIGVtYmxhQXBpLnNjcm9sbFByb2dyZXNzID0gc2Nyb2xsUHJvZ3Jlc3M7XG4gICAgZW1ibGFBcGkub24oJ3NlbGVjdCcsIHNlbGVjdCkub24oJ3NsaWRlRm9jdXMnLCBmYWRlVG9TZWxlY3RlZFNuYXBJbnN0YW50bHkpLm9uKCdwb2ludGVyRG93bicsIHBvaW50ZXJEb3duKS5vbigncG9pbnRlclVwJywgcG9pbnRlclVwKTtcbiAgICBkaXNhYmxlU2Nyb2xsKCk7XG4gICAgZmFkZVRvU2VsZWN0ZWRTbmFwSW5zdGFudGx5KCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxCb2R5XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgc2Nyb2xsQm9keS5zZXR0bGVkID0gZGVmYXVsdFNldHRsZWRCZWhhdmlvdXI7XG4gICAgZW1ibGFBcGkuc2Nyb2xsUHJvZ3Jlc3MgPSBkZWZhdWx0UHJvZ3Jlc3NCZWhhdmlvdXI7XG4gICAgZW1ibGFBcGkub2ZmKCdzZWxlY3QnLCBzZWxlY3QpLm9mZignc2xpZGVGb2N1cycsIGZhZGVUb1NlbGVjdGVkU25hcEluc3RhbnRseSkub2ZmKCdwb2ludGVyRG93bicsIHBvaW50ZXJEb3duKS5vZmYoJ3BvaW50ZXJVcCcsIHBvaW50ZXJVcCk7XG4gICAgZW1ibGFBcGkuc2xpZGVOb2RlcygpLmZvckVhY2goc2xpZGVOb2RlID0+IHtcbiAgICAgIGNvbnN0IHNsaWRlU3R5bGUgPSBzbGlkZU5vZGUuc3R5bGU7XG4gICAgICBzbGlkZVN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgIHNsaWRlU3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICBzbGlkZVN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIGlmICghc2xpZGVOb2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkgc2xpZGVOb2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmYWRlVG9TZWxlY3RlZFNuYXBJbnN0YW50bHkoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRTbmFwID0gZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgc2V0T3BhY2l0aWVzKHNlbGVjdGVkU25hcCwgZnVsbE9wYWNpdHkpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJVcCgpIHtcbiAgICBzaG91bGRGYWRlUGFpciA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJEb3duKCkge1xuICAgIHNob3VsZEZhZGVQYWlyID0gZmFsc2U7XG4gICAgZGlzdGFuY2VGcm9tUG9pbnRlckRvd24gPSAwO1xuICAgIGZhZGVWZWxvY2l0eSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKS5zY3JvbGxCb2R5LmR1cmF0aW9uKCk7XG4gICAgZmFkZVZlbG9jaXR5ID0gZHVyYXRpb24gPyAwIDogZnVsbE9wYWNpdHk7XG4gICAgc2hvdWxkRmFkZVBhaXIgPSB0cnVlO1xuICAgIGlmICghZHVyYXRpb24pIGZhZGVUb1NlbGVjdGVkU25hcEluc3RhbnRseSgpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNsaWRlVHJhbnNmb3JtKHBvc2l0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXhpc1xuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZUF4aXMgPSBheGlzLnNjcm9sbC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBgdHJhbnNsYXRlJHt0cmFuc2xhdGVBeGlzfSgke2F4aXMuZGlyZWN0aW9uKHBvc2l0aW9uKX1weClgO1xuICB9XG4gIGZ1bmN0aW9uIGRpc2FibGVTY3JvbGwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNsYXRlLFxuICAgICAgc2xpZGVMb29wZXJcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICB0cmFuc2xhdGUuY2xlYXIoKTtcbiAgICB0cmFuc2xhdGUudG9nZ2xlQWN0aXZlKGZhbHNlKTtcbiAgICBzbGlkZUxvb3Blci5sb29wUG9pbnRzLmZvckVhY2goKHtcbiAgICAgIHRyYW5zbGF0ZVxuICAgIH0pID0+IHtcbiAgICAgIHRyYW5zbGF0ZS5jbGVhcigpO1xuICAgICAgdHJhbnNsYXRlLnRvZ2dsZUFjdGl2ZShmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbG9ja0V4Y2Vzc2l2ZVNjcm9sbChmYWRlSW5kZXgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxTbmFwcyxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGFyZ2V0XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgaWYgKCFpc051bWJlcihmYWRlSW5kZXgpIHx8IG9wYWNpdGllc1tmYWRlSW5kZXhdIDwgMC41KSByZXR1cm47XG4gICAgbG9jYXRpb24uc2V0KHNjcm9sbFNuYXBzW2ZhZGVJbmRleF0pO1xuICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHNldE9wYWNpdGllcyhmYWRlSW5kZXgsIHZlbG9jaXR5KSB7XG4gICAgY29uc3Qgc2Nyb2xsU25hcHMgPSBlbWJsYUFwaS5zY3JvbGxTbmFwTGlzdCgpO1xuICAgIHNjcm9sbFNuYXBzLmZvckVhY2goKF8sIGluZGV4QSkgPT4ge1xuICAgICAgY29uc3QgYWJzVmVsb2NpdHkgPSBNYXRoLmFicyh2ZWxvY2l0eSk7XG4gICAgICBjb25zdCBjdXJyZW50T3BhY2l0eSA9IG9wYWNpdGllc1tpbmRleEFdO1xuICAgICAgY29uc3QgaXNGYWRlSW5kZXggPSBpbmRleEEgPT09IGZhZGVJbmRleDtcbiAgICAgIGNvbnN0IG5leHRPcGFjaXR5ID0gaXNGYWRlSW5kZXggPyBjdXJyZW50T3BhY2l0eSArIGFic1ZlbG9jaXR5IDogY3VycmVudE9wYWNpdHkgLSBhYnNWZWxvY2l0eTtcbiAgICAgIGNvbnN0IGNsYW1wZWRPcGFjaXR5ID0gY2xhbXBOdW1iZXIobmV4dE9wYWNpdHksIG5vT3BhY2l0eSwgZnVsbE9wYWNpdHkpO1xuICAgICAgb3BhY2l0aWVzW2luZGV4QV0gPSBjbGFtcGVkT3BhY2l0eTtcbiAgICAgIGNvbnN0IGZhZGVQYWlyID0gaXNGYWRlSW5kZXggJiYgc2hvdWxkRmFkZVBhaXI7XG4gICAgICBjb25zdCBpbmRleEIgPSBlbWJsYUFwaS5wcmV2aW91c1Njcm9sbFNuYXAoKTtcbiAgICAgIGlmIChmYWRlUGFpcikgb3BhY2l0aWVzW2luZGV4Ql0gPSAxIC0gY2xhbXBlZE9wYWNpdHk7XG4gICAgICBpZiAoaXNGYWRlSW5kZXgpIHNldFByb2dyZXNzKGZhZGVJbmRleCwgY2xhbXBlZE9wYWNpdHkpO1xuICAgICAgc2V0T3BhY2l0eShpbmRleEEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNldE9wYWNpdHkoaW5kZXgpIHtcbiAgICBjb25zdCBzbGlkZXNJblNuYXAgPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpLnNsaWRlUmVnaXN0cnlbaW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbFNuYXBzLFxuICAgICAgY29udGFpbmVyUmVjdFxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IG9wYWNpdHkgPSBvcGFjaXRpZXNbaW5kZXhdO1xuICAgIHNsaWRlc0luU25hcC5mb3JFYWNoKHNsaWRlSW5kZXggPT4ge1xuICAgICAgY29uc3Qgc2xpZGVTdHlsZSA9IGVtYmxhQXBpLnNsaWRlTm9kZXMoKVtzbGlkZUluZGV4XS5zdHlsZTtcbiAgICAgIGNvbnN0IHJvdW5kZWRPcGFjaXR5ID0gcGFyc2VGbG9hdChvcGFjaXR5LnRvRml4ZWQoMikpO1xuICAgICAgY29uc3QgaGFzT3BhY2l0eSA9IHJvdW5kZWRPcGFjaXR5ID4gbm9PcGFjaXR5O1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBoYXNPcGFjaXR5ID8gc2Nyb2xsU25hcHNbaW5kZXhdIDogY29udGFpbmVyUmVjdC53aWR0aCArIDI7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRTbGlkZVRyYW5zZm9ybShwb3NpdGlvbik7XG4gICAgICBpZiAoaGFzT3BhY2l0eSkgc2xpZGVTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICBzbGlkZVN0eWxlLm9wYWNpdHkgPSByb3VuZGVkT3BhY2l0eS50b1N0cmluZygpO1xuICAgICAgc2xpZGVTdHlsZS5wb2ludGVyRXZlbnRzID0gb3BhY2l0eSA+IDAuNSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgIGlmICghaGFzT3BhY2l0eSkgc2xpZGVTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0UHJvZ3Jlc3MoZmFkZUluZGV4LCBvcGFjaXR5KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXgsXG4gICAgICBkcmFnSGFuZGxlcixcbiAgICAgIHNjcm9sbFNuYXBzXG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgcG9pbnRlckRvd24gPSBkcmFnSGFuZGxlci5wb2ludGVyRG93bigpO1xuICAgIGNvbnN0IHNuYXBGcmFjdGlvbiA9IDEgLyAoc2Nyb2xsU25hcHMubGVuZ3RoIC0gMSk7XG4gICAgbGV0IGluZGV4QSA9IGZhZGVJbmRleDtcbiAgICBsZXQgaW5kZXhCID0gcG9pbnRlckRvd24gPyBlbWJsYUFwaS5zZWxlY3RlZFNjcm9sbFNuYXAoKSA6IGVtYmxhQXBpLnByZXZpb3VzU2Nyb2xsU25hcCgpO1xuICAgIGlmIChwb2ludGVyRG93biAmJiBpbmRleEEgPT09IGluZGV4Qikge1xuICAgICAgY29uc3QgcmV2ZXJzZVNpZ24gPSBNYXRoLnNpZ24oZGlzdGFuY2VGcm9tUG9pbnRlckRvd24pICogLTE7XG4gICAgICBpbmRleEEgPSBpbmRleEI7XG4gICAgICBpbmRleEIgPSBpbmRleC5jbG9uZSgpLnNldChpbmRleEIpLmFkZChyZXZlcnNlU2lnbikuZ2V0KCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvbiA9IGluZGV4QiAqIHNuYXBGcmFjdGlvbjtcbiAgICBjb25zdCBkaWZmUG9zaXRpb24gPSAoaW5kZXhBIC0gaW5kZXhCKSAqIHNuYXBGcmFjdGlvbjtcbiAgICBwcm9ncmVzcyA9IGN1cnJlbnRQb3NpdGlvbiArIGRpZmZQb3NpdGlvbiAqIG9wYWNpdHk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmFkZUluZGV4KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYWdIYW5kbGVyLFxuICAgICAgaW5kZXgsXG4gICAgICBzY3JvbGxCb2R5XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRTbmFwID0gZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgaWYgKCFkcmFnSGFuZGxlci5wb2ludGVyRG93bigpKSByZXR1cm4gc2VsZWN0ZWRTbmFwO1xuICAgIGNvbnN0IGRpcmVjdGlvblNpZ24gPSBNYXRoLnNpZ24oc2Nyb2xsQm9keS52ZWxvY2l0eSgpKTtcbiAgICBjb25zdCBkaXN0YW5jZVNpZ24gPSBNYXRoLnNpZ24oZGlzdGFuY2VGcm9tUG9pbnRlckRvd24pO1xuICAgIGNvbnN0IG5leHRTbmFwID0gaW5kZXguY2xvbmUoKS5zZXQoc2VsZWN0ZWRTbmFwKS5hZGQoZGlyZWN0aW9uU2lnbiAqIC0xKS5nZXQoKTtcbiAgICBpZiAoIWRpcmVjdGlvblNpZ24gfHwgIWRpc3RhbmNlU2lnbikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGRpc3RhbmNlU2lnbiA9PT0gZGlyZWN0aW9uU2lnbiA/IG5leHRTbmFwIDogc2VsZWN0ZWRTbmFwO1xuICB9XG4gIGZ1bmN0aW9uIGZhZGUoZW1ibGFBcGkpIHtcbiAgICBjb25zdCB7XG4gICAgICBkcmFnSGFuZGxlcixcbiAgICAgIHNjcm9sbEJvZHlcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBwb2ludGVyRG93biA9IGRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCk7XG4gICAgY29uc3QgdmVsb2NpdHkgPSBzY3JvbGxCb2R5LnZlbG9jaXR5KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBzY3JvbGxCb2R5LmR1cmF0aW9uKCk7XG4gICAgY29uc3QgZmFkZUluZGV4ID0gZ2V0RmFkZUluZGV4KCk7XG4gICAgY29uc3Qgbm9GYWRlSW5kZXggPSAhaXNOdW1iZXIoZmFkZUluZGV4KTtcbiAgICBpZiAocG9pbnRlckRvd24pIHtcbiAgICAgIGlmICghdmVsb2NpdHkpIHJldHVybjtcbiAgICAgIGRpc3RhbmNlRnJvbVBvaW50ZXJEb3duICs9IHZlbG9jaXR5O1xuICAgICAgZmFkZVZlbG9jaXR5ID0gTWF0aC5hYnModmVsb2NpdHkgLyBmYWRlVG9OZXh0RGlzdGFuY2UpO1xuICAgICAgbG9ja0V4Y2Vzc2l2ZVNjcm9sbChmYWRlSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoIXBvaW50ZXJEb3duKSB7XG4gICAgICBpZiAoIWR1cmF0aW9uIHx8IG5vRmFkZUluZGV4KSByZXR1cm47XG4gICAgICBmYWRlVmVsb2NpdHkgKz0gKGZ1bGxPcGFjaXR5IC0gb3BhY2l0aWVzW2ZhZGVJbmRleF0pIC8gZHVyYXRpb247XG4gICAgICBmYWRlVmVsb2NpdHkgKj0gZmFkZUZyaWN0aW9uO1xuICAgIH1cbiAgICBpZiAobm9GYWRlSW5kZXgpIHJldHVybjtcbiAgICBzZXRPcGFjaXRpZXMoZmFkZUluZGV4LCBmYWRlVmVsb2NpdHkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldHRsZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgbG9jYXRpb25cbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBkaWZmVG9UYXJnZXQgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBub3RSZWFjaGVkVGFyZ2V0ID0gTWF0aC5hYnMoZGlmZlRvVGFyZ2V0KSA+PSAxO1xuICAgIGNvbnN0IGZhZGVJbmRleCA9IGdldEZhZGVJbmRleCgpO1xuICAgIGNvbnN0IG5vRmFkZUluZGV4ID0gIWlzTnVtYmVyKGZhZGVJbmRleCk7XG4gICAgZmFkZShlbWJsYUFwaSk7XG4gICAgaWYgKG5vRmFkZUluZGV4IHx8IG5vdFJlYWNoZWRUYXJnZXQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb3BhY2l0aWVzW2ZhZGVJbmRleF0gPiAwLjk5OTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxQcm9ncmVzcygpIHtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBuYW1lOiAnZmFkZScsXG4gICAgb3B0aW9uczogdXNlck9wdGlvbnMsXG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuRmFkZS5nbG9iYWxPcHRpb25zID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBGYWRlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmxhLWNhcm91c2VsLWZhZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbInRyYW5zbGF0ZSIsInBvaW50ZXJEb3duIiwiZW1ibGFBcGkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js\n\n}");

/***/ }),

/***/ "./node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction isNumber(subject) {\n  return typeof subject === \"number\";\n}\nfunction isString(subject) {\n  return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n  return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n  return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n  return Math.abs(n);\n}\nfunction mathSign(n) {\n  return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n  return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n  if (valueB === 0 || valueA === 0)\n    return 0;\n  if (mathAbs(valueB) <= mathAbs(valueA))\n    return 0;\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n  return mathAbs(diff / valueB);\n}\nfunction roundToTwoDecimals(num) {\n  return Math.round(num * 100) / 100;\n}\nfunction arrayKeys(array) {\n  return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n  return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n  return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n  return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n  return Array.from(Array(n), (_, i) => startAt + i);\n}\nfunction objectKeys(object) {\n  return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key];\n      const valueB = currentObject[key];\n      const areObjects = isObject(valueA) && isObject(valueB);\n      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n    });\n    return mergedObjects;\n  }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n  return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n  const predefined = {\n    start,\n    center,\n    end\n  };\n  function start() {\n    return 0;\n  }\n  function center(n) {\n    return end(n) / 2;\n  }\n  function end(n) {\n    return viewSize - n;\n  }\n  function measure(n, index) {\n    if (isString(align))\n      return predefined[align](n);\n    return align(viewSize, n, index);\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\nfunction EventStore() {\n  let listeners = [];\n  function add(node, type, handler, options = {\n    passive: true\n  }) {\n    let removeListener;\n    if (\"addEventListener\" in node) {\n      node.addEventListener(type, handler, options);\n      removeListener = () => node.removeEventListener(type, handler, options);\n    } else {\n      const legacyMediaQueryList = node;\n      legacyMediaQueryList.addListener(handler);\n      removeListener = () => legacyMediaQueryList.removeListener(handler);\n    }\n    listeners.push(removeListener);\n    return self;\n  }\n  function clear() {\n    listeners = listeners.filter((remove) => remove());\n  }\n  const self = {\n    add,\n    clear\n  };\n  return self;\n}\nfunction Animations(ownerDocument, ownerWindow, update, render) {\n  const documentVisibleHandler = EventStore();\n  const fixedTimeStep = 1e3 / 60;\n  let lastTimeStamp = null;\n  let accumulatedTime = 0;\n  let animationId = 0;\n  function init() {\n    documentVisibleHandler.add(ownerDocument, \"visibilitychange\", () => {\n      if (ownerDocument.hidden)\n        reset();\n    });\n  }\n  function destroy() {\n    stop();\n    documentVisibleHandler.clear();\n  }\n  function animate(timeStamp) {\n    if (!animationId)\n      return;\n    if (!lastTimeStamp) {\n      lastTimeStamp = timeStamp;\n      update();\n      update();\n    }\n    const timeElapsed = timeStamp - lastTimeStamp;\n    lastTimeStamp = timeStamp;\n    accumulatedTime += timeElapsed;\n    while (accumulatedTime >= fixedTimeStep) {\n      update();\n      accumulatedTime -= fixedTimeStep;\n    }\n    const alpha = accumulatedTime / fixedTimeStep;\n    render(alpha);\n    if (animationId) {\n      animationId = ownerWindow.requestAnimationFrame(animate);\n    }\n  }\n  function start() {\n    if (animationId)\n      return;\n    animationId = ownerWindow.requestAnimationFrame(animate);\n  }\n  function stop() {\n    ownerWindow.cancelAnimationFrame(animationId);\n    lastTimeStamp = null;\n    accumulatedTime = 0;\n    animationId = 0;\n  }\n  function reset() {\n    lastTimeStamp = null;\n    accumulatedTime = 0;\n  }\n  const self = {\n    init,\n    destroy,\n    start,\n    stop,\n    update,\n    render\n  };\n  return self;\n}\nfunction Axis(axis, contentDirection) {\n  const isRightToLeft = contentDirection === \"rtl\";\n  const isVertical = axis === \"y\";\n  const scroll = isVertical ? \"y\" : \"x\";\n  const cross = isVertical ? \"x\" : \"y\";\n  const sign = !isVertical && isRightToLeft ? -1 : 1;\n  const startEdge = getStartEdge();\n  const endEdge = getEndEdge();\n  function measureSize(nodeRect) {\n    const {\n      height,\n      width\n    } = nodeRect;\n    return isVertical ? height : width;\n  }\n  function getStartEdge() {\n    if (isVertical)\n      return \"top\";\n    return isRightToLeft ? \"right\" : \"left\";\n  }\n  function getEndEdge() {\n    if (isVertical)\n      return \"bottom\";\n    return isRightToLeft ? \"left\" : \"right\";\n  }\n  function direction(n) {\n    return n * sign;\n  }\n  const self = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n    direction\n  };\n  return self;\n}\nfunction Limit(min = 0, max = 0) {\n  const length = mathAbs(min - max);\n  function reachedMin(n) {\n    return n < min;\n  }\n  function reachedMax(n) {\n    return n > max;\n  }\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n  function constrain(n) {\n    if (!reachedAny(n))\n      return n;\n    return reachedMin(n) ? min : max;\n  }\n  function removeOffset(n) {\n    if (!length)\n      return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n  const self = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset\n  };\n  return self;\n}\nfunction Counter(max, start, loop) {\n  const {\n    constrain\n  } = Limit(0, max);\n  const loopEnd = max + 1;\n  let counter = withinLimit(start);\n  function withinLimit(n) {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n  }\n  function get() {\n    return counter;\n  }\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n  function add(n) {\n    return clone().set(get() + n);\n  }\n  function clone() {\n    return Counter(max, get(), loop);\n  }\n  const self = {\n    get,\n    set,\n    add,\n    clone\n  };\n  return self;\n}\nfunction DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n  const {\n    cross: crossAxis,\n    direction\n  } = axis;\n  const focusNodes = [\"INPUT\", \"SELECT\", \"TEXTAREA\"];\n  const nonPassiveEvent = {\n    passive: false\n  };\n  const initEvents = EventStore();\n  const dragEvents = EventStore();\n  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n  const snapForceBoost = {\n    mouse: 300,\n    touch: 400\n  };\n  const freeForceBoost = {\n    mouse: 500,\n    touch: 600\n  };\n  const baseSpeed = dragFree ? 43 : 25;\n  let isMoving = false;\n  let startScroll = 0;\n  let startCross = 0;\n  let pointerIsDown = false;\n  let preventScroll = false;\n  let preventClick = false;\n  let isMouse = false;\n  function init(emblaApi) {\n    if (!watchDrag)\n      return;\n    function downIfAllowed(evt) {\n      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt))\n        down(evt);\n    }\n    const node = rootNode;\n    initEvents.add(node, \"dragstart\", (evt) => evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", () => void 0, nonPassiveEvent).add(node, \"touchend\", () => void 0).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n  }\n  function destroy() {\n    initEvents.clear();\n    dragEvents.clear();\n  }\n  function addDragEvents() {\n    const node = isMouse ? ownerDocument : rootNode;\n    dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n  }\n  function isFocusNode(node) {\n    const nodeName = node.nodeName || \"\";\n    return focusNodes.includes(nodeName);\n  }\n  function forceBoost() {\n    const boost = dragFree ? freeForceBoost : snapForceBoost;\n    const type = isMouse ? \"mouse\" : \"touch\";\n    return boost[type];\n  }\n  function allowedForce(force, targetChanged) {\n    const next = index.add(mathSign(force) * -1);\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n    if (dragFree || mathAbs(force) < goToNextThreshold)\n      return baseForce;\n    if (skipSnaps && targetChanged)\n      return baseForce * 0.5;\n    return scrollTarget.byIndex(next.get(), 0).distance;\n  }\n  function down(evt) {\n    const isMouseEvt = isMouseEvent(evt, ownerWindow);\n    isMouse = isMouseEvt;\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n    isMoving = deltaAbs(target.get(), location.get()) >= 2;\n    if (isMouseEvt && evt.button !== 0)\n      return;\n    if (isFocusNode(evt.target))\n      return;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    scrollBody.useFriction(0).useDuration(0);\n    target.set(location);\n    addDragEvents();\n    startScroll = dragTracker.readPoint(evt);\n    startCross = dragTracker.readPoint(evt, crossAxis);\n    eventHandler.emit(\"pointerDown\");\n  }\n  function move(evt) {\n    const isTouchEvt = !isMouseEvent(evt, ownerWindow);\n    if (isTouchEvt && evt.touches.length >= 2)\n      return up(evt);\n    const lastScroll = dragTracker.readPoint(evt);\n    const lastCross = dragTracker.readPoint(evt, crossAxis);\n    const diffScroll = deltaAbs(lastScroll, startScroll);\n    const diffCross = deltaAbs(lastCross, startCross);\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable)\n        return up(evt);\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll)\n        return up(evt);\n    }\n    const diff = dragTracker.pointerMove(evt);\n    if (diffScroll > dragThreshold)\n      preventClick = true;\n    scrollBody.useFriction(0.3).useDuration(0.75);\n    animation.start();\n    target.add(direction(diff));\n    evt.preventDefault();\n  }\n  function up(evt) {\n    const currentLocation = scrollTarget.byDistance(0, false);\n    const targetChanged = currentLocation.index !== index.get();\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n    const force = allowedForce(direction(rawForce), targetChanged);\n    const forceFactor = factorAbs(rawForce, force);\n    const speed = baseSpeed - 10 * forceFactor;\n    const friction = baseFriction + forceFactor / 50;\n    preventScroll = false;\n    pointerIsDown = false;\n    dragEvents.clear();\n    scrollBody.useDuration(speed).useFriction(friction);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    eventHandler.emit(\"pointerUp\");\n  }\n  function click(evt) {\n    if (preventClick) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      preventClick = false;\n    }\n  }\n  function pointerDown() {\n    return pointerIsDown;\n  }\n  const self = {\n    init,\n    destroy,\n    pointerDown\n  };\n  return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n  const logInterval = 170;\n  let startEvent;\n  let lastEvent;\n  function readTime(evt) {\n    return evt.timeStamp;\n  }\n  function readPoint(evt, evtAxis) {\n    const property = evtAxis || axis.scroll;\n    const coord = `client${property === \"x\" ? \"X\" : \"Y\"}`;\n    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n  }\n  function pointerDown(evt) {\n    startEvent = evt;\n    lastEvent = evt;\n    return readPoint(evt);\n  }\n  function pointerMove(evt) {\n    const diff = readPoint(evt) - readPoint(lastEvent);\n    const expired = readTime(evt) - readTime(startEvent) > logInterval;\n    lastEvent = evt;\n    if (expired)\n      startEvent = evt;\n    return diff;\n  }\n  function pointerUp(evt) {\n    if (!startEvent || !lastEvent)\n      return 0;\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n    const diffTime = readTime(evt) - readTime(startEvent);\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n    const force = diffDrag / diffTime;\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n    return isFlick ? force : 0;\n  }\n  const self = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint\n  };\n  return self;\n}\nfunction NodeRects() {\n  function measure(node) {\n    const {\n      offsetTop,\n      offsetLeft,\n      offsetWidth,\n      offsetHeight\n    } = node;\n    const offset = {\n      top: offsetTop,\n      right: offsetLeft + offsetWidth,\n      bottom: offsetTop + offsetHeight,\n      left: offsetLeft,\n      width: offsetWidth,\n      height: offsetHeight\n    };\n    return offset;\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\nfunction PercentOfView(viewSize) {\n  function measure(n) {\n    return viewSize * (n / 100);\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n  const observeNodes = [container].concat(slides);\n  let resizeObserver;\n  let containerSize;\n  let slideSizes = [];\n  let destroyed = false;\n  function readSize(node) {\n    return axis.measureSize(nodeRects.measure(node));\n  }\n  function init(emblaApi) {\n    if (!watchResize)\n      return;\n    containerSize = readSize(container);\n    slideSizes = slides.map(readSize);\n    function defaultCallback(entries) {\n      for (const entry of entries) {\n        if (destroyed)\n          return;\n        const isContainer = entry.target === container;\n        const slideIndex = slides.indexOf(entry.target);\n        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n        const newSize = readSize(isContainer ? container : slides[slideIndex]);\n        const diffSize = mathAbs(newSize - lastSize);\n        if (diffSize >= 0.5) {\n          emblaApi.reInit();\n          eventHandler.emit(\"resize\");\n          break;\n        }\n      }\n    }\n    resizeObserver = new ResizeObserver((entries) => {\n      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n        defaultCallback(entries);\n      }\n    });\n    ownerWindow.requestAnimationFrame(() => {\n      observeNodes.forEach((node) => resizeObserver.observe(node));\n    });\n  }\n  function destroy() {\n    destroyed = true;\n    if (resizeObserver)\n      resizeObserver.disconnect();\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\nfunction ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {\n  let scrollVelocity = 0;\n  let scrollDirection = 0;\n  let scrollDuration = baseDuration;\n  let scrollFriction = baseFriction;\n  let rawLocation = location.get();\n  let rawLocationPrevious = 0;\n  function seek() {\n    const displacement = target.get() - location.get();\n    const isInstant = !scrollDuration;\n    let scrollDistance = 0;\n    if (isInstant) {\n      scrollVelocity = 0;\n      previousLocation.set(target);\n      location.set(target);\n      scrollDistance = displacement;\n    } else {\n      previousLocation.set(location);\n      scrollVelocity += displacement / scrollDuration;\n      scrollVelocity *= scrollFriction;\n      rawLocation += scrollVelocity;\n      location.add(scrollVelocity);\n      scrollDistance = rawLocation - rawLocationPrevious;\n    }\n    scrollDirection = mathSign(scrollDistance);\n    rawLocationPrevious = rawLocation;\n    return self;\n  }\n  function settled() {\n    const diff = target.get() - offsetLocation.get();\n    return mathAbs(diff) < 1e-3;\n  }\n  function duration() {\n    return scrollDuration;\n  }\n  function direction() {\n    return scrollDirection;\n  }\n  function velocity() {\n    return scrollVelocity;\n  }\n  function useBaseDuration() {\n    return useDuration(baseDuration);\n  }\n  function useBaseFriction() {\n    return useFriction(baseFriction);\n  }\n  function useDuration(n) {\n    scrollDuration = n;\n    return self;\n  }\n  function useFriction(n) {\n    scrollFriction = n;\n    return self;\n  }\n  const self = {\n    direction,\n    duration,\n    velocity,\n    seek,\n    settled,\n    useBaseFriction,\n    useBaseDuration,\n    useFriction,\n    useDuration\n  };\n  return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n  const pullBackThreshold = percentOfView.measure(10);\n  const edgeOffsetTolerance = percentOfView.measure(50);\n  const frictionLimit = Limit(0.1, 0.99);\n  let disabled = false;\n  function shouldConstrain() {\n    if (disabled)\n      return false;\n    if (!limit.reachedAny(target.get()))\n      return false;\n    if (!limit.reachedAny(location.get()))\n      return false;\n    return true;\n  }\n  function constrain(pointerDown) {\n    if (!shouldConstrain())\n      return;\n    const edge = limit.reachedMin(location.get()) ? \"min\" : \"max\";\n    const diffToEdge = mathAbs(limit[edge] - location.get());\n    const diffToTarget = target.get() - location.get();\n    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n    target.subtract(diffToTarget * friction);\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()));\n      scrollBody.useDuration(25).useBaseFriction();\n    }\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  const self = {\n    shouldConstrain,\n    constrain,\n    toggleActive\n  };\n  return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n  const scrollBounds = Limit(-contentSize + viewSize, 0);\n  const snapsBounded = measureBounded();\n  const scrollContainLimit = findScrollContainLimit();\n  const snapsContained = measureContained();\n  function usePixelTolerance(bound, snap) {\n    return deltaAbs(bound, snap) <= 1;\n  }\n  function findScrollContainLimit() {\n    const startSnap = snapsBounded[0];\n    const endSnap = arrayLast(snapsBounded);\n    const min = snapsBounded.lastIndexOf(startSnap);\n    const max = snapsBounded.indexOf(endSnap) + 1;\n    return Limit(min, max);\n  }\n  function measureBounded() {\n    return snapsAligned.map((snapAligned, index) => {\n      const {\n        min,\n        max\n      } = scrollBounds;\n      const snap = scrollBounds.constrain(snapAligned);\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(snapsAligned, index);\n      if (isFirst)\n        return max;\n      if (isLast)\n        return min;\n      if (usePixelTolerance(min, snap))\n        return min;\n      if (usePixelTolerance(max, snap))\n        return max;\n      return snap;\n    }).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));\n  }\n  function measureContained() {\n    if (contentSize <= viewSize + pixelTolerance)\n      return [scrollBounds.max];\n    if (containScroll === \"keepSnaps\")\n      return snapsBounded;\n    const {\n      min,\n      max\n    } = scrollContainLimit;\n    return snapsBounded.slice(min, max);\n  }\n  const self = {\n    snapsContained,\n    scrollContainLimit\n  };\n  return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n  const max = scrollSnaps[0];\n  const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n  const limit = Limit(min, max);\n  const self = {\n    limit\n  };\n  return self;\n}\nfunction ScrollLooper(contentSize, limit, location, vectors) {\n  const jointSafety = 0.1;\n  const min = limit.min + jointSafety;\n  const max = limit.max + jointSafety;\n  const {\n    reachedMin,\n    reachedMax\n  } = Limit(min, max);\n  function shouldLoop(direction) {\n    if (direction === 1)\n      return reachedMax(location.get());\n    if (direction === -1)\n      return reachedMin(location.get());\n    return false;\n  }\n  function loop(direction) {\n    if (!shouldLoop(direction))\n      return;\n    const loopDistance = contentSize * (direction * -1);\n    vectors.forEach((v) => v.add(loopDistance));\n  }\n  const self = {\n    loop\n  };\n  return self;\n}\nfunction ScrollProgress(limit) {\n  const {\n    max,\n    length\n  } = limit;\n  function get(n) {\n    const currentLocation = n - max;\n    return length ? currentLocation / -length : 0;\n  }\n  const self = {\n    get\n  };\n  return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n  const {\n    startEdge,\n    endEdge\n  } = axis;\n  const {\n    groupSlides\n  } = slidesToScroll;\n  const alignments = measureSizes().map(alignment.measure);\n  const snaps = measureUnaligned();\n  const snapsAligned = measureAligned();\n  function measureSizes() {\n    return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n  }\n  function measureUnaligned() {\n    return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));\n  }\n  function measureAligned() {\n    return groupSlides(snaps).map((g) => g[0]).map((snap, index) => snap + alignments[index]);\n  }\n  const self = {\n    snaps,\n    snapsAligned\n  };\n  return self;\n}\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n  const {\n    groupSlides\n  } = slidesToScroll;\n  const {\n    min,\n    max\n  } = scrollContainLimit;\n  const slideRegistry = createSlideRegistry();\n  function createSlideRegistry() {\n    const groupedSlideIndexes = groupSlides(slideIndexes);\n    const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n    if (scrollSnaps.length === 1)\n      return [slideIndexes];\n    if (doNotContain)\n      return groupedSlideIndexes;\n    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(groups, index);\n      if (isFirst) {\n        const range = arrayLast(groups[0]) + 1;\n        return arrayFromNumber(range);\n      }\n      if (isLast) {\n        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n        return arrayFromNumber(range, arrayLast(groups)[0]);\n      }\n      return group;\n    });\n  }\n  const self = {\n    slideRegistry\n  };\n  return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n  const {\n    reachedAny,\n    removeOffset,\n    constrain\n  } = limit;\n  function minDistance(distances) {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];\n  }\n  function findTargetSnap(target) {\n    const distance = loop ? removeOffset(target) : constrain(target);\n    const ascDiffsToSnaps = scrollSnaps.map((snap, index2) => ({\n      diff: shortcut(snap - distance, 0),\n      index: index2\n    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));\n    const {\n      index\n    } = ascDiffsToSnaps[0];\n    return {\n      index,\n      distance\n    };\n  }\n  function shortcut(target, direction) {\n    const targets = [target, target + contentSize, target - contentSize];\n    if (!loop)\n      return target;\n    if (!direction)\n      return minDistance(targets);\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction);\n    if (matchingTargets.length)\n      return minDistance(matchingTargets);\n    return arrayLast(targets) - contentSize;\n  }\n  function byIndex(index, direction) {\n    const diffToSnap = scrollSnaps[index] - targetVector.get();\n    const distance = shortcut(diffToSnap, direction);\n    return {\n      index,\n      distance\n    };\n  }\n  function byDistance(distance, snap) {\n    const target = targetVector.get() + distance;\n    const {\n      index,\n      distance: targetSnapDistance\n    } = findTargetSnap(target);\n    const reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound)\n      return {\n        index,\n        distance\n      };\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n    const snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index,\n      distance: snapDistance\n    };\n  }\n  const self = {\n    byDistance,\n    byIndex,\n    shortcut\n  };\n  return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {\n  function scrollTo(target) {\n    const distanceDiff = target.distance;\n    const indexDiff = target.index !== indexCurrent.get();\n    targetVector.add(distanceDiff);\n    if (distanceDiff) {\n      if (scrollBody.duration()) {\n        animation.start();\n      } else {\n        animation.update();\n        animation.render(1);\n        animation.update();\n      }\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      eventHandler.emit(\"select\");\n    }\n  }\n  function distance(n, snap) {\n    const target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n  function index(n, direction) {\n    const targetIndex = indexCurrent.clone().set(n);\n    const target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n  const self = {\n    distance,\n    index\n  };\n  return self;\n}\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {\n  const focusListenerOptions = {\n    passive: true,\n    capture: true\n  };\n  let lastTabPressTime = 0;\n  function init(emblaApi) {\n    if (!watchFocus)\n      return;\n    function defaultCallback(index) {\n      const nowTime = new Date().getTime();\n      const diffTime = nowTime - lastTabPressTime;\n      if (diffTime > 10)\n        return;\n      eventHandler.emit(\"slideFocusStart\");\n      root.scrollLeft = 0;\n      const group = slideRegistry.findIndex((group2) => group2.includes(index));\n      if (!isNumber(group))\n        return;\n      scrollBody.useDuration(0);\n      scrollTo.index(group, 0);\n      eventHandler.emit(\"slideFocus\");\n    }\n    eventStore.add(document, \"keydown\", registerTabPress, false);\n    slides.forEach((slide, slideIndex) => {\n      eventStore.add(slide, \"focus\", (evt) => {\n        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {\n          defaultCallback(slideIndex);\n        }\n      }, focusListenerOptions);\n    });\n  }\n  function registerTabPress(event) {\n    if (event.code === \"Tab\")\n      lastTabPressTime = new Date().getTime();\n  }\n  const self = {\n    init\n  };\n  return self;\n}\nfunction Vector1D(initialValue) {\n  let value = initialValue;\n  function get() {\n    return value;\n  }\n  function set(n) {\n    value = normalizeInput(n);\n  }\n  function add(n) {\n    value += normalizeInput(n);\n  }\n  function subtract(n) {\n    value -= normalizeInput(n);\n  }\n  function normalizeInput(n) {\n    return isNumber(n) ? n : n.get();\n  }\n  const self = {\n    get,\n    set,\n    add,\n    subtract\n  };\n  return self;\n}\nfunction Translate(axis, container) {\n  const translate = axis.scroll === \"x\" ? x : y;\n  const containerStyle = container.style;\n  let previousTarget = null;\n  let disabled = false;\n  function x(n) {\n    return `translate3d(${n}px,0px,0px)`;\n  }\n  function y(n) {\n    return `translate3d(0px,${n}px,0px)`;\n  }\n  function to(target) {\n    if (disabled)\n      return;\n    const newTarget = roundToTwoDecimals(axis.direction(target));\n    if (newTarget === previousTarget)\n      return;\n    containerStyle.transform = translate(newTarget);\n    previousTarget = newTarget;\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  function clear() {\n    if (disabled)\n      return;\n    containerStyle.transform = \"\";\n    if (!container.getAttribute(\"style\"))\n      container.removeAttribute(\"style\");\n  }\n  const self = {\n    clear,\n    to,\n    toggleActive\n  };\n  return self;\n}\nfunction SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {\n  const roundingSafety = 0.5;\n  const ascItems = arrayKeys(slideSizesWithGaps);\n  const descItems = arrayKeys(slideSizesWithGaps).reverse();\n  const loopPoints = startPoints().concat(endPoints());\n  function removeSlideSizes(indexes, from) {\n    return indexes.reduce((a, i) => {\n      return a - slideSizesWithGaps[i];\n    }, from);\n  }\n  function slidesInGap(indexes, gap) {\n    return indexes.reduce((a, i) => {\n      const remainingGap = removeSlideSizes(a, gap);\n      return remainingGap > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n  function findSlideBounds(offset) {\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + roundingSafety + offset,\n      end: snap + viewSize - roundingSafety + offset\n    }));\n  }\n  function findLoopPoints(indexes, offset, isEndEdge) {\n    const slideBounds = findSlideBounds(offset);\n    return indexes.map((index) => {\n      const initial = isEndEdge ? 0 : -contentSize;\n      const altered = isEndEdge ? contentSize : 0;\n      const boundEdge = isEndEdge ? \"end\" : \"start\";\n      const loopPoint = slideBounds[index][boundEdge];\n      return {\n        index,\n        loopPoint,\n        slideLocation: Vector1D(-1),\n        translate: Translate(axis, slides[index]),\n        target: () => location.get() > loopPoint ? initial : altered\n      };\n    });\n  }\n  function startPoints() {\n    const gap = scrollSnaps[0];\n    const indexes = slidesInGap(descItems, gap);\n    return findLoopPoints(indexes, contentSize, false);\n  }\n  function endPoints() {\n    const gap = viewSize - scrollSnaps[0] - 1;\n    const indexes = slidesInGap(ascItems, gap);\n    return findLoopPoints(indexes, -contentSize, true);\n  }\n  function canLoop() {\n    return loopPoints.every(({\n      index\n    }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index);\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n    });\n  }\n  function loop() {\n    loopPoints.forEach((loopPoint) => {\n      const {\n        target,\n        translate,\n        slideLocation\n      } = loopPoint;\n      const shiftLocation = target();\n      if (shiftLocation === slideLocation.get())\n        return;\n      translate.to(shiftLocation);\n      slideLocation.set(shiftLocation);\n    });\n  }\n  function clear() {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear());\n  }\n  const self = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints\n  };\n  return self;\n}\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n  let mutationObserver;\n  let destroyed = false;\n  function init(emblaApi) {\n    if (!watchSlides)\n      return;\n    function defaultCallback(mutations) {\n      for (const mutation of mutations) {\n        if (mutation.type === \"childList\") {\n          emblaApi.reInit();\n          eventHandler.emit(\"slidesChanged\");\n          break;\n        }\n      }\n    }\n    mutationObserver = new MutationObserver((mutations) => {\n      if (destroyed)\n        return;\n      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n        defaultCallback(mutations);\n      }\n    });\n    mutationObserver.observe(container, {\n      childList: true\n    });\n  }\n  function destroy() {\n    if (mutationObserver)\n      mutationObserver.disconnect();\n    destroyed = true;\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n  const intersectionEntryMap = {};\n  let inViewCache = null;\n  let notInViewCache = null;\n  let intersectionObserver;\n  let destroyed = false;\n  function init() {\n    intersectionObserver = new IntersectionObserver((entries) => {\n      if (destroyed)\n        return;\n      entries.forEach((entry) => {\n        const index = slides.indexOf(entry.target);\n        intersectionEntryMap[index] = entry;\n      });\n      inViewCache = null;\n      notInViewCache = null;\n      eventHandler.emit(\"slidesInView\");\n    }, {\n      root: container.parentElement,\n      threshold\n    });\n    slides.forEach((slide) => intersectionObserver.observe(slide));\n  }\n  function destroy() {\n    if (intersectionObserver)\n      intersectionObserver.disconnect();\n    destroyed = true;\n  }\n  function createInViewList(inView) {\n    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {\n      const index = parseInt(slideIndex);\n      const {\n        isIntersecting\n      } = intersectionEntryMap[index];\n      const inViewMatch = inView && isIntersecting;\n      const notInViewMatch = !inView && !isIntersecting;\n      if (inViewMatch || notInViewMatch)\n        list.push(index);\n      return list;\n    }, []);\n  }\n  function get(inView = true) {\n    if (inView && inViewCache)\n      return inViewCache;\n    if (!inView && notInViewCache)\n      return notInViewCache;\n    const slideIndexes = createInViewList(inView);\n    if (inView)\n      inViewCache = slideIndexes;\n    if (!inView)\n      notInViewCache = slideIndexes;\n    return slideIndexes;\n  }\n  const self = {\n    init,\n    destroy,\n    get\n  };\n  return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n  const {\n    measureSize,\n    startEdge,\n    endEdge\n  } = axis;\n  const withEdgeGap = slideRects[0] && readEdgeGap;\n  const startGap = measureStartGap();\n  const endGap = measureEndGap();\n  const slideSizes = slideRects.map(measureSize);\n  const slideSizesWithGaps = measureWithGaps();\n  function measureStartGap() {\n    if (!withEdgeGap)\n      return 0;\n    const slideRect = slideRects[0];\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n  }\n  function measureEndGap() {\n    if (!withEdgeGap)\n      return 0;\n    const style = ownerWindow.getComputedStyle(arrayLast(slides));\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n  }\n  function measureWithGaps() {\n    return slideRects.map((rect, index, rects) => {\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(rects, index);\n      if (isFirst)\n        return slideSizes[index] + startGap;\n      if (isLast)\n        return slideSizes[index] + endGap;\n      return rects[index + 1][startEdge] - rect[startEdge];\n    }).map(mathAbs);\n  }\n  const self = {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  };\n  return self;\n}\nfunction SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n  const {\n    startEdge,\n    endEdge,\n    direction\n  } = axis;\n  const groupByNumber = isNumber(slidesToScroll);\n  function byNumber(array, groupSize) {\n    return arrayKeys(array).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));\n  }\n  function bySize(array) {\n    if (!array.length)\n      return [];\n    return arrayKeys(array).reduce((groups, rectB, index) => {\n      const rectA = arrayLast(groups) || 0;\n      const isFirst = rectA === 0;\n      const isLast = rectB === arrayLastIndex(array);\n      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n      const gapA = !loop && isFirst ? direction(startGap) : 0;\n      const gapB = !loop && isLast ? direction(endGap) : 0;\n      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n      if (index && chunkSize > viewSize + pixelTolerance)\n        groups.push(rectB);\n      if (isLast)\n        groups.push(array.length);\n      return groups;\n    }, []).map((currentSize, index, groups) => {\n      const previousSize = Math.max(groups[index - 1] || 0);\n      return array.slice(previousSize, currentSize);\n    });\n  }\n  function groupSlides(array) {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n  }\n  const self = {\n    groupSlides\n  };\n  return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {\n  const {\n    align,\n    axis: scrollAxis,\n    direction,\n    startIndex,\n    loop,\n    duration,\n    dragFree,\n    dragThreshold,\n    inViewThreshold,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n    watchResize,\n    watchSlides,\n    watchDrag,\n    watchFocus\n  } = options;\n  const pixelTolerance = 2;\n  const nodeRects = NodeRects();\n  const containerRect = nodeRects.measure(container);\n  const slideRects = slides.map(nodeRects.measure);\n  const axis = Axis(scrollAxis, direction);\n  const viewSize = axis.measureSize(containerRect);\n  const percentOfView = PercentOfView(viewSize);\n  const alignment = Alignment(align, viewSize);\n  const containSnaps = !loop && !!containScroll;\n  const readEdgeGap = loop || !!containScroll;\n  const {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n  const {\n    snaps,\n    snapsAligned\n  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  const {\n    snapsContained,\n    scrollContainLimit\n  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n  const {\n    limit\n  } = ScrollLimit(contentSize, scrollSnaps, loop);\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n  const indexPrevious = index.clone();\n  const slideIndexes = arrayKeys(slides);\n  const update = ({\n    dragHandler,\n    scrollBody: scrollBody2,\n    scrollBounds,\n    options: {\n      loop: loop2\n    }\n  }) => {\n    if (!loop2)\n      scrollBounds.constrain(dragHandler.pointerDown());\n    scrollBody2.seek();\n  };\n  const render = ({\n    scrollBody: scrollBody2,\n    translate,\n    location: location2,\n    offsetLocation: offsetLocation2,\n    previousLocation: previousLocation2,\n    scrollLooper,\n    slideLooper,\n    dragHandler,\n    animation: animation2,\n    eventHandler: eventHandler2,\n    scrollBounds,\n    options: {\n      loop: loop2\n    }\n  }, alpha) => {\n    const shouldSettle = scrollBody2.settled();\n    const withinBounds = !scrollBounds.shouldConstrain();\n    const hasSettled = loop2 ? shouldSettle : shouldSettle && withinBounds;\n    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();\n    if (hasSettledAndIdle)\n      animation2.stop();\n    const interpolatedLocation = location2.get() * alpha + previousLocation2.get() * (1 - alpha);\n    offsetLocation2.set(interpolatedLocation);\n    if (loop2) {\n      scrollLooper.loop(scrollBody2.direction());\n      slideLooper.loop();\n    }\n    translate.to(offsetLocation2.get());\n    if (hasSettledAndIdle)\n      eventHandler2.emit(\"settle\");\n    if (!hasSettled)\n      eventHandler2.emit(\"scroll\");\n  };\n  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), (alpha) => render(engine, alpha));\n  const friction = 0.68;\n  const startLocation = scrollSnaps[index.get()];\n  const location = Vector1D(startLocation);\n  const previousLocation = Vector1D(startLocation);\n  const offsetLocation = Vector1D(startLocation);\n  const target = Vector1D(startLocation);\n  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);\n  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n  const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);\n  const scrollProgress = ScrollProgress(limit);\n  const eventStore = EventStore();\n  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n  const {\n    slideRegistry\n  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);\n  const engine = {\n    ownerDocument,\n    ownerWindow,\n    eventHandler,\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n    eventStore,\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    offsetLocation,\n    previousLocation,\n    options,\n    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n    scrollBody,\n    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),\n    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),\n    scrollProgress,\n    scrollSnapList: scrollSnaps.map(scrollProgress.get),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n    slideFocus,\n    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n    slidesInView,\n    slideIndexes,\n    slideRegistry,\n    slidesToScroll,\n    target,\n    translate: Translate(axis, container)\n  };\n  return engine;\n}\nfunction EventHandler() {\n  let listeners = {};\n  let api;\n  function init(emblaApi) {\n    api = emblaApi;\n  }\n  function getListeners(evt) {\n    return listeners[evt] || [];\n  }\n  function emit(evt) {\n    getListeners(evt).forEach((e) => e(api, evt));\n    return self;\n  }\n  function on(evt, cb) {\n    listeners[evt] = getListeners(evt).concat([cb]);\n    return self;\n  }\n  function off(evt, cb) {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb);\n    return self;\n  }\n  function clear() {\n    listeners = {};\n  }\n  const self = {\n    init,\n    emit,\n    off,\n    on,\n    clear\n  };\n  return self;\n}\nconst defaultOptions = {\n  align: \"center\",\n  axis: \"x\",\n  container: null,\n  slides: null,\n  containScroll: \"trimSnaps\",\n  direction: \"ltr\",\n  slidesToScroll: 1,\n  inViewThreshold: 0,\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startIndex: 0,\n  active: true,\n  watchDrag: true,\n  watchResize: true,\n  watchSlides: true,\n  watchFocus: true\n};\nfunction OptionsHandler(ownerWindow) {\n  function mergeOptions(optionsA, optionsB) {\n    return objectsMergeDeep(optionsA, optionsB || {});\n  }\n  function optionsAtMedia(options) {\n    const optionsAtMedia2 = options.breakpoints || {};\n    const matchedMediaOptions = objectKeys(optionsAtMedia2).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia2[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});\n    return mergeOptions(options, matchedMediaOptions);\n  }\n  function optionsMediaQueries(optionsList) {\n    return optionsList.map((options) => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n  }\n  const self = {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  };\n  return self;\n}\nfunction PluginsHandler(optionsHandler) {\n  let activePlugins = [];\n  function init(emblaApi, plugins) {\n    activePlugins = plugins.filter(({\n      options\n    }) => optionsHandler.optionsAtMedia(options).active !== false);\n    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));\n    return plugins.reduce((map, plugin) => Object.assign(map, {\n      [plugin.name]: plugin\n    }), {});\n  }\n  function destroy() {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy());\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n  const ownerDocument = root.ownerDocument;\n  const ownerWindow = ownerDocument.defaultView;\n  const optionsHandler = OptionsHandler(ownerWindow);\n  const pluginsHandler = PluginsHandler(optionsHandler);\n  const mediaHandlers = EventStore();\n  const eventHandler = EventHandler();\n  const {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  } = optionsHandler;\n  const {\n    on,\n    off,\n    emit\n  } = eventHandler;\n  const reInit = reActivate;\n  let destroyed = false;\n  let engine;\n  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n  let options = mergeOptions(optionsBase);\n  let pluginList = [];\n  let pluginApis;\n  let container;\n  let slides;\n  function storeElements() {\n    const {\n      container: userContainer,\n      slides: userSlides\n    } = options;\n    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n    container = customContainer || root.children[0];\n    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n    slides = [].slice.call(customSlides || container.children);\n  }\n  function createEngine(options2) {\n    const engine2 = Engine(root, container, slides, ownerDocument, ownerWindow, options2, eventHandler);\n    if (options2.loop && !engine2.slideLooper.canLoop()) {\n      const optionsWithoutLoop = Object.assign({}, options2, {\n        loop: false\n      });\n      return createEngine(optionsWithoutLoop);\n    }\n    return engine2;\n  }\n  function activate(withOptions, withPlugins) {\n    if (destroyed)\n      return;\n    optionsBase = mergeOptions(optionsBase, withOptions);\n    options = optionsAtMedia(optionsBase);\n    pluginList = withPlugins || pluginList;\n    storeElements();\n    engine = createEngine(options);\n    optionsMediaQueries([optionsBase, ...pluginList.map(({\n      options: options2\n    }) => options2)]).forEach((query) => mediaHandlers.add(query, \"change\", reActivate));\n    if (!options.active)\n      return;\n    engine.translate.to(engine.location.get());\n    engine.animation.init();\n    engine.slidesInView.init();\n    engine.slideFocus.init(self);\n    engine.eventHandler.init(self);\n    engine.resizeHandler.init(self);\n    engine.slidesHandler.init(self);\n    if (engine.options.loop)\n      engine.slideLooper.loop();\n    if (container.offsetParent && slides.length)\n      engine.dragHandler.init(self);\n    pluginApis = pluginsHandler.init(self, pluginList);\n  }\n  function reActivate(withOptions, withPlugins) {\n    const startIndex = selectedScrollSnap();\n    deActivate();\n    activate(mergeOptions({\n      startIndex\n    }, withOptions), withPlugins);\n    eventHandler.emit(\"reInit\");\n  }\n  function deActivate() {\n    engine.dragHandler.destroy();\n    engine.eventStore.clear();\n    engine.translate.clear();\n    engine.slideLooper.clear();\n    engine.resizeHandler.destroy();\n    engine.slidesHandler.destroy();\n    engine.slidesInView.destroy();\n    engine.animation.destroy();\n    pluginsHandler.destroy();\n    mediaHandlers.clear();\n  }\n  function destroy() {\n    if (destroyed)\n      return;\n    destroyed = true;\n    mediaHandlers.clear();\n    deActivate();\n    eventHandler.emit(\"destroy\");\n    eventHandler.clear();\n  }\n  function scrollTo(index, jump, direction) {\n    if (!options.active || destroyed)\n      return;\n    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n    engine.scrollTo.index(index, direction || 0);\n  }\n  function scrollNext(jump) {\n    const next = engine.index.add(1).get();\n    scrollTo(next, jump, -1);\n  }\n  function scrollPrev(jump) {\n    const prev = engine.index.add(-1).get();\n    scrollTo(prev, jump, 1);\n  }\n  function canScrollNext() {\n    const next = engine.index.add(1).get();\n    return next !== selectedScrollSnap();\n  }\n  function canScrollPrev() {\n    const prev = engine.index.add(-1).get();\n    return prev !== selectedScrollSnap();\n  }\n  function scrollSnapList() {\n    return engine.scrollSnapList;\n  }\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.offsetLocation.get());\n  }\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n  function slidesInView() {\n    return engine.slidesInView.get();\n  }\n  function slidesNotInView() {\n    return engine.slidesInView.get(false);\n  }\n  function plugins() {\n    return pluginApis;\n  }\n  function internalEngine() {\n    return engine;\n  }\n  function rootNode() {\n    return root;\n  }\n  function containerNode() {\n    return container;\n  }\n  function slideNodes() {\n    return slides;\n  }\n  const self = {\n    canScrollNext,\n    canScrollPrev,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    emit,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView\n  };\n  activate(userOptions, userPlugins);\n  setTimeout(() => eventHandler.emit(\"init\"), 0);\n  return self;\n}\nEmblaCarousel.globalOptions = void 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBUyxTQUFTLFNBQVM7QUFDekIsU0FBTyxPQUFPLFlBQVk7QUFDNUI7QUFDQSxTQUFTLFNBQVMsU0FBUztBQUN6QixTQUFPLE9BQU8sWUFBWTtBQUM1QjtBQUNBLFNBQVMsVUFBVSxTQUFTO0FBQzFCLFNBQU8sT0FBTyxZQUFZO0FBQzVCO0FBQ0EsU0FBUyxTQUFTLFNBQVM7QUFDekIsU0FBTyxPQUFPLFVBQVUsU0FBUyxLQUFLLE9BQU8sTUFBTTtBQUNyRDtBQUNBLFNBQVMsUUFBUSxHQUFHO0FBQ2xCLFNBQU8sS0FBSyxJQUFJLENBQUM7QUFDbkI7QUFDQSxTQUFTLFNBQVMsR0FBRztBQUNuQixTQUFPLEtBQUssS0FBSyxDQUFDO0FBQ3BCO0FBQ0EsU0FBUyxTQUFTLFFBQVEsUUFBUTtBQUNoQyxTQUFPLFFBQVEsU0FBUyxNQUFNO0FBQ2hDO0FBQ0EsU0FBUyxVQUFVLFFBQVEsUUFBUTtBQUNqQyxNQUFJLFdBQVcsS0FBSyxXQUFXO0FBQUcsV0FBTztBQUN6QyxNQUFJLFFBQVEsTUFBTSxLQUFLLFFBQVEsTUFBTTtBQUFHLFdBQU87QUFDL0MsUUFBTSxPQUFPLFNBQVMsUUFBUSxNQUFNLEdBQUcsUUFBUSxNQUFNLENBQUM7QUFDdEQsU0FBTyxRQUFRLE9BQU8sTUFBTTtBQUM5QjtBQUNBLFNBQVMsbUJBQW1CLEtBQUs7QUFDL0IsU0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLElBQUk7QUFDakM7QUFDQSxTQUFTLFVBQVUsT0FBTztBQUN4QixTQUFPLFdBQVcsS0FBSyxFQUFFLElBQUksTUFBTTtBQUNyQztBQUNBLFNBQVMsVUFBVSxPQUFPO0FBQ3hCLFNBQU8sTUFBTSxlQUFlLEtBQUssQ0FBQztBQUNwQztBQUNBLFNBQVMsZUFBZSxPQUFPO0FBQzdCLFNBQU8sS0FBSyxJQUFJLEdBQUcsTUFBTSxTQUFTLENBQUM7QUFD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VDtBQUNBLFFBQU0sT0FBTztBQUFBLElBQ1g7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxXQUFTLGFBQWEsV0FBVztBQUNqQyxhQUFXLE1BQU0sYUFBYSxLQUFLLE1BQU0sR0FBRyxDQUFDO0FBQzdDLFNBQU87QUFDVDtBQUNBLGNBQWMsZ0JBQWdCO0FBRU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waWZ5LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcz85NmYxIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzTnVtYmVyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbihzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ2Jvb2xlYW4nO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmZ1bmN0aW9uIG1hdGhBYnMobikge1xuICByZXR1cm4gTWF0aC5hYnMobik7XG59XG5mdW5jdGlvbiBtYXRoU2lnbihuKSB7XG4gIHJldHVybiBNYXRoLnNpZ24obik7XG59XG5mdW5jdGlvbiBkZWx0YUFicyh2YWx1ZUIsIHZhbHVlQSkge1xuICByZXR1cm4gbWF0aEFicyh2YWx1ZUIgLSB2YWx1ZUEpO1xufVxuZnVuY3Rpb24gZmFjdG9yQWJzKHZhbHVlQiwgdmFsdWVBKSB7XG4gIGlmICh2YWx1ZUIgPT09IDAgfHwgdmFsdWVBID09PSAwKSByZXR1cm4gMDtcbiAgaWYgKG1hdGhBYnModmFsdWVCKSA8PSBtYXRoQWJzKHZhbHVlQSkpIHJldHVybiAwO1xuICBjb25zdCBkaWZmID0gZGVsdGFBYnMobWF0aEFicyh2YWx1ZUIpLCBtYXRoQWJzKHZhbHVlQSkpO1xuICByZXR1cm4gbWF0aEFicyhkaWZmIC8gdmFsdWVCKTtcbn1cbmZ1bmN0aW9uIHJvdW5kVG9Ud29EZWNpbWFscyhudW0pIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMTAwKSAvIDEwMDtcbn1cbmZ1bmN0aW9uIGFycmF5S2V5cyhhcnJheSkge1xuICByZXR1cm4gb2JqZWN0S2V5cyhhcnJheSkubWFwKE51bWJlcik7XG59XG5mdW5jdGlvbiBhcnJheUxhc3QoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5W2FycmF5TGFzdEluZGV4KGFycmF5KV07XG59XG5mdW5jdGlvbiBhcnJheUxhc3RJbmRleChhcnJheSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBhcnJheUlzTGFzdEluZGV4KGFycmF5LCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPT09IGFycmF5TGFzdEluZGV4KGFycmF5KTtcbn1cbmZ1bmN0aW9uIGFycmF5RnJvbU51bWJlcihuLCBzdGFydEF0ID0gMCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShBcnJheShuKSwgKF8sIGkpID0+IHN0YXJ0QXQgKyBpKTtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xufVxuZnVuY3Rpb24gb2JqZWN0c01lcmdlRGVlcChvYmplY3RBLCBvYmplY3RCKSB7XG4gIHJldHVybiBbb2JqZWN0QSwgb2JqZWN0Ql0ucmVkdWNlKChtZXJnZWRPYmplY3RzLCBjdXJyZW50T2JqZWN0KSA9PiB7XG4gICAgb2JqZWN0S2V5cyhjdXJyZW50T2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZUEgPSBtZXJnZWRPYmplY3RzW2tleV07XG4gICAgICBjb25zdCB2YWx1ZUIgPSBjdXJyZW50T2JqZWN0W2tleV07XG4gICAgICBjb25zdCBhcmVPYmplY3RzID0gaXNPYmplY3QodmFsdWVBKSAmJiBpc09iamVjdCh2YWx1ZUIpO1xuICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gYXJlT2JqZWN0cyA/IG9iamVjdHNNZXJnZURlZXAodmFsdWVBLCB2YWx1ZUIpIDogdmFsdWVCO1xuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWRPYmplY3RzO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdykge1xuICByZXR1cm4gdHlwZW9mIG93bmVyV2luZG93Lk1vdXNlRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIGV2dCBpbnN0YW5jZW9mIG93bmVyV2luZG93Lk1vdXNlRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIEFsaWdubWVudChhbGlnbiwgdmlld1NpemUpIHtcbiAgY29uc3QgcHJlZGVmaW5lZCA9IHtcbiAgICBzdGFydCxcbiAgICBjZW50ZXIsXG4gICAgZW5kXG4gIH07XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNlbnRlcihuKSB7XG4gICAgcmV0dXJuIGVuZChuKSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZW5kKG4pIHtcbiAgICByZXR1cm4gdmlld1NpemUgLSBuO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmUobiwgaW5kZXgpIHtcbiAgICBpZiAoaXNTdHJpbmcoYWxpZ24pKSByZXR1cm4gcHJlZGVmaW5lZFthbGlnbl0obik7XG4gICAgcmV0dXJuIGFsaWduKHZpZXdTaXplLCBuLCBpbmRleCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFdmVudFN0b3JlKCkge1xuICBsZXQgbGlzdGVuZXJzID0gW107XG4gIGZ1bmN0aW9uIGFkZChub2RlLCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSkge1xuICAgIGxldCByZW1vdmVMaXN0ZW5lcjtcbiAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG5vZGUpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyID0gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZWdhY3lNZWRpYVF1ZXJ5TGlzdCA9IG5vZGU7XG4gICAgICBsZWdhY3lNZWRpYVF1ZXJ5TGlzdC5hZGRMaXN0ZW5lcihoYW5kbGVyKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyID0gKCkgPT4gbGVnYWN5TWVkaWFRdWVyeUxpc3QucmVtb3ZlTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGxpc3RlbmVycy5wdXNoKHJlbW92ZUxpc3RlbmVyKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKHJlbW92ZSA9PiByZW1vdmUoKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBhZGQsXG4gICAgY2xlYXJcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbnMob3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHVwZGF0ZSwgcmVuZGVyKSB7XG4gIGNvbnN0IGRvY3VtZW50VmlzaWJsZUhhbmRsZXIgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGZpeGVkVGltZVN0ZXAgPSAxMDAwIC8gNjA7XG4gIGxldCBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgbGV0IGFjY3VtdWxhdGVkVGltZSA9IDA7XG4gIGxldCBhbmltYXRpb25JZCA9IDA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5hZGQob3duZXJEb2N1bWVudCwgJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpZiAob3duZXJEb2N1bWVudC5oaWRkZW4pIHJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBzdG9wKCk7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFuaW1hdGUodGltZVN0YW1wKSB7XG4gICAgaWYgKCFhbmltYXRpb25JZCkgcmV0dXJuO1xuICAgIGlmICghbGFzdFRpbWVTdGFtcCkge1xuICAgICAgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gdGltZVN0YW1wIC0gbGFzdFRpbWVTdGFtcDtcbiAgICBsYXN0VGltZVN0YW1wID0gdGltZVN0YW1wO1xuICAgIGFjY3VtdWxhdGVkVGltZSArPSB0aW1lRWxhcHNlZDtcbiAgICB3aGlsZSAoYWNjdW11bGF0ZWRUaW1lID49IGZpeGVkVGltZVN0ZXApIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgYWNjdW11bGF0ZWRUaW1lIC09IGZpeGVkVGltZVN0ZXA7XG4gICAgfVxuICAgIGNvbnN0IGFscGhhID0gYWNjdW11bGF0ZWRUaW1lIC8gZml4ZWRUaW1lU3RlcDtcbiAgICByZW5kZXIoYWxwaGEpO1xuICAgIGlmIChhbmltYXRpb25JZCkge1xuICAgICAgYW5pbWF0aW9uSWQgPSBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGlmIChhbmltYXRpb25JZCkgcmV0dXJuO1xuICAgIGFuaW1hdGlvbklkID0gb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgb3duZXJXaW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWQpO1xuICAgIGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICAgIGFjY3VtdWxhdGVkVGltZSA9IDA7XG4gICAgYW5pbWF0aW9uSWQgPSAwO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICAgIGFjY3VtdWxhdGVkVGltZSA9IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICB1cGRhdGUsXG4gICAgcmVuZGVyXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBBeGlzKGF4aXMsIGNvbnRlbnREaXJlY3Rpb24pIHtcbiAgY29uc3QgaXNSaWdodFRvTGVmdCA9IGNvbnRlbnREaXJlY3Rpb24gPT09ICdydGwnO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gYXhpcyA9PT0gJ3knO1xuICBjb25zdCBzY3JvbGwgPSBpc1ZlcnRpY2FsID8gJ3knIDogJ3gnO1xuICBjb25zdCBjcm9zcyA9IGlzVmVydGljYWwgPyAneCcgOiAneSc7XG4gIGNvbnN0IHNpZ24gPSAhaXNWZXJ0aWNhbCAmJiBpc1JpZ2h0VG9MZWZ0ID8gLTEgOiAxO1xuICBjb25zdCBzdGFydEVkZ2UgPSBnZXRTdGFydEVkZ2UoKTtcbiAgY29uc3QgZW5kRWRnZSA9IGdldEVuZEVkZ2UoKTtcbiAgZnVuY3Rpb24gbWVhc3VyZVNpemUobm9kZVJlY3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBub2RlUmVjdDtcbiAgICByZXR1cm4gaXNWZXJ0aWNhbCA/IGhlaWdodCA6IHdpZHRoO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXJ0RWRnZSgpIHtcbiAgICBpZiAoaXNWZXJ0aWNhbCkgcmV0dXJuICd0b3AnO1xuICAgIHJldHVybiBpc1JpZ2h0VG9MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgfVxuICBmdW5jdGlvbiBnZXRFbmRFZGdlKCkge1xuICAgIGlmIChpc1ZlcnRpY2FsKSByZXR1cm4gJ2JvdHRvbSc7XG4gICAgcmV0dXJuIGlzUmlnaHRUb0xlZnQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbihuKSB7XG4gICAgcmV0dXJuIG4gKiBzaWduO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2Nyb2xsLFxuICAgIGNyb3NzLFxuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlLFxuICAgIG1lYXN1cmVTaXplLFxuICAgIGRpcmVjdGlvblxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gTGltaXQobWluID0gMCwgbWF4ID0gMCkge1xuICBjb25zdCBsZW5ndGggPSBtYXRoQWJzKG1pbiAtIG1heCk7XG4gIGZ1bmN0aW9uIHJlYWNoZWRNaW4obikge1xuICAgIHJldHVybiBuIDwgbWluO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWNoZWRNYXgobikge1xuICAgIHJldHVybiBuID4gbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHJlYWNoZWRBbnkobikge1xuICAgIHJldHVybiByZWFjaGVkTWluKG4pIHx8IHJlYWNoZWRNYXgobik7XG4gIH1cbiAgZnVuY3Rpb24gY29uc3RyYWluKG4pIHtcbiAgICBpZiAoIXJlYWNoZWRBbnkobikpIHJldHVybiBuO1xuICAgIHJldHVybiByZWFjaGVkTWluKG4pID8gbWluIDogbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9mZnNldChuKSB7XG4gICAgaWYgKCFsZW5ndGgpIHJldHVybiBuO1xuICAgIHJldHVybiBuIC0gbGVuZ3RoICogTWF0aC5jZWlsKChuIC0gbWF4KSAvIGxlbmd0aCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsZW5ndGgsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBjb25zdHJhaW4sXG4gICAgcmVhY2hlZEFueSxcbiAgICByZWFjaGVkTWF4LFxuICAgIHJlYWNoZWRNaW4sXG4gICAgcmVtb3ZlT2Zmc2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBDb3VudGVyKG1heCwgc3RhcnQsIGxvb3ApIHtcbiAgY29uc3Qge1xuICAgIGNvbnN0cmFpblxuICB9ID0gTGltaXQoMCwgbWF4KTtcbiAgY29uc3QgbG9vcEVuZCA9IG1heCArIDE7XG4gIGxldCBjb3VudGVyID0gd2l0aGluTGltaXQoc3RhcnQpO1xuICBmdW5jdGlvbiB3aXRoaW5MaW1pdChuKSB7XG4gICAgcmV0dXJuICFsb29wID8gY29uc3RyYWluKG4pIDogbWF0aEFicygobG9vcEVuZCArIG4pICUgbG9vcEVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgY291bnRlciA9IHdpdGhpbkxpbWl0KG4pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChuKSB7XG4gICAgcmV0dXJuIGNsb25lKCkuc2V0KGdldCgpICsgbik7XG4gIH1cbiAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIENvdW50ZXIobWF4LCBnZXQoKSwgbG9vcCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBjbG9uZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ0hhbmRsZXIoYXhpcywgcm9vdE5vZGUsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB0YXJnZXQsIGRyYWdUcmFja2VyLCBsb2NhdGlvbiwgYW5pbWF0aW9uLCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCBpbmRleCwgZXZlbnRIYW5kbGVyLCBwZXJjZW50T2ZWaWV3LCBkcmFnRnJlZSwgZHJhZ1RocmVzaG9sZCwgc2tpcFNuYXBzLCBiYXNlRnJpY3Rpb24sIHdhdGNoRHJhZykge1xuICBjb25zdCB7XG4gICAgY3Jvc3M6IGNyb3NzQXhpcyxcbiAgICBkaXJlY3Rpb25cbiAgfSA9IGF4aXM7XG4gIGNvbnN0IGZvY3VzTm9kZXMgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuICBjb25zdCBub25QYXNzaXZlRXZlbnQgPSB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfTtcbiAgY29uc3QgaW5pdEV2ZW50cyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZHJhZ0V2ZW50cyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZ29Ub05leHRUaHJlc2hvbGQgPSBMaW1pdCg1MCwgMjI1KS5jb25zdHJhaW4ocGVyY2VudE9mVmlldy5tZWFzdXJlKDIwKSk7XG4gIGNvbnN0IHNuYXBGb3JjZUJvb3N0ID0ge1xuICAgIG1vdXNlOiAzMDAsXG4gICAgdG91Y2g6IDQwMFxuICB9O1xuICBjb25zdCBmcmVlRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogNTAwLFxuICAgIHRvdWNoOiA2MDBcbiAgfTtcbiAgY29uc3QgYmFzZVNwZWVkID0gZHJhZ0ZyZWUgPyA0MyA6IDI1O1xuICBsZXQgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgbGV0IHN0YXJ0U2Nyb2xsID0gMDtcbiAgbGV0IHN0YXJ0Q3Jvc3MgPSAwO1xuICBsZXQgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICBsZXQgcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICBsZXQgcHJldmVudENsaWNrID0gZmFsc2U7XG4gIGxldCBpc01vdXNlID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBpZiAoIXdhdGNoRHJhZykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRvd25JZkFsbG93ZWQoZXZ0KSB7XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoRHJhZykgfHwgd2F0Y2hEcmFnKGVtYmxhQXBpLCBldnQpKSBkb3duKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSByb290Tm9kZTtcbiAgICBpbml0RXZlbnRzLmFkZChub2RlLCAnZHJhZ3N0YXJ0JywgZXZ0ID0+IGV2dC5wcmV2ZW50RGVmYXVsdCgpLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2htb3ZlJywgKCkgPT4gdW5kZWZpbmVkLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCAoKSA9PiB1bmRlZmluZWQpLmFkZChub2RlLCAndG91Y2hzdGFydCcsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAnbW91c2Vkb3duJywgZG93bklmQWxsb3dlZCkuYWRkKG5vZGUsICd0b3VjaGNhbmNlbCcsIHVwKS5hZGQobm9kZSwgJ2NvbnRleHRtZW51JywgdXApLmFkZChub2RlLCAnY2xpY2snLCBjbGljaywgdHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpbml0RXZlbnRzLmNsZWFyKCk7XG4gICAgZHJhZ0V2ZW50cy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZERyYWdFdmVudHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGlzTW91c2UgPyBvd25lckRvY3VtZW50IDogcm9vdE5vZGU7XG4gICAgZHJhZ0V2ZW50cy5hZGQobm9kZSwgJ3RvdWNobW92ZScsIG1vdmUsIG5vblBhc3NpdmVFdmVudCkuYWRkKG5vZGUsICd0b3VjaGVuZCcsIHVwKS5hZGQobm9kZSwgJ21vdXNlbW92ZScsIG1vdmUsIG5vblBhc3NpdmVFdmVudCkuYWRkKG5vZGUsICdtb3VzZXVwJywgdXApO1xuICB9XG4gIGZ1bmN0aW9uIGlzRm9jdXNOb2RlKG5vZGUpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUgfHwgJyc7XG4gICAgcmV0dXJuIGZvY3VzTm9kZXMuaW5jbHVkZXMobm9kZU5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcmNlQm9vc3QoKSB7XG4gICAgY29uc3QgYm9vc3QgPSBkcmFnRnJlZSA/IGZyZWVGb3JjZUJvb3N0IDogc25hcEZvcmNlQm9vc3Q7XG4gICAgY29uc3QgdHlwZSA9IGlzTW91c2UgPyAnbW91c2UnIDogJ3RvdWNoJztcbiAgICByZXR1cm4gYm9vc3RbdHlwZV07XG4gIH1cbiAgZnVuY3Rpb24gYWxsb3dlZEZvcmNlKGZvcmNlLCB0YXJnZXRDaGFuZ2VkKSB7XG4gICAgY29uc3QgbmV4dCA9IGluZGV4LmFkZChtYXRoU2lnbihmb3JjZSkgKiAtMSk7XG4gICAgY29uc3QgYmFzZUZvcmNlID0gc2Nyb2xsVGFyZ2V0LmJ5RGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSkuZGlzdGFuY2U7XG4gICAgaWYgKGRyYWdGcmVlIHx8IG1hdGhBYnMoZm9yY2UpIDwgZ29Ub05leHRUaHJlc2hvbGQpIHJldHVybiBiYXNlRm9yY2U7XG4gICAgaWYgKHNraXBTbmFwcyAmJiB0YXJnZXRDaGFuZ2VkKSByZXR1cm4gYmFzZUZvcmNlICogMC41O1xuICAgIHJldHVybiBzY3JvbGxUYXJnZXQuYnlJbmRleChuZXh0LmdldCgpLCAwKS5kaXN0YW5jZTtcbiAgfVxuICBmdW5jdGlvbiBkb3duKGV2dCkge1xuICAgIGNvbnN0IGlzTW91c2VFdnQgPSBpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdyk7XG4gICAgaXNNb3VzZSA9IGlzTW91c2VFdnQ7XG4gICAgcHJldmVudENsaWNrID0gZHJhZ0ZyZWUgJiYgaXNNb3VzZUV2dCAmJiAhZXZ0LmJ1dHRvbnMgJiYgaXNNb3Zpbmc7XG4gICAgaXNNb3ZpbmcgPSBkZWx0YUFicyh0YXJnZXQuZ2V0KCksIGxvY2F0aW9uLmdldCgpKSA+PSAyO1xuICAgIGlmIChpc01vdXNlRXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICBpZiAoaXNGb2N1c05vZGUoZXZ0LnRhcmdldCkpIHJldHVybjtcbiAgICBwb2ludGVySXNEb3duID0gdHJ1ZTtcbiAgICBkcmFnVHJhY2tlci5wb2ludGVyRG93bihldnQpO1xuICAgIHNjcm9sbEJvZHkudXNlRnJpY3Rpb24oMCkudXNlRHVyYXRpb24oMCk7XG4gICAgdGFyZ2V0LnNldChsb2NhdGlvbik7XG4gICAgYWRkRHJhZ0V2ZW50cygpO1xuICAgIHN0YXJ0U2Nyb2xsID0gZHJhZ1RyYWNrZXIucmVhZFBvaW50KGV2dCk7XG4gICAgc3RhcnRDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3BvaW50ZXJEb3duJyk7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZShldnQpIHtcbiAgICBjb25zdCBpc1RvdWNoRXZ0ID0gIWlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KTtcbiAgICBpZiAoaXNUb3VjaEV2dCAmJiBldnQudG91Y2hlcy5sZW5ndGggPj0gMikgcmV0dXJuIHVwKGV2dCk7XG4gICAgY29uc3QgbGFzdFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIGNvbnN0IGxhc3RDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgY29uc3QgZGlmZlNjcm9sbCA9IGRlbHRhQWJzKGxhc3RTY3JvbGwsIHN0YXJ0U2Nyb2xsKTtcbiAgICBjb25zdCBkaWZmQ3Jvc3MgPSBkZWx0YUFicyhsYXN0Q3Jvc3MsIHN0YXJ0Q3Jvc3MpO1xuICAgIGlmICghcHJldmVudFNjcm9sbCAmJiAhaXNNb3VzZSkge1xuICAgICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuIHVwKGV2dCk7XG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZGlmZlNjcm9sbCA+IGRpZmZDcm9zcztcbiAgICAgIGlmICghcHJldmVudFNjcm9sbCkgcmV0dXJuIHVwKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBkcmFnVHJhY2tlci5wb2ludGVyTW92ZShldnQpO1xuICAgIGlmIChkaWZmU2Nyb2xsID4gZHJhZ1RocmVzaG9sZCkgcHJldmVudENsaWNrID0gdHJ1ZTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDAuMykudXNlRHVyYXRpb24oMC43NSk7XG4gICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgdGFyZ2V0LmFkZChkaXJlY3Rpb24oZGlmZikpO1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwKGV2dCkge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKDAsIGZhbHNlKTtcbiAgICBjb25zdCB0YXJnZXRDaGFuZ2VkID0gY3VycmVudExvY2F0aW9uLmluZGV4ICE9PSBpbmRleC5nZXQoKTtcbiAgICBjb25zdCByYXdGb3JjZSA9IGRyYWdUcmFja2VyLnBvaW50ZXJVcChldnQpICogZm9yY2VCb29zdCgpO1xuICAgIGNvbnN0IGZvcmNlID0gYWxsb3dlZEZvcmNlKGRpcmVjdGlvbihyYXdGb3JjZSksIHRhcmdldENoYW5nZWQpO1xuICAgIGNvbnN0IGZvcmNlRmFjdG9yID0gZmFjdG9yQWJzKHJhd0ZvcmNlLCBmb3JjZSk7XG4gICAgY29uc3Qgc3BlZWQgPSBiYXNlU3BlZWQgLSAxMCAqIGZvcmNlRmFjdG9yO1xuICAgIGNvbnN0IGZyaWN0aW9uID0gYmFzZUZyaWN0aW9uICsgZm9yY2VGYWN0b3IgLyA1MDtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgICBzY3JvbGxCb2R5LnVzZUR1cmF0aW9uKHNwZWVkKS51c2VGcmljdGlvbihmcmljdGlvbik7XG4gICAgc2Nyb2xsVG8uZGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSk7XG4gICAgaXNNb3VzZSA9IGZhbHNlO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyVXAnKTtcbiAgfVxuICBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICBpZiAocHJldmVudENsaWNrKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHByZXZlbnRDbGljayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bigpIHtcbiAgICByZXR1cm4gcG9pbnRlcklzRG93bjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveSxcbiAgICBwb2ludGVyRG93blxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ1RyYWNrZXIoYXhpcywgb3duZXJXaW5kb3cpIHtcbiAgY29uc3QgbG9nSW50ZXJ2YWwgPSAxNzA7XG4gIGxldCBzdGFydEV2ZW50O1xuICBsZXQgbGFzdEV2ZW50O1xuICBmdW5jdGlvbiByZWFkVGltZShldnQpIHtcbiAgICByZXR1cm4gZXZ0LnRpbWVTdGFtcDtcbiAgfVxuICBmdW5jdGlvbiByZWFkUG9pbnQoZXZ0LCBldnRBeGlzKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBldnRBeGlzIHx8IGF4aXMuc2Nyb2xsO1xuICAgIGNvbnN0IGNvb3JkID0gYGNsaWVudCR7cHJvcGVydHkgPT09ICd4JyA/ICdYJyA6ICdZJ31gO1xuICAgIHJldHVybiAoaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpID8gZXZ0IDogZXZ0LnRvdWNoZXNbMF0pW2Nvb3JkXTtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bihldnQpIHtcbiAgICBzdGFydEV2ZW50ID0gZXZ0O1xuICAgIGxhc3RFdmVudCA9IGV2dDtcbiAgICByZXR1cm4gcmVhZFBvaW50KGV2dCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1vdmUoZXZ0KSB7XG4gICAgY29uc3QgZGlmZiA9IHJlYWRQb2ludChldnQpIC0gcmVhZFBvaW50KGxhc3RFdmVudCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IHJlYWRUaW1lKGV2dCkgLSByZWFkVGltZShzdGFydEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGxhc3RFdmVudCA9IGV2dDtcbiAgICBpZiAoZXhwaXJlZCkgc3RhcnRFdmVudCA9IGV2dDtcbiAgICByZXR1cm4gZGlmZjtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyVXAoZXZ0KSB7XG4gICAgaWYgKCFzdGFydEV2ZW50IHx8ICFsYXN0RXZlbnQpIHJldHVybiAwO1xuICAgIGNvbnN0IGRpZmZEcmFnID0gcmVhZFBvaW50KGxhc3RFdmVudCkgLSByZWFkUG9pbnQoc3RhcnRFdmVudCk7XG4gICAgY29uc3QgZGlmZlRpbWUgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IHJlYWRUaW1lKGV2dCkgLSByZWFkVGltZShsYXN0RXZlbnQpID4gbG9nSW50ZXJ2YWw7XG4gICAgY29uc3QgZm9yY2UgPSBkaWZmRHJhZyAvIGRpZmZUaW1lO1xuICAgIGNvbnN0IGlzRmxpY2sgPSBkaWZmVGltZSAmJiAhZXhwaXJlZCAmJiBtYXRoQWJzKGZvcmNlKSA+IDAuMTtcbiAgICByZXR1cm4gaXNGbGljayA/IGZvcmNlIDogMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHBvaW50ZXJEb3duLFxuICAgIHBvaW50ZXJNb3ZlLFxuICAgIHBvaW50ZXJVcCxcbiAgICByZWFkUG9pbnRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIE5vZGVSZWN0cygpIHtcbiAgZnVuY3Rpb24gbWVhc3VyZShub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0VG9wLFxuICAgICAgb2Zmc2V0TGVmdCxcbiAgICAgIG9mZnNldFdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoLFxuICAgICAgYm90dG9tOiBvZmZzZXRUb3AgKyBvZmZzZXRIZWlnaHQsXG4gICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgd2lkdGg6IG9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHRcbiAgICB9O1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBQZXJjZW50T2ZWaWV3KHZpZXdTaXplKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobikge1xuICAgIHJldHVybiB2aWV3U2l6ZSAqIChuIC8gMTAwKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lYXN1cmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFJlc2l6ZUhhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIG93bmVyV2luZG93LCBzbGlkZXMsIGF4aXMsIHdhdGNoUmVzaXplLCBub2RlUmVjdHMpIHtcbiAgY29uc3Qgb2JzZXJ2ZU5vZGVzID0gW2NvbnRhaW5lcl0uY29uY2F0KHNsaWRlcyk7XG4gIGxldCByZXNpemVPYnNlcnZlcjtcbiAgbGV0IGNvbnRhaW5lclNpemU7XG4gIGxldCBzbGlkZVNpemVzID0gW107XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcmVhZFNpemUobm9kZSkge1xuICAgIHJldHVybiBheGlzLm1lYXN1cmVTaXplKG5vZGVSZWN0cy5tZWFzdXJlKG5vZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFJlc2l6ZSkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclNpemUgPSByZWFkU2l6ZShjb250YWluZXIpO1xuICAgIHNsaWRlU2l6ZXMgPSBzbGlkZXMubWFwKHJlYWRTaXplKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZW50cmllcykge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNDb250YWluZXIgPSBlbnRyeS50YXJnZXQgPT09IGNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IHNsaWRlcy5pbmRleE9mKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGxhc3RTaXplID0gaXNDb250YWluZXIgPyBjb250YWluZXJTaXplIDogc2xpZGVTaXplc1tzbGlkZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHJlYWRTaXplKGlzQ29udGFpbmVyID8gY29udGFpbmVyIDogc2xpZGVzW3NsaWRlSW5kZXhdKTtcbiAgICAgICAgY29uc3QgZGlmZlNpemUgPSBtYXRoQWJzKG5ld1NpemUgLSBsYXN0U2l6ZSk7XG4gICAgICAgIGlmIChkaWZmU2l6ZSA+PSAwLjUpIHtcbiAgICAgICAgICBlbWJsYUFwaS5yZUluaXQoKTtcbiAgICAgICAgICBldmVudEhhbmRsZXIuZW1pdCgncmVzaXplJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoUmVzaXplKSB8fCB3YXRjaFJlc2l6ZShlbWJsYUFwaSwgZW50cmllcykpIHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKGVudHJpZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG93bmVyV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBvYnNlcnZlTm9kZXMuZm9yRWFjaChub2RlID0+IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpZiAocmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHByZXZpb3VzTG9jYXRpb24sIHRhcmdldCwgYmFzZUR1cmF0aW9uLCBiYXNlRnJpY3Rpb24pIHtcbiAgbGV0IHNjcm9sbFZlbG9jaXR5ID0gMDtcbiAgbGV0IHNjcm9sbERpcmVjdGlvbiA9IDA7XG4gIGxldCBzY3JvbGxEdXJhdGlvbiA9IGJhc2VEdXJhdGlvbjtcbiAgbGV0IHNjcm9sbEZyaWN0aW9uID0gYmFzZUZyaWN0aW9uO1xuICBsZXQgcmF3TG9jYXRpb24gPSBsb2NhdGlvbi5nZXQoKTtcbiAgbGV0IHJhd0xvY2F0aW9uUHJldmlvdXMgPSAwO1xuICBmdW5jdGlvbiBzZWVrKCkge1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRhcmdldC5nZXQoKSAtIGxvY2F0aW9uLmdldCgpO1xuICAgIGNvbnN0IGlzSW5zdGFudCA9ICFzY3JvbGxEdXJhdGlvbjtcbiAgICBsZXQgc2Nyb2xsRGlzdGFuY2UgPSAwO1xuICAgIGlmIChpc0luc3RhbnQpIHtcbiAgICAgIHNjcm9sbFZlbG9jaXR5ID0gMDtcbiAgICAgIHByZXZpb3VzTG9jYXRpb24uc2V0KHRhcmdldCk7XG4gICAgICBsb2NhdGlvbi5zZXQodGFyZ2V0KTtcbiAgICAgIHNjcm9sbERpc3RhbmNlID0gZGlzcGxhY2VtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0xvY2F0aW9uLnNldChsb2NhdGlvbik7XG4gICAgICBzY3JvbGxWZWxvY2l0eSArPSBkaXNwbGFjZW1lbnQgLyBzY3JvbGxEdXJhdGlvbjtcbiAgICAgIHNjcm9sbFZlbG9jaXR5ICo9IHNjcm9sbEZyaWN0aW9uO1xuICAgICAgcmF3TG9jYXRpb24gKz0gc2Nyb2xsVmVsb2NpdHk7XG4gICAgICBsb2NhdGlvbi5hZGQoc2Nyb2xsVmVsb2NpdHkpO1xuICAgICAgc2Nyb2xsRGlzdGFuY2UgPSByYXdMb2NhdGlvbiAtIHJhd0xvY2F0aW9uUHJldmlvdXM7XG4gICAgfVxuICAgIHNjcm9sbERpcmVjdGlvbiA9IG1hdGhTaWduKHNjcm9sbERpc3RhbmNlKTtcbiAgICByYXdMb2NhdGlvblByZXZpb3VzID0gcmF3TG9jYXRpb247XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gc2V0dGxlZCgpIHtcbiAgICBjb25zdCBkaWZmID0gdGFyZ2V0LmdldCgpIC0gb2Zmc2V0TG9jYXRpb24uZ2V0KCk7XG4gICAgcmV0dXJuIG1hdGhBYnMoZGlmZikgPCAwLjAwMTtcbiAgfVxuICBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRHVyYXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBzY3JvbGxEaXJlY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gdmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHNjcm9sbFZlbG9jaXR5O1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJhc2VEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdXNlRHVyYXRpb24oYmFzZUR1cmF0aW9uKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VCYXNlRnJpY3Rpb24oKSB7XG4gICAgcmV0dXJuIHVzZUZyaWN0aW9uKGJhc2VGcmljdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRHVyYXRpb24obikge1xuICAgIHNjcm9sbER1cmF0aW9uID0gbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiB1c2VGcmljdGlvbihuKSB7XG4gICAgc2Nyb2xsRnJpY3Rpb24gPSBuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZGlyZWN0aW9uLFxuICAgIGR1cmF0aW9uLFxuICAgIHZlbG9jaXR5LFxuICAgIHNlZWssXG4gICAgc2V0dGxlZCxcbiAgICB1c2VCYXNlRnJpY3Rpb24sXG4gICAgdXNlQmFzZUR1cmF0aW9uLFxuICAgIHVzZUZyaWN0aW9uLFxuICAgIHVzZUR1cmF0aW9uXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxCb3VuZHMobGltaXQsIGxvY2F0aW9uLCB0YXJnZXQsIHNjcm9sbEJvZHksIHBlcmNlbnRPZlZpZXcpIHtcbiAgY29uc3QgcHVsbEJhY2tUaHJlc2hvbGQgPSBwZXJjZW50T2ZWaWV3Lm1lYXN1cmUoMTApO1xuICBjb25zdCBlZGdlT2Zmc2V0VG9sZXJhbmNlID0gcGVyY2VudE9mVmlldy5tZWFzdXJlKDUwKTtcbiAgY29uc3QgZnJpY3Rpb25MaW1pdCA9IExpbWl0KDAuMSwgMC45OSk7XG4gIGxldCBkaXNhYmxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBzaG91bGRDb25zdHJhaW4oKSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFsaW1pdC5yZWFjaGVkQW55KHRhcmdldC5nZXQoKSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWxpbWl0LnJlYWNoZWRBbnkobG9jYXRpb24uZ2V0KCkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY29uc3RyYWluKHBvaW50ZXJEb3duKSB7XG4gICAgaWYgKCFzaG91bGRDb25zdHJhaW4oKSkgcmV0dXJuO1xuICAgIGNvbnN0IGVkZ2UgPSBsaW1pdC5yZWFjaGVkTWluKGxvY2F0aW9uLmdldCgpKSA/ICdtaW4nIDogJ21heCc7XG4gICAgY29uc3QgZGlmZlRvRWRnZSA9IG1hdGhBYnMobGltaXRbZWRnZV0gLSBsb2NhdGlvbi5nZXQoKSk7XG4gICAgY29uc3QgZGlmZlRvVGFyZ2V0ID0gdGFyZ2V0LmdldCgpIC0gbG9jYXRpb24uZ2V0KCk7XG4gICAgY29uc3QgZnJpY3Rpb24gPSBmcmljdGlvbkxpbWl0LmNvbnN0cmFpbihkaWZmVG9FZGdlIC8gZWRnZU9mZnNldFRvbGVyYW5jZSk7XG4gICAgdGFyZ2V0LnN1YnRyYWN0KGRpZmZUb1RhcmdldCAqIGZyaWN0aW9uKTtcbiAgICBpZiAoIXBvaW50ZXJEb3duICYmIG1hdGhBYnMoZGlmZlRvVGFyZ2V0KSA8IHB1bGxCYWNrVGhyZXNob2xkKSB7XG4gICAgICB0YXJnZXQuc2V0KGxpbWl0LmNvbnN0cmFpbih0YXJnZXQuZ2V0KCkpKTtcbiAgICAgIHNjcm9sbEJvZHkudXNlRHVyYXRpb24oMjUpLnVzZUJhc2VGcmljdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVBY3RpdmUoYWN0aXZlKSB7XG4gICAgZGlzYWJsZWQgPSAhYWN0aXZlO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2hvdWxkQ29uc3RyYWluLFxuICAgIGNvbnN0cmFpbixcbiAgICB0b2dnbGVBY3RpdmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbENvbnRhaW4odmlld1NpemUsIGNvbnRlbnRTaXplLCBzbmFwc0FsaWduZWQsIGNvbnRhaW5TY3JvbGwsIHBpeGVsVG9sZXJhbmNlKSB7XG4gIGNvbnN0IHNjcm9sbEJvdW5kcyA9IExpbWl0KC1jb250ZW50U2l6ZSArIHZpZXdTaXplLCAwKTtcbiAgY29uc3Qgc25hcHNCb3VuZGVkID0gbWVhc3VyZUJvdW5kZWQoKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbkxpbWl0ID0gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpO1xuICBjb25zdCBzbmFwc0NvbnRhaW5lZCA9IG1lYXN1cmVDb250YWluZWQoKTtcbiAgZnVuY3Rpb24gdXNlUGl4ZWxUb2xlcmFuY2UoYm91bmQsIHNuYXApIHtcbiAgICByZXR1cm4gZGVsdGFBYnMoYm91bmQsIHNuYXApIDw9IDE7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpIHtcbiAgICBjb25zdCBzdGFydFNuYXAgPSBzbmFwc0JvdW5kZWRbMF07XG4gICAgY29uc3QgZW5kU25hcCA9IGFycmF5TGFzdChzbmFwc0JvdW5kZWQpO1xuICAgIGNvbnN0IG1pbiA9IHNuYXBzQm91bmRlZC5sYXN0SW5kZXhPZihzdGFydFNuYXApO1xuICAgIGNvbnN0IG1heCA9IHNuYXBzQm91bmRlZC5pbmRleE9mKGVuZFNuYXApICsgMTtcbiAgICByZXR1cm4gTGltaXQobWluLCBtYXgpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVCb3VuZGVkKCkge1xuICAgIHJldHVybiBzbmFwc0FsaWduZWQubWFwKChzbmFwQWxpZ25lZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluLFxuICAgICAgICBtYXhcbiAgICAgIH0gPSBzY3JvbGxCb3VuZHM7XG4gICAgICBjb25zdCBzbmFwID0gc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihzbmFwQWxpZ25lZCk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChzbmFwc0FsaWduZWQsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gbWF4O1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIG1pbjtcbiAgICAgIGlmICh1c2VQaXhlbFRvbGVyYW5jZShtaW4sIHNuYXApKSByZXR1cm4gbWluO1xuICAgICAgaWYgKHVzZVBpeGVsVG9sZXJhbmNlKG1heCwgc25hcCkpIHJldHVybiBtYXg7XG4gICAgICByZXR1cm4gc25hcDtcbiAgICB9KS5tYXAoc2Nyb2xsQm91bmQgPT4gcGFyc2VGbG9hdChzY3JvbGxCb3VuZC50b0ZpeGVkKDMpKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUNvbnRhaW5lZCgpIHtcbiAgICBpZiAoY29udGVudFNpemUgPD0gdmlld1NpemUgKyBwaXhlbFRvbGVyYW5jZSkgcmV0dXJuIFtzY3JvbGxCb3VuZHMubWF4XTtcbiAgICBpZiAoY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcycpIHJldHVybiBzbmFwc0JvdW5kZWQ7XG4gICAgY29uc3Qge1xuICAgICAgbWluLFxuICAgICAgbWF4XG4gICAgfSA9IHNjcm9sbENvbnRhaW5MaW1pdDtcbiAgICByZXR1cm4gc25hcHNCb3VuZGVkLnNsaWNlKG1pbiwgbWF4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNuYXBzQ29udGFpbmVkLFxuICAgIHNjcm9sbENvbnRhaW5MaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTGltaXQoY29udGVudFNpemUsIHNjcm9sbFNuYXBzLCBsb29wKSB7XG4gIGNvbnN0IG1heCA9IHNjcm9sbFNuYXBzWzBdO1xuICBjb25zdCBtaW4gPSBsb29wID8gbWF4IC0gY29udGVudFNpemUgOiBhcnJheUxhc3Qoc2Nyb2xsU25hcHMpO1xuICBjb25zdCBsaW1pdCA9IExpbWl0KG1pbiwgbWF4KTtcbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTG9vcGVyKGNvbnRlbnRTaXplLCBsaW1pdCwgbG9jYXRpb24sIHZlY3RvcnMpIHtcbiAgY29uc3Qgam9pbnRTYWZldHkgPSAwLjE7XG4gIGNvbnN0IG1pbiA9IGxpbWl0Lm1pbiArIGpvaW50U2FmZXR5O1xuICBjb25zdCBtYXggPSBsaW1pdC5tYXggKyBqb2ludFNhZmV0eTtcbiAgY29uc3Qge1xuICAgIHJlYWNoZWRNaW4sXG4gICAgcmVhY2hlZE1heFxuICB9ID0gTGltaXQobWluLCBtYXgpO1xuICBmdW5jdGlvbiBzaG91bGRMb29wKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHJldHVybiByZWFjaGVkTWF4KGxvY2F0aW9uLmdldCgpKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkgcmV0dXJuIHJlYWNoZWRNaW4obG9jYXRpb24uZ2V0KCkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBsb29wKGRpcmVjdGlvbikge1xuICAgIGlmICghc2hvdWxkTG9vcChkaXJlY3Rpb24pKSByZXR1cm47XG4gICAgY29uc3QgbG9vcERpc3RhbmNlID0gY29udGVudFNpemUgKiAoZGlyZWN0aW9uICogLTEpO1xuICAgIHZlY3RvcnMuZm9yRWFjaCh2ID0+IHYuYWRkKGxvb3BEaXN0YW5jZSkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbG9vcFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpIHtcbiAgY29uc3Qge1xuICAgIG1heCxcbiAgICBsZW5ndGhcbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBnZXQobikge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IG4gLSBtYXg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IGN1cnJlbnRMb2NhdGlvbiAvIC1sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxTbmFwcyhheGlzLCBhbGlnbm1lbnQsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlc1RvU2Nyb2xsKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3Qge1xuICAgIGdyb3VwU2xpZGVzXG4gIH0gPSBzbGlkZXNUb1Njcm9sbDtcbiAgY29uc3QgYWxpZ25tZW50cyA9IG1lYXN1cmVTaXplcygpLm1hcChhbGlnbm1lbnQubWVhc3VyZSk7XG4gIGNvbnN0IHNuYXBzID0gbWVhc3VyZVVuYWxpZ25lZCgpO1xuICBjb25zdCBzbmFwc0FsaWduZWQgPSBtZWFzdXJlQWxpZ25lZCgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZXMoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNsaWRlUmVjdHMpLm1hcChyZWN0cyA9PiBhcnJheUxhc3QocmVjdHMpW2VuZEVkZ2VdIC0gcmVjdHNbMF1bc3RhcnRFZGdlXSkubWFwKG1hdGhBYnMpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVVbmFsaWduZWQoKSB7XG4gICAgcmV0dXJuIHNsaWRlUmVjdHMubWFwKHJlY3QgPT4gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gcmVjdFtzdGFydEVkZ2VdKS5tYXAoc25hcCA9PiAtbWF0aEFicyhzbmFwKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUFsaWduZWQoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNuYXBzKS5tYXAoZyA9PiBnWzBdKS5tYXAoKHNuYXAsIGluZGV4KSA9PiBzbmFwICsgYWxpZ25tZW50c1tpbmRleF0pO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc25hcHMsXG4gICAgc25hcHNBbGlnbmVkXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZVJlZ2lzdHJ5KGNvbnRhaW5TbmFwcywgY29udGFpblNjcm9sbCwgc2Nyb2xsU25hcHMsIHNjcm9sbENvbnRhaW5MaW1pdCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlSW5kZXhlcykge1xuICBjb25zdCB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfSA9IHNsaWRlc1RvU2Nyb2xsO1xuICBjb25zdCB7XG4gICAgbWluLFxuICAgIG1heFxuICB9ID0gc2Nyb2xsQ29udGFpbkxpbWl0O1xuICBjb25zdCBzbGlkZVJlZ2lzdHJ5ID0gY3JlYXRlU2xpZGVSZWdpc3RyeSgpO1xuICBmdW5jdGlvbiBjcmVhdGVTbGlkZVJlZ2lzdHJ5KCkge1xuICAgIGNvbnN0IGdyb3VwZWRTbGlkZUluZGV4ZXMgPSBncm91cFNsaWRlcyhzbGlkZUluZGV4ZXMpO1xuICAgIGNvbnN0IGRvTm90Q29udGFpbiA9ICFjb250YWluU25hcHMgfHwgY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcyc7XG4gICAgaWYgKHNjcm9sbFNuYXBzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIFtzbGlkZUluZGV4ZXNdO1xuICAgIGlmIChkb05vdENvbnRhaW4pIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzO1xuICAgIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzLnNsaWNlKG1pbiwgbWF4KS5tYXAoKGdyb3VwLCBpbmRleCwgZ3JvdXBzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChncm91cHMsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gYXJyYXlMYXN0KGdyb3Vwc1swXSkgKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhcnJheUxhc3RJbmRleChzbGlkZUluZGV4ZXMpIC0gYXJyYXlMYXN0KGdyb3VwcylbMF0gKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlLCBhcnJheUxhc3QoZ3JvdXBzKVswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbGlkZVJlZ2lzdHJ5XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUYXJnZXQobG9vcCwgc2Nyb2xsU25hcHMsIGNvbnRlbnRTaXplLCBsaW1pdCwgdGFyZ2V0VmVjdG9yKSB7XG4gIGNvbnN0IHtcbiAgICByZWFjaGVkQW55LFxuICAgIHJlbW92ZU9mZnNldCxcbiAgICBjb25zdHJhaW5cbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBtaW5EaXN0YW5jZShkaXN0YW5jZXMpIHtcbiAgICByZXR1cm4gZGlzdGFuY2VzLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IG1hdGhBYnMoYSkgLSBtYXRoQWJzKGIpKVswXTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGxvb3AgPyByZW1vdmVPZmZzZXQodGFyZ2V0KSA6IGNvbnN0cmFpbih0YXJnZXQpO1xuICAgIGNvbnN0IGFzY0RpZmZzVG9TbmFwcyA9IHNjcm9sbFNuYXBzLm1hcCgoc25hcCwgaW5kZXgpID0+ICh7XG4gICAgICBkaWZmOiBzaG9ydGN1dChzbmFwIC0gZGlzdGFuY2UsIDApLFxuICAgICAgaW5kZXhcbiAgICB9KSkuc29ydCgoZDEsIGQyKSA9PiBtYXRoQWJzKGQxLmRpZmYpIC0gbWF0aEFicyhkMi5kaWZmKSk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXhcbiAgICB9ID0gYXNjRGlmZnNUb1NuYXBzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzaG9ydGN1dCh0YXJnZXQsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldHMgPSBbdGFyZ2V0LCB0YXJnZXQgKyBjb250ZW50U2l6ZSwgdGFyZ2V0IC0gY29udGVudFNpemVdO1xuICAgIGlmICghbG9vcCkgcmV0dXJuIHRhcmdldDtcbiAgICBpZiAoIWRpcmVjdGlvbikgcmV0dXJuIG1pbkRpc3RhbmNlKHRhcmdldHMpO1xuICAgIGNvbnN0IG1hdGNoaW5nVGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKHQgPT4gbWF0aFNpZ24odCkgPT09IGRpcmVjdGlvbik7XG4gICAgaWYgKG1hdGNoaW5nVGFyZ2V0cy5sZW5ndGgpIHJldHVybiBtaW5EaXN0YW5jZShtYXRjaGluZ1RhcmdldHMpO1xuICAgIHJldHVybiBhcnJheUxhc3QodGFyZ2V0cykgLSBjb250ZW50U2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBieUluZGV4KGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBkaWZmVG9TbmFwID0gc2Nyb2xsU25hcHNbaW5kZXhdIC0gdGFyZ2V0VmVjdG9yLmdldCgpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gc2hvcnRjdXQoZGlmZlRvU25hcCwgZGlyZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnlEaXN0YW5jZShkaXN0YW5jZSwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFZlY3Rvci5nZXQoKSArIGRpc3RhbmNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2U6IHRhcmdldFNuYXBEaXN0YW5jZVxuICAgIH0gPSBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpO1xuICAgIGNvbnN0IHJlYWNoZWRCb3VuZCA9ICFsb29wICYmIHJlYWNoZWRBbnkodGFyZ2V0KTtcbiAgICBpZiAoIXNuYXAgfHwgcmVhY2hlZEJvdW5kKSByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gICAgY29uc3QgZGlmZlRvU25hcCA9IHNjcm9sbFNuYXBzW2luZGV4XSAtIHRhcmdldFNuYXBEaXN0YW5jZTtcbiAgICBjb25zdCBzbmFwRGlzdGFuY2UgPSBkaXN0YW5jZSArIHNob3J0Y3V0KGRpZmZUb1NuYXAsIDApO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlOiBzbmFwRGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYnlEaXN0YW5jZSxcbiAgICBieUluZGV4LFxuICAgIHNob3J0Y3V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUbyhhbmltYXRpb24sIGluZGV4Q3VycmVudCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXRWZWN0b3IsIGV2ZW50SGFuZGxlcikge1xuICBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZURpZmYgPSB0YXJnZXQuZGlzdGFuY2U7XG4gICAgY29uc3QgaW5kZXhEaWZmID0gdGFyZ2V0LmluZGV4ICE9PSBpbmRleEN1cnJlbnQuZ2V0KCk7XG4gICAgdGFyZ2V0VmVjdG9yLmFkZChkaXN0YW5jZURpZmYpO1xuICAgIGlmIChkaXN0YW5jZURpZmYpIHtcbiAgICAgIGlmIChzY3JvbGxCb2R5LmR1cmF0aW9uKCkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb24udXBkYXRlKCk7XG4gICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoMSk7XG4gICAgICAgIGFuaW1hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4RGlmZikge1xuICAgICAgaW5kZXhQcmV2aW91cy5zZXQoaW5kZXhDdXJyZW50LmdldCgpKTtcbiAgICAgIGluZGV4Q3VycmVudC5zZXQodGFyZ2V0LmluZGV4KTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzZWxlY3QnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGlzdGFuY2Uobiwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKG4sIHNuYXApO1xuICAgIHNjcm9sbFRvKHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5kZXgobiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpbmRleEN1cnJlbnQuY2xvbmUoKS5zZXQobik7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgodGFyZ2V0SW5kZXguZ2V0KCksIGRpcmVjdGlvbik7XG4gICAgc2Nyb2xsVG8odGFyZ2V0KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGRpc3RhbmNlLFxuICAgIGluZGV4XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZUZvY3VzKHJvb3QsIHNsaWRlcywgc2xpZGVSZWdpc3RyeSwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIGV2ZW50U3RvcmUsIGV2ZW50SGFuZGxlciwgd2F0Y2hGb2N1cykge1xuICBjb25zdCBmb2N1c0xpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICBwYXNzaXZlOiB0cnVlLFxuICAgIGNhcHR1cmU6IHRydWVcbiAgfTtcbiAgbGV0IGxhc3RUYWJQcmVzc1RpbWUgPSAwO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaEZvY3VzKSByZXR1cm47XG4gICAgZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKGluZGV4KSB7XG4gICAgICBjb25zdCBub3dUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBkaWZmVGltZSA9IG5vd1RpbWUgLSBsYXN0VGFiUHJlc3NUaW1lO1xuICAgICAgaWYgKGRpZmZUaW1lID4gMTApIHJldHVybjtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZUZvY3VzU3RhcnQnKTtcbiAgICAgIHJvb3Quc2Nyb2xsTGVmdCA9IDA7XG4gICAgICBjb25zdCBncm91cCA9IHNsaWRlUmVnaXN0cnkuZmluZEluZGV4KGdyb3VwID0+IGdyb3VwLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICBpZiAoIWlzTnVtYmVyKGdyb3VwKSkgcmV0dXJuO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigwKTtcbiAgICAgIHNjcm9sbFRvLmluZGV4KGdyb3VwLCAwKTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZUZvY3VzJyk7XG4gICAgfVxuICAgIGV2ZW50U3RvcmUuYWRkKGRvY3VtZW50LCAna2V5ZG93bicsIHJlZ2lzdGVyVGFiUHJlc3MsIGZhbHNlKTtcbiAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGV2ZW50U3RvcmUuYWRkKHNsaWRlLCAnZm9jdXMnLCBldnQgPT4ge1xuICAgICAgICBpZiAoaXNCb29sZWFuKHdhdGNoRm9jdXMpIHx8IHdhdGNoRm9jdXMoZW1ibGFBcGksIGV2dCkpIHtcbiAgICAgICAgICBkZWZhdWx0Q2FsbGJhY2soc2xpZGVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZvY3VzTGlzdGVuZXJPcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlclRhYlByZXNzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNvZGUgPT09ICdUYWInKSBsYXN0VGFiUHJlc3NUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBWZWN0b3IxRChpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgdmFsdWUgPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHZhbHVlICs9IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnRyYWN0KG4pIHtcbiAgICB2YWx1ZSAtPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVJbnB1dChuKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG4pID8gbiA6IG4uZ2V0KCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBzdWJ0cmFjdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gVHJhbnNsYXRlKGF4aXMsIGNvbnRhaW5lcikge1xuICBjb25zdCB0cmFuc2xhdGUgPSBheGlzLnNjcm9sbCA9PT0gJ3gnID8geCA6IHk7XG4gIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICBsZXQgcHJldmlvdXNUYXJnZXQgPSBudWxsO1xuICBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24geChuKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUzZCgke259cHgsMHB4LDBweClgO1xuICB9XG4gIGZ1bmN0aW9uIHkobikge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoMHB4LCR7bn1weCwwcHgpYDtcbiAgfVxuICBmdW5jdGlvbiB0byh0YXJnZXQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCBuZXdUYXJnZXQgPSByb3VuZFRvVHdvRGVjaW1hbHMoYXhpcy5kaXJlY3Rpb24odGFyZ2V0KSk7XG4gICAgaWYgKG5ld1RhcmdldCA9PT0gcHJldmlvdXNUYXJnZXQpIHJldHVybjtcbiAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGUobmV3VGFyZ2V0KTtcbiAgICBwcmV2aW91c1RhcmdldCA9IG5ld1RhcmdldDtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVBY3RpdmUoYWN0aXZlKSB7XG4gICAgZGlzYWJsZWQgPSAhYWN0aXZlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgIGlmICghY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNsZWFyLFxuICAgIHRvLFxuICAgIHRvZ2dsZUFjdGl2ZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVMb29wZXIoYXhpcywgdmlld1NpemUsIGNvbnRlbnRTaXplLCBzbGlkZVNpemVzLCBzbGlkZVNpemVzV2l0aEdhcHMsIHNuYXBzLCBzY3JvbGxTbmFwcywgbG9jYXRpb24sIHNsaWRlcykge1xuICBjb25zdCByb3VuZGluZ1NhZmV0eSA9IDAuNTtcbiAgY29uc3QgYXNjSXRlbXMgPSBhcnJheUtleXMoc2xpZGVTaXplc1dpdGhHYXBzKTtcbiAgY29uc3QgZGVzY0l0ZW1zID0gYXJyYXlLZXlzKHNsaWRlU2l6ZXNXaXRoR2FwcykucmV2ZXJzZSgpO1xuICBjb25zdCBsb29wUG9pbnRzID0gc3RhcnRQb2ludHMoKS5jb25jYXQoZW5kUG9pbnRzKCkpO1xuICBmdW5jdGlvbiByZW1vdmVTbGlkZVNpemVzKGluZGV4ZXMsIGZyb20pIHtcbiAgICByZXR1cm4gaW5kZXhlcy5yZWR1Y2UoKGEsIGkpID0+IHtcbiAgICAgIHJldHVybiBhIC0gc2xpZGVTaXplc1dpdGhHYXBzW2ldO1xuICAgIH0sIGZyb20pO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc0luR2FwKGluZGV4ZXMsIGdhcCkge1xuICAgIHJldHVybiBpbmRleGVzLnJlZHVjZSgoYSwgaSkgPT4ge1xuICAgICAgY29uc3QgcmVtYWluaW5nR2FwID0gcmVtb3ZlU2xpZGVTaXplcyhhLCBnYXApO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZ0dhcCA+IDAgPyBhLmNvbmNhdChbaV0pIDogYTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNsaWRlQm91bmRzKG9mZnNldCkge1xuICAgIHJldHVybiBzbmFwcy5tYXAoKHNuYXAsIGluZGV4KSA9PiAoe1xuICAgICAgc3RhcnQ6IHNuYXAgLSBzbGlkZVNpemVzW2luZGV4XSArIHJvdW5kaW5nU2FmZXR5ICsgb2Zmc2V0LFxuICAgICAgZW5kOiBzbmFwICsgdmlld1NpemUgLSByb3VuZGluZ1NhZmV0eSArIG9mZnNldFxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCBvZmZzZXQsIGlzRW5kRWRnZSkge1xuICAgIGNvbnN0IHNsaWRlQm91bmRzID0gZmluZFNsaWRlQm91bmRzKG9mZnNldCk7XG4gICAgcmV0dXJuIGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWwgPSBpc0VuZEVkZ2UgPyAwIDogLWNvbnRlbnRTaXplO1xuICAgICAgY29uc3QgYWx0ZXJlZCA9IGlzRW5kRWRnZSA/IGNvbnRlbnRTaXplIDogMDtcbiAgICAgIGNvbnN0IGJvdW5kRWRnZSA9IGlzRW5kRWRnZSA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgIGNvbnN0IGxvb3BQb2ludCA9IHNsaWRlQm91bmRzW2luZGV4XVtib3VuZEVkZ2VdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxvb3BQb2ludCxcbiAgICAgICAgc2xpZGVMb2NhdGlvbjogVmVjdG9yMUQoLTEpLFxuICAgICAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZShheGlzLCBzbGlkZXNbaW5kZXhdKSxcbiAgICAgICAgdGFyZ2V0OiAoKSA9PiBsb2NhdGlvbi5nZXQoKSA+IGxvb3BQb2ludCA/IGluaXRpYWwgOiBhbHRlcmVkXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0UG9pbnRzKCkge1xuICAgIGNvbnN0IGdhcCA9IHNjcm9sbFNuYXBzWzBdO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBzbGlkZXNJbkdhcChkZXNjSXRlbXMsIGdhcCk7XG4gICAgcmV0dXJuIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIGNvbnRlbnRTaXplLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gZW5kUG9pbnRzKCkge1xuICAgIGNvbnN0IGdhcCA9IHZpZXdTaXplIC0gc2Nyb2xsU25hcHNbMF0gLSAxO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBzbGlkZXNJbkdhcChhc2NJdGVtcywgZ2FwKTtcbiAgICByZXR1cm4gZmluZExvb3BQb2ludHMoaW5kZXhlcywgLWNvbnRlbnRTaXplLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5Mb29wKCkge1xuICAgIHJldHVybiBsb29wUG9pbnRzLmV2ZXJ5KCh7XG4gICAgICBpbmRleFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG90aGVySW5kZXhlcyA9IGFzY0l0ZW1zLmZpbHRlcihpID0+IGkgIT09IGluZGV4KTtcbiAgICAgIHJldHVybiByZW1vdmVTbGlkZVNpemVzKG90aGVySW5kZXhlcywgdmlld1NpemUpIDw9IDAuMTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBsb29wKCkge1xuICAgIGxvb3BQb2ludHMuZm9yRWFjaChsb29wUG9pbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgc2xpZGVMb2NhdGlvblxuICAgICAgfSA9IGxvb3BQb2ludDtcbiAgICAgIGNvbnN0IHNoaWZ0TG9jYXRpb24gPSB0YXJnZXQoKTtcbiAgICAgIGlmIChzaGlmdExvY2F0aW9uID09PSBzbGlkZUxvY2F0aW9uLmdldCgpKSByZXR1cm47XG4gICAgICB0cmFuc2xhdGUudG8oc2hpZnRMb2NhdGlvbik7XG4gICAgICBzbGlkZUxvY2F0aW9uLnNldChzaGlmdExvY2F0aW9uKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBsb29wUG9pbnRzLmZvckVhY2gobG9vcFBvaW50ID0+IGxvb3BQb2ludC50cmFuc2xhdGUuY2xlYXIoKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjYW5Mb29wLFxuICAgIGNsZWFyLFxuICAgIGxvb3AsXG4gICAgbG9vcFBvaW50c1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgd2F0Y2hTbGlkZXMpIHtcbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSkge1xuICAgIGlmICghd2F0Y2hTbGlkZXMpIHJldHVybjtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2sobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICBlbWJsYUFwaS5yZUluaXQoKTtcbiAgICAgICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2xpZGVzQ2hhbmdlZCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaFNsaWRlcykgfHwgd2F0Y2hTbGlkZXMoZW1ibGFBcGksIG11dGF0aW9ucykpIHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKG11dGF0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lciwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAobXV0YXRpb25PYnNlcnZlcikgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzSW5WaWV3KGNvbnRhaW5lciwgc2xpZGVzLCBldmVudEhhbmRsZXIsIHRocmVzaG9sZCkge1xuICBjb25zdCBpbnRlcnNlY3Rpb25FbnRyeU1hcCA9IHt9O1xuICBsZXQgaW5WaWV3Q2FjaGUgPSBudWxsO1xuICBsZXQgbm90SW5WaWV3Q2FjaGUgPSBudWxsO1xuICBsZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2xpZGVzLmluZGV4T2YoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgaW50ZXJzZWN0aW9uRW50cnlNYXBbaW5kZXhdID0gZW50cnk7XG4gICAgICB9KTtcbiAgICAgIGluVmlld0NhY2hlID0gbnVsbDtcbiAgICAgIG5vdEluVmlld0NhY2hlID0gbnVsbDtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZXNJblZpZXcnKTtcbiAgICB9LCB7XG4gICAgICByb290OiBjb250YWluZXIucGFyZW50RWxlbWVudCxcbiAgICAgIHRocmVzaG9sZFxuICAgIH0pO1xuICAgIHNsaWRlcy5mb3JFYWNoKHNsaWRlID0+IGludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoc2xpZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChpbnRlcnNlY3Rpb25PYnNlcnZlcikgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW5WaWV3TGlzdChpblZpZXcpIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhpbnRlcnNlY3Rpb25FbnRyeU1hcCkucmVkdWNlKChsaXN0LCBzbGlkZUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHNsaWRlSW5kZXgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0ludGVyc2VjdGluZ1xuICAgICAgfSA9IGludGVyc2VjdGlvbkVudHJ5TWFwW2luZGV4XTtcbiAgICAgIGNvbnN0IGluVmlld01hdGNoID0gaW5WaWV3ICYmIGlzSW50ZXJzZWN0aW5nO1xuICAgICAgY29uc3Qgbm90SW5WaWV3TWF0Y2ggPSAhaW5WaWV3ICYmICFpc0ludGVyc2VjdGluZztcbiAgICAgIGlmIChpblZpZXdNYXRjaCB8fCBub3RJblZpZXdNYXRjaCkgbGlzdC5wdXNoKGluZGV4KTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoaW5WaWV3ID0gdHJ1ZSkge1xuICAgIGlmIChpblZpZXcgJiYgaW5WaWV3Q2FjaGUpIHJldHVybiBpblZpZXdDYWNoZTtcbiAgICBpZiAoIWluVmlldyAmJiBub3RJblZpZXdDYWNoZSkgcmV0dXJuIG5vdEluVmlld0NhY2hlO1xuICAgIGNvbnN0IHNsaWRlSW5kZXhlcyA9IGNyZWF0ZUluVmlld0xpc3QoaW5WaWV3KTtcbiAgICBpZiAoaW5WaWV3KSBpblZpZXdDYWNoZSA9IHNsaWRlSW5kZXhlcztcbiAgICBpZiAoIWluVmlldykgbm90SW5WaWV3Q2FjaGUgPSBzbGlkZUluZGV4ZXM7XG4gICAgcmV0dXJuIHNsaWRlSW5kZXhlcztcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveSxcbiAgICBnZXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlU2l6ZXMoYXhpcywgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzLCByZWFkRWRnZUdhcCwgb3duZXJXaW5kb3cpIHtcbiAgY29uc3Qge1xuICAgIG1lYXN1cmVTaXplLFxuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlXG4gIH0gPSBheGlzO1xuICBjb25zdCB3aXRoRWRnZUdhcCA9IHNsaWRlUmVjdHNbMF0gJiYgcmVhZEVkZ2VHYXA7XG4gIGNvbnN0IHN0YXJ0R2FwID0gbWVhc3VyZVN0YXJ0R2FwKCk7XG4gIGNvbnN0IGVuZEdhcCA9IG1lYXN1cmVFbmRHYXAoKTtcbiAgY29uc3Qgc2xpZGVTaXplcyA9IHNsaWRlUmVjdHMubWFwKG1lYXN1cmVTaXplKTtcbiAgY29uc3Qgc2xpZGVTaXplc1dpdGhHYXBzID0gbWVhc3VyZVdpdGhHYXBzKCk7XG4gIGZ1bmN0aW9uIG1lYXN1cmVTdGFydEdhcCgpIHtcbiAgICBpZiAoIXdpdGhFZGdlR2FwKSByZXR1cm4gMDtcbiAgICBjb25zdCBzbGlkZVJlY3QgPSBzbGlkZVJlY3RzWzBdO1xuICAgIHJldHVybiBtYXRoQWJzKGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdFtzdGFydEVkZ2VdKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlRW5kR2FwKCkge1xuICAgIGlmICghd2l0aEVkZ2VHYXApIHJldHVybiAwO1xuICAgIGNvbnN0IHN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhcnJheUxhc3Qoc2xpZGVzKSk7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShgbWFyZ2luLSR7ZW5kRWRnZX1gKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZVdpdGhHYXBzKCkge1xuICAgIHJldHVybiBzbGlkZVJlY3RzLm1hcCgocmVjdCwgaW5kZXgsIHJlY3RzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChyZWN0cywgaW5kZXgpO1xuICAgICAgaWYgKGlzRmlyc3QpIHJldHVybiBzbGlkZVNpemVzW2luZGV4XSArIHN0YXJ0R2FwO1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIHNsaWRlU2l6ZXNbaW5kZXhdICsgZW5kR2FwO1xuICAgICAgcmV0dXJuIHJlY3RzW2luZGV4ICsgMV1bc3RhcnRFZGdlXSAtIHJlY3Rbc3RhcnRFZGdlXTtcbiAgICB9KS5tYXAobWF0aEFicyk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbGlkZVNpemVzLFxuICAgIHNsaWRlU2l6ZXNXaXRoR2FwcyxcbiAgICBzdGFydEdhcCxcbiAgICBlbmRHYXBcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc1RvU2Nyb2xsKGF4aXMsIHZpZXdTaXplLCBzbGlkZXNUb1Njcm9sbCwgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCwgcGl4ZWxUb2xlcmFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlLFxuICAgIGRpcmVjdGlvblxuICB9ID0gYXhpcztcbiAgY29uc3QgZ3JvdXBCeU51bWJlciA9IGlzTnVtYmVyKHNsaWRlc1RvU2Nyb2xsKTtcbiAgZnVuY3Rpb24gYnlOdW1iZXIoYXJyYXksIGdyb3VwU2l6ZSkge1xuICAgIHJldHVybiBhcnJheUtleXMoYXJyYXkpLmZpbHRlcihpID0+IGkgJSBncm91cFNpemUgPT09IDApLm1hcChpID0+IGFycmF5LnNsaWNlKGksIGkgKyBncm91cFNpemUpKTtcbiAgfVxuICBmdW5jdGlvbiBieVNpemUoYXJyYXkpIHtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnJheUtleXMoYXJyYXkpLnJlZHVjZSgoZ3JvdXBzLCByZWN0QiwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJlY3RBID0gYXJyYXlMYXN0KGdyb3VwcykgfHwgMDtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSByZWN0QSA9PT0gMDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IHJlY3RCID09PSBhcnJheUxhc3RJbmRleChhcnJheSk7XG4gICAgICBjb25zdCBlZGdlQSA9IGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdHNbcmVjdEFdW3N0YXJ0RWRnZV07XG4gICAgICBjb25zdCBlZGdlQiA9IGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdHNbcmVjdEJdW2VuZEVkZ2VdO1xuICAgICAgY29uc3QgZ2FwQSA9ICFsb29wICYmIGlzRmlyc3QgPyBkaXJlY3Rpb24oc3RhcnRHYXApIDogMDtcbiAgICAgIGNvbnN0IGdhcEIgPSAhbG9vcCAmJiBpc0xhc3QgPyBkaXJlY3Rpb24oZW5kR2FwKSA6IDA7XG4gICAgICBjb25zdCBjaHVua1NpemUgPSBtYXRoQWJzKGVkZ2VCIC0gZ2FwQiAtIChlZGdlQSArIGdhcEEpKTtcbiAgICAgIGlmIChpbmRleCAmJiBjaHVua1NpemUgPiB2aWV3U2l6ZSArIHBpeGVsVG9sZXJhbmNlKSBncm91cHMucHVzaChyZWN0Qik7XG4gICAgICBpZiAoaXNMYXN0KSBncm91cHMucHVzaChhcnJheS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LCBbXSkubWFwKChjdXJyZW50U2l6ZSwgaW5kZXgsIGdyb3VwcykgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNTaXplID0gTWF0aC5tYXgoZ3JvdXBzW2luZGV4IC0gMV0gfHwgMCk7XG4gICAgICByZXR1cm4gYXJyYXkuc2xpY2UocHJldmlvdXNTaXplLCBjdXJyZW50U2l6ZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ3JvdXBTbGlkZXMoYXJyYXkpIHtcbiAgICByZXR1cm4gZ3JvdXBCeU51bWJlciA/IGJ5TnVtYmVyKGFycmF5LCBzbGlkZXNUb1Njcm9sbCkgOiBieVNpemUoYXJyYXkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEVuZ2luZShyb290LCBjb250YWluZXIsIHNsaWRlcywgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIG9wdGlvbnMsIGV2ZW50SGFuZGxlcikge1xuICAvLyBPcHRpb25zXG4gIGNvbnN0IHtcbiAgICBhbGlnbixcbiAgICBheGlzOiBzY3JvbGxBeGlzLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGFydEluZGV4LFxuICAgIGxvb3AsXG4gICAgZHVyYXRpb24sXG4gICAgZHJhZ0ZyZWUsXG4gICAgZHJhZ1RocmVzaG9sZCxcbiAgICBpblZpZXdUaHJlc2hvbGQsXG4gICAgc2xpZGVzVG9TY3JvbGw6IGdyb3VwU2xpZGVzLFxuICAgIHNraXBTbmFwcyxcbiAgICBjb250YWluU2Nyb2xsLFxuICAgIHdhdGNoUmVzaXplLFxuICAgIHdhdGNoU2xpZGVzLFxuICAgIHdhdGNoRHJhZyxcbiAgICB3YXRjaEZvY3VzXG4gIH0gPSBvcHRpb25zO1xuICAvLyBNZWFzdXJlbWVudHNcbiAgY29uc3QgcGl4ZWxUb2xlcmFuY2UgPSAyO1xuICBjb25zdCBub2RlUmVjdHMgPSBOb2RlUmVjdHMoKTtcbiAgY29uc3QgY29udGFpbmVyUmVjdCA9IG5vZGVSZWN0cy5tZWFzdXJlKGNvbnRhaW5lcik7XG4gIGNvbnN0IHNsaWRlUmVjdHMgPSBzbGlkZXMubWFwKG5vZGVSZWN0cy5tZWFzdXJlKTtcbiAgY29uc3QgYXhpcyA9IEF4aXMoc2Nyb2xsQXhpcywgZGlyZWN0aW9uKTtcbiAgY29uc3Qgdmlld1NpemUgPSBheGlzLm1lYXN1cmVTaXplKGNvbnRhaW5lclJlY3QpO1xuICBjb25zdCBwZXJjZW50T2ZWaWV3ID0gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSk7XG4gIGNvbnN0IGFsaWdubWVudCA9IEFsaWdubWVudChhbGlnbiwgdmlld1NpemUpO1xuICBjb25zdCBjb250YWluU25hcHMgPSAhbG9vcCAmJiAhIWNvbnRhaW5TY3JvbGw7XG4gIGNvbnN0IHJlYWRFZGdlR2FwID0gbG9vcCB8fCAhIWNvbnRhaW5TY3JvbGw7XG4gIGNvbnN0IHtcbiAgICBzbGlkZVNpemVzLFxuICAgIHNsaWRlU2l6ZXNXaXRoR2FwcyxcbiAgICBzdGFydEdhcCxcbiAgICBlbmRHYXBcbiAgfSA9IFNsaWRlU2l6ZXMoYXhpcywgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzLCByZWFkRWRnZUdhcCwgb3duZXJXaW5kb3cpO1xuICBjb25zdCBzbGlkZXNUb1Njcm9sbCA9IFNsaWRlc1RvU2Nyb2xsKGF4aXMsIHZpZXdTaXplLCBncm91cFNsaWRlcywgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCwgcGl4ZWxUb2xlcmFuY2UpO1xuICBjb25zdCB7XG4gICAgc25hcHMsXG4gICAgc25hcHNBbGlnbmVkXG4gIH0gPSBTY3JvbGxTbmFwcyhheGlzLCBhbGlnbm1lbnQsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlc1RvU2Nyb2xsKTtcbiAgY29uc3QgY29udGVudFNpemUgPSAtYXJyYXlMYXN0KHNuYXBzKSArIGFycmF5TGFzdChzbGlkZVNpemVzV2l0aEdhcHMpO1xuICBjb25zdCB7XG4gICAgc25hcHNDb250YWluZWQsXG4gICAgc2Nyb2xsQ29udGFpbkxpbWl0XG4gIH0gPSBTY3JvbGxDb250YWluKHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc25hcHNBbGlnbmVkLCBjb250YWluU2Nyb2xsLCBwaXhlbFRvbGVyYW5jZSk7XG4gIGNvbnN0IHNjcm9sbFNuYXBzID0gY29udGFpblNuYXBzID8gc25hcHNDb250YWluZWQgOiBzbmFwc0FsaWduZWQ7XG4gIGNvbnN0IHtcbiAgICBsaW1pdFxuICB9ID0gU2Nyb2xsTGltaXQoY29udGVudFNpemUsIHNjcm9sbFNuYXBzLCBsb29wKTtcbiAgLy8gSW5kZXhlc1xuICBjb25zdCBpbmRleCA9IENvdW50ZXIoYXJyYXlMYXN0SW5kZXgoc2Nyb2xsU25hcHMpLCBzdGFydEluZGV4LCBsb29wKTtcbiAgY29uc3QgaW5kZXhQcmV2aW91cyA9IGluZGV4LmNsb25lKCk7XG4gIGNvbnN0IHNsaWRlSW5kZXhlcyA9IGFycmF5S2V5cyhzbGlkZXMpO1xuICAvLyBBbmltYXRpb25cbiAgY29uc3QgdXBkYXRlID0gKHtcbiAgICBkcmFnSGFuZGxlcixcbiAgICBzY3JvbGxCb2R5LFxuICAgIHNjcm9sbEJvdW5kcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBsb29wXG4gICAgfVxuICB9KSA9PiB7XG4gICAgaWYgKCFsb29wKSBzY3JvbGxCb3VuZHMuY29uc3RyYWluKGRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpO1xuICAgIHNjcm9sbEJvZHkuc2VlaygpO1xuICB9O1xuICBjb25zdCByZW5kZXIgPSAoe1xuICAgIHNjcm9sbEJvZHksXG4gICAgdHJhbnNsYXRlLFxuICAgIGxvY2F0aW9uLFxuICAgIG9mZnNldExvY2F0aW9uLFxuICAgIHByZXZpb3VzTG9jYXRpb24sXG4gICAgc2Nyb2xsTG9vcGVyLFxuICAgIHNsaWRlTG9vcGVyLFxuICAgIGRyYWdIYW5kbGVyLFxuICAgIGFuaW1hdGlvbixcbiAgICBldmVudEhhbmRsZXIsXG4gICAgc2Nyb2xsQm91bmRzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGxvb3BcbiAgICB9XG4gIH0sIGFscGhhKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkU2V0dGxlID0gc2Nyb2xsQm9keS5zZXR0bGVkKCk7XG4gICAgY29uc3Qgd2l0aGluQm91bmRzID0gIXNjcm9sbEJvdW5kcy5zaG91bGRDb25zdHJhaW4oKTtcbiAgICBjb25zdCBoYXNTZXR0bGVkID0gbG9vcCA/IHNob3VsZFNldHRsZSA6IHNob3VsZFNldHRsZSAmJiB3aXRoaW5Cb3VuZHM7XG4gICAgY29uc3QgaGFzU2V0dGxlZEFuZElkbGUgPSBoYXNTZXR0bGVkICYmICFkcmFnSGFuZGxlci5wb2ludGVyRG93bigpO1xuICAgIGlmIChoYXNTZXR0bGVkQW5kSWRsZSkgYW5pbWF0aW9uLnN0b3AoKTtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWRMb2NhdGlvbiA9IGxvY2F0aW9uLmdldCgpICogYWxwaGEgKyBwcmV2aW91c0xvY2F0aW9uLmdldCgpICogKDEgLSBhbHBoYSk7XG4gICAgb2Zmc2V0TG9jYXRpb24uc2V0KGludGVycG9sYXRlZExvY2F0aW9uKTtcbiAgICBpZiAobG9vcCkge1xuICAgICAgc2Nyb2xsTG9vcGVyLmxvb3Aoc2Nyb2xsQm9keS5kaXJlY3Rpb24oKSk7XG4gICAgICBzbGlkZUxvb3Blci5sb29wKCk7XG4gICAgfVxuICAgIHRyYW5zbGF0ZS50byhvZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gICAgaWYgKGhhc1NldHRsZWRBbmRJZGxlKSBldmVudEhhbmRsZXIuZW1pdCgnc2V0dGxlJyk7XG4gICAgaWYgKCFoYXNTZXR0bGVkKSBldmVudEhhbmRsZXIuZW1pdCgnc2Nyb2xsJyk7XG4gIH07XG4gIGNvbnN0IGFuaW1hdGlvbiA9IEFuaW1hdGlvbnMob3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csICgpID0+IHVwZGF0ZShlbmdpbmUpLCBhbHBoYSA9PiByZW5kZXIoZW5naW5lLCBhbHBoYSkpO1xuICAvLyBTaGFyZWRcbiAgY29uc3QgZnJpY3Rpb24gPSAwLjY4O1xuICBjb25zdCBzdGFydExvY2F0aW9uID0gc2Nyb2xsU25hcHNbaW5kZXguZ2V0KCldO1xuICBjb25zdCBsb2NhdGlvbiA9IFZlY3RvcjFEKHN0YXJ0TG9jYXRpb24pO1xuICBjb25zdCBwcmV2aW91c0xvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IG9mZnNldExvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHRhcmdldCA9IFZlY3RvcjFEKHN0YXJ0TG9jYXRpb24pO1xuICBjb25zdCBzY3JvbGxCb2R5ID0gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHByZXZpb3VzTG9jYXRpb24sIHRhcmdldCwgZHVyYXRpb24sIGZyaWN0aW9uKTtcbiAgY29uc3Qgc2Nyb2xsVGFyZ2V0ID0gU2Nyb2xsVGFyZ2V0KGxvb3AsIHNjcm9sbFNuYXBzLCBjb250ZW50U2l6ZSwgbGltaXQsIHRhcmdldCk7XG4gIGNvbnN0IHNjcm9sbFRvID0gU2Nyb2xsVG8oYW5pbWF0aW9uLCBpbmRleCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXQsIGV2ZW50SGFuZGxlcik7XG4gIGNvbnN0IHNjcm9sbFByb2dyZXNzID0gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpO1xuICBjb25zdCBldmVudFN0b3JlID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCBzbGlkZXNJblZpZXcgPSBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgaW5WaWV3VGhyZXNob2xkKTtcbiAgY29uc3Qge1xuICAgIHNsaWRlUmVnaXN0cnlcbiAgfSA9IFNsaWRlUmVnaXN0cnkoY29udGFpblNuYXBzLCBjb250YWluU2Nyb2xsLCBzY3JvbGxTbmFwcywgc2Nyb2xsQ29udGFpbkxpbWl0LCBzbGlkZXNUb1Njcm9sbCwgc2xpZGVJbmRleGVzKTtcbiAgY29uc3Qgc2xpZGVGb2N1cyA9IFNsaWRlRm9jdXMocm9vdCwgc2xpZGVzLCBzbGlkZVJlZ2lzdHJ5LCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgZXZlbnRTdG9yZSwgZXZlbnRIYW5kbGVyLCB3YXRjaEZvY3VzKTtcbiAgLy8gRW5naW5lXG4gIGNvbnN0IGVuZ2luZSA9IHtcbiAgICBvd25lckRvY3VtZW50LFxuICAgIG93bmVyV2luZG93LFxuICAgIGV2ZW50SGFuZGxlcixcbiAgICBjb250YWluZXJSZWN0LFxuICAgIHNsaWRlUmVjdHMsXG4gICAgYW5pbWF0aW9uLFxuICAgIGF4aXMsXG4gICAgZHJhZ0hhbmRsZXI6IERyYWdIYW5kbGVyKGF4aXMsIHJvb3QsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB0YXJnZXQsIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSwgbG9jYXRpb24sIGFuaW1hdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIHNjcm9sbFRhcmdldCwgaW5kZXgsIGV2ZW50SGFuZGxlciwgcGVyY2VudE9mVmlldywgZHJhZ0ZyZWUsIGRyYWdUaHJlc2hvbGQsIHNraXBTbmFwcywgZnJpY3Rpb24sIHdhdGNoRHJhZyksXG4gICAgZXZlbnRTdG9yZSxcbiAgICBwZXJjZW50T2ZWaWV3LFxuICAgIGluZGV4LFxuICAgIGluZGV4UHJldmlvdXMsXG4gICAgbGltaXQsXG4gICAgbG9jYXRpb24sXG4gICAgb2Zmc2V0TG9jYXRpb24sXG4gICAgcHJldmlvdXNMb2NhdGlvbixcbiAgICBvcHRpb25zLFxuICAgIHJlc2l6ZUhhbmRsZXI6IFJlc2l6ZUhhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIG93bmVyV2luZG93LCBzbGlkZXMsIGF4aXMsIHdhdGNoUmVzaXplLCBub2RlUmVjdHMpLFxuICAgIHNjcm9sbEJvZHksXG4gICAgc2Nyb2xsQm91bmRzOiBTY3JvbGxCb3VuZHMobGltaXQsIG9mZnNldExvY2F0aW9uLCB0YXJnZXQsIHNjcm9sbEJvZHksIHBlcmNlbnRPZlZpZXcpLFxuICAgIHNjcm9sbExvb3BlcjogU2Nyb2xsTG9vcGVyKGNvbnRlbnRTaXplLCBsaW1pdCwgb2Zmc2V0TG9jYXRpb24sIFtsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHByZXZpb3VzTG9jYXRpb24sIHRhcmdldF0pLFxuICAgIHNjcm9sbFByb2dyZXNzLFxuICAgIHNjcm9sbFNuYXBMaXN0OiBzY3JvbGxTbmFwcy5tYXAoc2Nyb2xsUHJvZ3Jlc3MuZ2V0KSxcbiAgICBzY3JvbGxTbmFwcyxcbiAgICBzY3JvbGxUYXJnZXQsXG4gICAgc2Nyb2xsVG8sXG4gICAgc2xpZGVMb29wZXI6IFNsaWRlTG9vcGVyKGF4aXMsIHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc2xpZGVTaXplcywgc2xpZGVTaXplc1dpdGhHYXBzLCBzbmFwcywgc2Nyb2xsU25hcHMsIG9mZnNldExvY2F0aW9uLCBzbGlkZXMpLFxuICAgIHNsaWRlRm9jdXMsXG4gICAgc2xpZGVzSGFuZGxlcjogU2xpZGVzSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgd2F0Y2hTbGlkZXMpLFxuICAgIHNsaWRlc0luVmlldyxcbiAgICBzbGlkZUluZGV4ZXMsXG4gICAgc2xpZGVSZWdpc3RyeSxcbiAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICB0YXJnZXQsXG4gICAgdHJhbnNsYXRlOiBUcmFuc2xhdGUoYXhpcywgY29udGFpbmVyKVxuICB9O1xuICByZXR1cm4gZW5naW5lO1xufVxuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSB7fTtcbiAgbGV0IGFwaTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSkge1xuICAgIGFwaSA9IGVtYmxhQXBpO1xuICB9XG4gIGZ1bmN0aW9uIGdldExpc3RlbmVycyhldnQpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJzW2V2dF0gfHwgW107XG4gIH1cbiAgZnVuY3Rpb24gZW1pdChldnQpIHtcbiAgICBnZXRMaXN0ZW5lcnMoZXZ0KS5mb3JFYWNoKGUgPT4gZShhcGksIGV2dCkpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIG9uKGV2dCwgY2IpIHtcbiAgICBsaXN0ZW5lcnNbZXZ0XSA9IGdldExpc3RlbmVycyhldnQpLmNvbmNhdChbY2JdKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBvZmYoZXZ0LCBjYikge1xuICAgIGxpc3RlbmVyc1tldnRdID0gZ2V0TGlzdGVuZXJzKGV2dCkuZmlsdGVyKGUgPT4gZSAhPT0gY2IpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxpc3RlbmVycyA9IHt9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBlbWl0LFxuICAgIG9mZixcbiAgICBvbixcbiAgICBjbGVhclxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFsaWduOiAnY2VudGVyJyxcbiAgYXhpczogJ3gnLFxuICBjb250YWluZXI6IG51bGwsXG4gIHNsaWRlczogbnVsbCxcbiAgY29udGFpblNjcm9sbDogJ3RyaW1TbmFwcycsXG4gIGRpcmVjdGlvbjogJ2x0cicsXG4gIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICBpblZpZXdUaHJlc2hvbGQ6IDAsXG4gIGJyZWFrcG9pbnRzOiB7fSxcbiAgZHJhZ0ZyZWU6IGZhbHNlLFxuICBkcmFnVGhyZXNob2xkOiAxMCxcbiAgbG9vcDogZmFsc2UsXG4gIHNraXBTbmFwczogZmFsc2UsXG4gIGR1cmF0aW9uOiAyNSxcbiAgc3RhcnRJbmRleDogMCxcbiAgYWN0aXZlOiB0cnVlLFxuICB3YXRjaERyYWc6IHRydWUsXG4gIHdhdGNoUmVzaXplOiB0cnVlLFxuICB3YXRjaFNsaWRlczogdHJ1ZSxcbiAgd2F0Y2hGb2N1czogdHJ1ZVxufTtcblxuZnVuY3Rpb24gT3B0aW9uc0hhbmRsZXIob3duZXJXaW5kb3cpIHtcbiAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnNBLCBvcHRpb25zQikge1xuICAgIHJldHVybiBvYmplY3RzTWVyZ2VEZWVwKG9wdGlvbnNBLCBvcHRpb25zQiB8fCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gb3B0aW9uc0F0TWVkaWEob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNBdE1lZGlhID0gb3B0aW9ucy5icmVha3BvaW50cyB8fCB7fTtcbiAgICBjb25zdCBtYXRjaGVkTWVkaWFPcHRpb25zID0gb2JqZWN0S2V5cyhvcHRpb25zQXRNZWRpYSkuZmlsdGVyKG1lZGlhID0+IG93bmVyV2luZG93Lm1hdGNoTWVkaWEobWVkaWEpLm1hdGNoZXMpLm1hcChtZWRpYSA9PiBvcHRpb25zQXRNZWRpYVttZWRpYV0pLnJlZHVjZSgoYSwgbWVkaWFPcHRpb24pID0+IG1lcmdlT3B0aW9ucyhhLCBtZWRpYU9wdGlvbiksIHt9KTtcbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIG1hdGNoZWRNZWRpYU9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIG9wdGlvbnNNZWRpYVF1ZXJpZXMob3B0aW9uc0xpc3QpIHtcbiAgICByZXR1cm4gb3B0aW9uc0xpc3QubWFwKG9wdGlvbnMgPT4gb2JqZWN0S2V5cyhvcHRpb25zLmJyZWFrcG9pbnRzIHx8IHt9KSkucmVkdWNlKChhY2MsIG1lZGlhUXVlcmllcykgPT4gYWNjLmNvbmNhdChtZWRpYVF1ZXJpZXMpLCBbXSkubWFwKG93bmVyV2luZG93Lm1hdGNoTWVkaWEpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIG9wdGlvbnNBdE1lZGlhLFxuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFBsdWdpbnNIYW5kbGVyKG9wdGlvbnNIYW5kbGVyKSB7XG4gIGxldCBhY3RpdmVQbHVnaW5zID0gW107XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGksIHBsdWdpbnMpIHtcbiAgICBhY3RpdmVQbHVnaW5zID0gcGx1Z2lucy5maWx0ZXIoKHtcbiAgICAgIG9wdGlvbnNcbiAgICB9KSA9PiBvcHRpb25zSGFuZGxlci5vcHRpb25zQXRNZWRpYShvcHRpb25zKS5hY3RpdmUgIT09IGZhbHNlKTtcbiAgICBhY3RpdmVQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5pbml0KGVtYmxhQXBpLCBvcHRpb25zSGFuZGxlcikpO1xuICAgIHJldHVybiBwbHVnaW5zLnJlZHVjZSgobWFwLCBwbHVnaW4pID0+IE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICBbcGx1Z2luLm5hbWVdOiBwbHVnaW5cbiAgICB9KSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgYWN0aXZlUGx1Z2lucyA9IGFjdGl2ZVBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiBwbHVnaW4uZGVzdHJveSgpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRW1ibGFDYXJvdXNlbChyb290LCB1c2VyT3B0aW9ucywgdXNlclBsdWdpbnMpIHtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IHJvb3Qub3duZXJEb2N1bWVudDtcbiAgY29uc3Qgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBvcHRpb25zSGFuZGxlciA9IE9wdGlvbnNIYW5kbGVyKG93bmVyV2luZG93KTtcbiAgY29uc3QgcGx1Z2luc0hhbmRsZXIgPSBQbHVnaW5zSGFuZGxlcihvcHRpb25zSGFuZGxlcik7XG4gIGNvbnN0IG1lZGlhSGFuZGxlcnMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGV2ZW50SGFuZGxlciA9IEV2ZW50SGFuZGxlcigpO1xuICBjb25zdCB7XG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIG9wdGlvbnNBdE1lZGlhLFxuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXNcbiAgfSA9IG9wdGlvbnNIYW5kbGVyO1xuICBjb25zdCB7XG4gICAgb24sXG4gICAgb2ZmLFxuICAgIGVtaXRcbiAgfSA9IGV2ZW50SGFuZGxlcjtcbiAgY29uc3QgcmVJbml0ID0gcmVBY3RpdmF0ZTtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBsZXQgZW5naW5lO1xuICBsZXQgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIEVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyk7XG4gIGxldCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdGlvbnNCYXNlKTtcbiAgbGV0IHBsdWdpbkxpc3QgPSBbXTtcbiAgbGV0IHBsdWdpbkFwaXM7XG4gIGxldCBjb250YWluZXI7XG4gIGxldCBzbGlkZXM7XG4gIGZ1bmN0aW9uIHN0b3JlRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyOiB1c2VyQ29udGFpbmVyLFxuICAgICAgc2xpZGVzOiB1c2VyU2xpZGVzXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3VzdG9tQ29udGFpbmVyID0gaXNTdHJpbmcodXNlckNvbnRhaW5lcikgPyByb290LnF1ZXJ5U2VsZWN0b3IodXNlckNvbnRhaW5lcikgOiB1c2VyQ29udGFpbmVyO1xuICAgIGNvbnRhaW5lciA9IGN1c3RvbUNvbnRhaW5lciB8fCByb290LmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGN1c3RvbVNsaWRlcyA9IGlzU3RyaW5nKHVzZXJTbGlkZXMpID8gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodXNlclNsaWRlcykgOiB1c2VyU2xpZGVzO1xuICAgIHNsaWRlcyA9IFtdLnNsaWNlLmNhbGwoY3VzdG9tU2xpZGVzIHx8IGNvbnRhaW5lci5jaGlsZHJlbik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRW5naW5lKG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBFbmdpbmUocm9vdCwgY29udGFpbmVyLCBzbGlkZXMsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCBvcHRpb25zLCBldmVudEhhbmRsZXIpO1xuICAgIGlmIChvcHRpb25zLmxvb3AgJiYgIWVuZ2luZS5zbGlkZUxvb3Blci5jYW5Mb29wKCkpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnNXaXRob3V0TG9vcCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgbG9vcDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVuZ2luZShvcHRpb25zV2l0aG91dExvb3ApO1xuICAgIH1cbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG4gIGZ1bmN0aW9uIGFjdGl2YXRlKHdpdGhPcHRpb25zLCB3aXRoUGx1Z2lucykge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBvcHRpb25zQmFzZSA9IG1lcmdlT3B0aW9ucyhvcHRpb25zQmFzZSwgd2l0aE9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zQXRNZWRpYShvcHRpb25zQmFzZSk7XG4gICAgcGx1Z2luTGlzdCA9IHdpdGhQbHVnaW5zIHx8IHBsdWdpbkxpc3Q7XG4gICAgc3RvcmVFbGVtZW50cygpO1xuICAgIGVuZ2luZSA9IGNyZWF0ZUVuZ2luZShvcHRpb25zKTtcbiAgICBvcHRpb25zTWVkaWFRdWVyaWVzKFtvcHRpb25zQmFzZSwgLi4ucGx1Z2luTGlzdC5tYXAoKHtcbiAgICAgIG9wdGlvbnNcbiAgICB9KSA9PiBvcHRpb25zKV0pLmZvckVhY2gocXVlcnkgPT4gbWVkaWFIYW5kbGVycy5hZGQocXVlcnksICdjaGFuZ2UnLCByZUFjdGl2YXRlKSk7XG4gICAgaWYgKCFvcHRpb25zLmFjdGl2ZSkgcmV0dXJuO1xuICAgIGVuZ2luZS50cmFuc2xhdGUudG8oZW5naW5lLmxvY2F0aW9uLmdldCgpKTtcbiAgICBlbmdpbmUuYW5pbWF0aW9uLmluaXQoKTtcbiAgICBlbmdpbmUuc2xpZGVzSW5WaWV3LmluaXQoKTtcbiAgICBlbmdpbmUuc2xpZGVGb2N1cy5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5ldmVudEhhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5zbGlkZXNIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgaWYgKGVuZ2luZS5vcHRpb25zLmxvb3ApIGVuZ2luZS5zbGlkZUxvb3Blci5sb29wKCk7XG4gICAgaWYgKGNvbnRhaW5lci5vZmZzZXRQYXJlbnQgJiYgc2xpZGVzLmxlbmd0aCkgZW5naW5lLmRyYWdIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgcGx1Z2luQXBpcyA9IHBsdWdpbnNIYW5kbGVyLmluaXQoc2VsZiwgcGx1Z2luTGlzdCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVBY3RpdmF0ZSh3aXRoT3B0aW9ucywgd2l0aFBsdWdpbnMpIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGFjdGl2YXRlKG1lcmdlT3B0aW9ucyh7XG4gICAgICBzdGFydEluZGV4XG4gICAgfSwgd2l0aE9wdGlvbnMpLCB3aXRoUGx1Z2lucyk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3JlSW5pdCcpO1xuICB9XG4gIGZ1bmN0aW9uIGRlQWN0aXZhdGUoKSB7XG4gICAgZW5naW5lLmRyYWdIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuZXZlbnRTdG9yZS5jbGVhcigpO1xuICAgIGVuZ2luZS50cmFuc2xhdGUuY2xlYXIoKTtcbiAgICBlbmdpbmUuc2xpZGVMb29wZXIuY2xlYXIoKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLnNsaWRlc0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5zbGlkZXNJblZpZXcuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5hbmltYXRpb24uZGVzdHJveSgpO1xuICAgIHBsdWdpbnNIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdkZXN0cm95Jyk7XG4gICAgZXZlbnRIYW5kbGVyLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsVG8oaW5kZXgsIGp1bXAsIGRpcmVjdGlvbikge1xuICAgIGlmICghb3B0aW9ucy5hY3RpdmUgfHwgZGVzdHJveWVkKSByZXR1cm47XG4gICAgZW5naW5lLnNjcm9sbEJvZHkudXNlQmFzZUZyaWN0aW9uKCkudXNlRHVyYXRpb24oanVtcCA9PT0gdHJ1ZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uKTtcbiAgICBlbmdpbmUuc2Nyb2xsVG8uaW5kZXgoaW5kZXgsIGRpcmVjdGlvbiB8fCAwKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxOZXh0KGp1bXApIHtcbiAgICBjb25zdCBuZXh0ID0gZW5naW5lLmluZGV4LmFkZCgxKS5nZXQoKTtcbiAgICBzY3JvbGxUbyhuZXh0LCBqdW1wLCAtMSk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJldihqdW1wKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHNjcm9sbFRvKHByZXYsIGp1bXAsIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbE5leHQoKSB7XG4gICAgY29uc3QgbmV4dCA9IGVuZ2luZS5pbmRleC5hZGQoMSkuZ2V0KCk7XG4gICAgcmV0dXJuIG5leHQgIT09IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbFByZXYoKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHJldHVybiBwcmV2ICE9PSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxTbmFwTGlzdCgpIHtcbiAgICByZXR1cm4gZW5naW5lLnNjcm9sbFNuYXBMaXN0O1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFByb2dyZXNzKCkge1xuICAgIHJldHVybiBlbmdpbmUuc2Nyb2xsUHJvZ3Jlc3MuZ2V0KGVuZ2luZS5vZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0ZWRTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXguZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJldmlvdXNTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXhQcmV2aW91cy5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNJblZpZXcoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zbGlkZXNJblZpZXcuZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzTm90SW5WaWV3KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2xpZGVzSW5WaWV3LmdldChmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gcGx1Z2lucygpIHtcbiAgICByZXR1cm4gcGx1Z2luQXBpcztcbiAgfVxuICBmdW5jdGlvbiBpbnRlcm5hbEVuZ2luZSgpIHtcbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG4gIGZ1bmN0aW9uIHJvb3ROb2RlKCkge1xuICAgIHJldHVybiByb290O1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRhaW5lck5vZGUoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZU5vZGVzKCkge1xuICAgIHJldHVybiBzbGlkZXM7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjYW5TY3JvbGxOZXh0LFxuICAgIGNhblNjcm9sbFByZXYsXG4gICAgY29udGFpbmVyTm9kZSxcbiAgICBpbnRlcm5hbEVuZ2luZSxcbiAgICBkZXN0cm95LFxuICAgIG9mZixcbiAgICBvbixcbiAgICBlbWl0LFxuICAgIHBsdWdpbnMsXG4gICAgcHJldmlvdXNTY3JvbGxTbmFwLFxuICAgIHJlSW5pdCxcbiAgICByb290Tm9kZSxcbiAgICBzY3JvbGxOZXh0LFxuICAgIHNjcm9sbFByZXYsXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3QsXG4gICAgc2Nyb2xsVG8sXG4gICAgc2VsZWN0ZWRTY3JvbGxTbmFwLFxuICAgIHNsaWRlTm9kZXMsXG4gICAgc2xpZGVzSW5WaWV3LFxuICAgIHNsaWRlc05vdEluVmlld1xuICB9O1xuICBhY3RpdmF0ZSh1c2VyT3B0aW9ucywgdXNlclBsdWdpbnMpO1xuICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50SGFuZGxlci5lbWl0KCdpbml0JyksIDApO1xuICByZXR1cm4gc2VsZjtcbn1cbkVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgRW1ibGFDYXJvdXNlbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJsYS1jYXJvdXNlbC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiaW5kZXgiLCJncm91cCIsInNjcm9sbEJvZHkiLCJsb29wIiwibG9jYXRpb24iLCJvZmZzZXRMb2NhdGlvbiIsInByZXZpb3VzTG9jYXRpb24iLCJhbmltYXRpb24iLCJldmVudEhhbmRsZXIiLCJvcHRpb25zQXRNZWRpYSIsIm9wdGlvbnMiLCJlbmdpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/embla-carousel/esm/embla-carousel.esm.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/slideshow.js":
/*!**************************************!*\
  !*** ./src/entrypoints/slideshow.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var embla_carousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! embla-carousel */ \"./node_modules/embla-carousel/esm/embla-carousel.esm.js\");\n/* harmony import */ var embla_carousel_class_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! embla-carousel-class-names */ \"./node_modules/embla-carousel-class-names/esm/embla-carousel-class-names.esm.js\");\n/* harmony import */ var embla_carousel_autoplay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! embla-carousel-autoplay */ \"./node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js\");\n/* harmony import */ var embla_carousel_fade__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! embla-carousel-fade */ \"./node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js\");\n\n\n\n\nif (!customElements.get(\"slide-show\")) {\n  customElements.define(\n    \"slide-show\",\n    class Slideshow extends HTMLElement {\n      constructor() {\n        super();\n        this.slidesToShow = this?.dataset?.slidesToShow ? this?.dataset?.slidesToShow.split(\",\") : \"1\";\n        this.loop = this.dataset.loop === \"true\" ? true : false;\n        this.axis = this.dataset.axis || \"x\";\n        this.align = this.dataset.align || \"center\";\n        this.autoplay = this.dataset.autoplay === \"true\" ? true : false;\n        this.autoplaySpeed = this?.dataset?.autoplaySpeed ? parseInt(this.dataset.autoplaySpeed) : 3e3;\n        this.drag = this.dataset.drag === \"false\" ? false : true;\n        this.fade = this.dataset.fade === \"true\" ? true : false;\n        this.dots = this.querySelector(\".slider-dots\");\n        this.dotItems = false;\n        this.arrowNext = this.querySelector(\".slider-next\");\n        this.arrowPrev = this.querySelector(\".slider-prev\");\n        this.slides = this.querySelectorAll(\".slider-slide\") || [];\n        this.navs = this.querySelectorAll(\".slider-nav\");\n        this.currentSlide = 0;\n        this.initializeSlideshow();\n      }\n      editorActions(embla) {\n        if (document.body.dataset.shopifyEditor === \"true\" && this.slides?.length > 1) {\n          const blockEditor = (ev) => {\n            const { target } = ev;\n            const selectedIndex = Array.from(this.slides).findIndex(\n              (slide) => slide?.dataset?.shopifyEditorBlock === target?.dataset?.shopifyEditorBlock\n            );\n            embla.scrollTo(selectedIndex);\n          };\n          document.addEventListener(\"shopify:block:select\", blockEditor);\n        }\n      }\n      initializeSlideshow() {\n        const slidesToShow = this.slidesToShow;\n        const loop = this.loop;\n        if (slidesToShow) {\n          this.style.setProperty(\"--slides-xs\", slidesToShow[0]);\n          this.style.setProperty(\"--slides-sm\", slidesToShow[1] || slidesToShow[0]);\n          this.style.setProperty(\n            \"--slides-md\",\n            slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n          this.style.setProperty(\n            \"--slides-lg\",\n            slidesToShow[3] || slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n          this.style.setProperty(\n            \"--slides-xl\",\n            slidesToShow[4] || slidesToShow[3] || slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n          this.style.setProperty(\n            \"--slides-2xl\",\n            slidesToShow[5] || slidesToShow[4] || slidesToShow[3] || slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n          this.style.setProperty(\n            \"--slides-3xl\",\n            slidesToShow[6] || slidesToShow[5] || slidesToShow[4] || slidesToShow[3] || slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n        }\n        const options = {\n          loop,\n          axis: this.axis,\n          align: this.align,\n          watchDrag: this.drag,\n          containScroll: \"trimSnaps\"\n        };\n        let plugins = [(0,embla_carousel_class_names__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()];\n        if (this.autoplay) {\n          plugins = [...plugins, (0,embla_carousel_autoplay__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({ delay: this.autoplaySpeed })];\n        }\n        if (this.fade) {\n          plugins = [...plugins, (0,embla_carousel_fade__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()];\n        }\n        const embla = (0,embla_carousel__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, options, plugins);\n        const toggleActiveWhenScrollable = () => {\n          setTimeout(() => {\n            let isScrollable = embla.internalEngine().scrollSnaps.length > 1;\n            if (!isScrollable) {\n              this?.arrowNext?.classList.add(\"!hidden\");\n              this?.arrowPrev?.classList.add(\"!hidden\");\n              this?.dots?.classList.add(\"!hidden\");\n            } else {\n              this?.arrowNext?.classList.remove(\"!hidden\");\n              this?.arrowPrev?.classList.remove(\"!hidden\");\n              this?.dots?.classList.remove(\"!hidden\");\n            }\n            embla.reInit({ active: isScrollable });\n          }, 100);\n        };\n        if (this.arrowNext) {\n          this.arrowNext.addEventListener(\"click\", () => {\n            embla.scrollNext();\n            updateSlide();\n          });\n        }\n        if (this.arrowPrev) {\n          this.arrowPrev.addEventListener(\"click\", () => {\n            embla.scrollPrev();\n            updateSlide();\n          });\n        }\n        const setTheme = () => {\n          if (this.classList.contains(\"change-color\")) {\n            const slideClasses = Array.from(this.classList);\n            const slideColor = this?.slides[this.currentSlide]?.dataset?.colorScheme || \"\";\n            const classToRemove = slideClasses.find((cls) => cls.includes(\"theme-\"));\n            if (!this.classList.contains(slideColor)) {\n              this.classList.remove(classToRemove);\n              this.classList.add(slideColor);\n            }\n          }\n        };\n        const updateSlide = () => {\n          if (this.arrowPrev) {\n            this.arrowPrev.disabled = !embla.canScrollPrev();\n          }\n          if (this.arrowNext) {\n            this.arrowNext.disabled = !embla.canScrollNext();\n          }\n          this.currentSlide = embla.slideNodes().findIndex((node) => node?.classList.contains(\"is-snapped\"));\n          this.querySelectorAll(\"#currentSlide\").forEach((item) => {\n            item.innerHTML = this.currentSlide + 1;\n          });\n          if (this.dotItems) {\n            this.dotItems?.forEach((item, index) => {\n              if (index === this.currentSlide) {\n                item.classList.add(\"active\");\n              } else {\n                item.classList.remove(\"active\");\n              }\n            });\n          }\n          if (this.navs?.length > 0) {\n            Array.from(this.navs).forEach((nav) => {\n              const buttons = nav.querySelectorAll(\"button\");\n              if (buttons?.length > 0) {\n                buttons.forEach((button, index) => {\n                  if (index === this.currentSlide) {\n                    button.classList.add(\"active\");\n                  } else {\n                    button.classList.remove(\"active\");\n                  }\n                });\n              }\n            });\n          }\n          setTheme();\n        };\n        const renderDots = () => {\n          if (this.dots) {\n            let dotItems = \"\";\n            embla.slideNodes()?.forEach((slide, index) => {\n              dotItems += '<button class=\"slider-dot\" title=\"Go to slide ' + (index + 1) + '\"><span>' + (index + 1) + \"</span></button>\";\n            });\n            this.dots.innerHTML = dotItems;\n            this.dotItems = this?.dots?.querySelectorAll(\".slider-dot\");\n            if (this.dotItems) {\n              this.dotItems?.forEach((item, index) => {\n                if (index === 0) {\n                  item.classList.add(\"active\");\n                }\n                item?.addEventListener(\"click\", () => {\n                  embla.scrollTo(index);\n                });\n              });\n            }\n          }\n        };\n        const renderNav = () => {\n          if (this.navs?.length > 0) {\n            Array.from(this.navs).forEach((nav) => {\n              const buttons = nav.querySelectorAll(\"button\");\n              if (buttons?.length > 0) {\n                buttons.forEach((button, index) => {\n                  button.addEventListener(\"click\", () => {\n                    embla.scrollTo(index);\n                    this.currentSlide = index;\n                  });\n                });\n              }\n            });\n          }\n        };\n        embla.on(\"scroll\", updateSlide);\n        window.addEventListener(\"resize\", toggleActiveWhenScrollable);\n        toggleActiveWhenScrollable();\n        updateSlide();\n        renderDots();\n        renderNav();\n        this.editorActions(embla);\n      }\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RztBQUN6QixrQkFBTSxLQUFLLEtBQUssSUFBSSxFQUFFLFFBQVEsQ0FBQyxRQUFRO0FBQ3JDLG9CQUFNLFVBQVUsSUFBSSxpQkFBaUIsUUFBUTtBQUM3QyxrQkFBSSxTQUFTLFNBQVMsR0FBRztBQUN2Qix3QkFBUSxRQUFRLENBQUMsUUFBUSxVQUFVO0FBQ2pDLHlCQUFPLGlCQUFpQixTQUFTLE1BQU07QUFDckMsMEJBQU0sU0FBUyxLQUFLO0FBQ3BCLHlCQUFLLGVBQWU7QUFBQSxrQkFDdEIsQ0FBQztBQUFBLGdCQUNILENBQUM7QUFBQSxjQUNIO0FBQUEsWUFDRixDQUFDO0FBQUEsVUFDSDtBQUFBLFFBQ0Y7QUFFQSxjQUFNLEdBQUcsVUFBVSxXQUFXO0FBQzlCLGVBQU8saUJBQWlCLFVBQVUsMEJBQTBCO0FBQzVELG1DQUEyQjtBQUMzQixvQkFBWTtBQUNaLG1CQUFXO0FBQ1gsa0JBQVU7QUFDVixhQUFLLGNBQWMsS0FBSztBQUFBLE1BQzFCO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpZnktc3RhcnRlci8uL3NyYy9lbnRyeXBvaW50cy9zbGlkZXNob3cuanM/YTA5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRW1ibGFDYXJvdXNlbCBmcm9tICdlbWJsYS1jYXJvdXNlbCdcbmltcG9ydCBDbGFzc05hbWVzIGZyb20gJ2VtYmxhLWNhcm91c2VsLWNsYXNzLW5hbWVzJ1xuaW1wb3J0IEF1dG9wbGF5IGZyb20gJ2VtYmxhLWNhcm91c2VsLWF1dG9wbGF5J1xuaW1wb3J0IEZhZGUgZnJvbSAnZW1ibGEtY2Fyb3VzZWwtZmFkZSdcblxuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoJ3NsaWRlLXNob3cnKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXG4gICAgJ3NsaWRlLXNob3cnLFxuICAgIGNsYXNzIFNsaWRlc2hvdyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG5cbiAgICAgICAgdGhpcy5zbGlkZXNUb1Nob3cgPSB0aGlzPy5kYXRhc2V0Py5zbGlkZXNUb1Nob3dcbiAgICAgICAgICA/IHRoaXM/LmRhdGFzZXQ/LnNsaWRlc1RvU2hvdy5zcGxpdCgnLCcpXG4gICAgICAgICAgOiAnMSdcbiAgICAgICAgdGhpcy5sb29wID0gdGhpcy5kYXRhc2V0Lmxvb3AgPT09ICd0cnVlJyA/IHRydWUgOiBmYWxzZVxuICAgICAgICB0aGlzLmF4aXMgPSB0aGlzLmRhdGFzZXQuYXhpcyB8fCAneCdcbiAgICAgICAgdGhpcy5hbGlnbiA9IHRoaXMuZGF0YXNldC5hbGlnbiB8fCAnY2VudGVyJ1xuICAgICAgICB0aGlzLmF1dG9wbGF5ID0gdGhpcy5kYXRhc2V0LmF1dG9wbGF5ID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgdGhpcy5hdXRvcGxheVNwZWVkID0gdGhpcz8uZGF0YXNldD8uYXV0b3BsYXlTcGVlZFxuICAgICAgICAgID8gcGFyc2VJbnQodGhpcy5kYXRhc2V0LmF1dG9wbGF5U3BlZWQpXG4gICAgICAgICAgOiAzMDAwXG4gICAgICAgIHRoaXMuZHJhZyA9IHRoaXMuZGF0YXNldC5kcmFnID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlXG4gICAgICAgIHRoaXMuZmFkZSA9IHRoaXMuZGF0YXNldC5mYWRlID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgdGhpcy5kb3RzID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyLWRvdHMnKVxuICAgICAgICB0aGlzLmRvdEl0ZW1zID0gZmFsc2VcbiAgICAgICAgdGhpcy5hcnJvd05leHQgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXItbmV4dCcpXG4gICAgICAgIHRoaXMuYXJyb3dQcmV2ID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyLXByZXYnKVxuICAgICAgICB0aGlzLnNsaWRlcyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlci1zbGlkZScpIHx8IFtdXG4gICAgICAgIHRoaXMubmF2cyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlci1uYXYnKVxuICAgICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IDBcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU2xpZGVzaG93KClcbiAgICAgIH1cblxuICAgICAgZWRpdG9yQWN0aW9ucyhlbWJsYSkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5kYXRhc2V0LnNob3BpZnlFZGl0b3IgPT09ICd0cnVlJyAmJiB0aGlzLnNsaWRlcz8ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrRWRpdG9yID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gZXZcbiAgICAgICAgICAgIC8vIEZpbmQgaW5kZXggb24gc2VsZWN0ZWQgc2xpZGVcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBBcnJheS5mcm9tKHRoaXMuc2xpZGVzKS5maW5kSW5kZXgoXG4gICAgICAgICAgICAgIChzbGlkZSkgPT4gc2xpZGU/LmRhdGFzZXQ/LnNob3BpZnlFZGl0b3JCbG9jayA9PT0gdGFyZ2V0Py5kYXRhc2V0Py5zaG9waWZ5RWRpdG9yQmxvY2tcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC8vIEdvIHRvIHNlbGVjdGVkIHNsaWRlIG9uIHNlbGVjdCBpbiBlZGl0b3JcblxuICAgICAgICAgICAgZW1ibGEuc2Nyb2xsVG8oc2VsZWN0ZWRJbmRleClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzaG9waWZ5OmJsb2NrOnNlbGVjdCcsIGJsb2NrRWRpdG9yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpemVTbGlkZXNob3coKSB7XG4gICAgICAgIGNvbnN0IHNsaWRlc1RvU2hvdyA9IHRoaXMuc2xpZGVzVG9TaG93XG4gICAgICAgIGNvbnN0IGxvb3AgPSB0aGlzLmxvb3BcblxuICAgICAgICBpZiAoc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zbGlkZXMteHMnLCBzbGlkZXNUb1Nob3dbMF0pXG4gICAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zbGlkZXMtc20nLCBzbGlkZXNUb1Nob3dbMV0gfHwgc2xpZGVzVG9TaG93WzBdKVxuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAnLS1zbGlkZXMtbWQnLFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzJdIHx8IHNsaWRlc1RvU2hvd1sxXSB8fCBzbGlkZXNUb1Nob3dbMF1cbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICctLXNsaWRlcy1sZycsXG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbM10gfHwgc2xpZGVzVG9TaG93WzJdIHx8IHNsaWRlc1RvU2hvd1sxXSB8fCBzbGlkZXNUb1Nob3dbMF1cbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICctLXNsaWRlcy14bCcsXG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbNF0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1szXSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzJdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbMV0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1swXVxuICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgJy0tc2xpZGVzLTJ4bCcsXG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbNV0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1s0XSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzNdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbMl0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1sxXSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzBdXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAnLS1zbGlkZXMtM3hsJyxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1s2XSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzVdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbNF0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1szXSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzJdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbMV0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1swXVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgbG9vcDogbG9vcCxcbiAgICAgICAgICBheGlzOiB0aGlzLmF4aXMsXG4gICAgICAgICAgYWxpZ246IHRoaXMuYWxpZ24sXG4gICAgICAgICAgd2F0Y2hEcmFnOiB0aGlzLmRyYWcsXG4gICAgICAgICAgY29udGFpblNjcm9sbDogJ3RyaW1TbmFwcydcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgc2xpZGVyXG4gICAgICAgIGxldCBwbHVnaW5zID0gW0NsYXNzTmFtZXMoKV1cbiAgICAgICAgaWYgKHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgICAgICBwbHVnaW5zID0gWy4uLnBsdWdpbnMsIEF1dG9wbGF5KHsgZGVsYXk6IHRoaXMuYXV0b3BsYXlTcGVlZCB9KV1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mYWRlKSB7XG4gICAgICAgICAgcGx1Z2lucyA9IFsuLi5wbHVnaW5zLCBGYWRlKCldXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbWJsYSA9IEVtYmxhQ2Fyb3VzZWwodGhpcywgb3B0aW9ucywgcGx1Z2lucylcblxuICAgICAgICBjb25zdCB0b2dnbGVBY3RpdmVXaGVuU2Nyb2xsYWJsZSA9ICgpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGxldCBpc1Njcm9sbGFibGUgPSBlbWJsYS5pbnRlcm5hbEVuZ2luZSgpLnNjcm9sbFNuYXBzLmxlbmd0aCA+IDFcblxuICAgICAgICAgICAgaWYgKCFpc1Njcm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgdGhpcz8uYXJyb3dOZXh0Py5jbGFzc0xpc3QuYWRkKCchaGlkZGVuJylcbiAgICAgICAgICAgICAgdGhpcz8uYXJyb3dQcmV2Py5jbGFzc0xpc3QuYWRkKCchaGlkZGVuJylcbiAgICAgICAgICAgICAgdGhpcz8uZG90cz8uY2xhc3NMaXN0LmFkZCgnIWhpZGRlbicpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzPy5hcnJvd05leHQ/LmNsYXNzTGlzdC5yZW1vdmUoJyFoaWRkZW4nKVxuICAgICAgICAgICAgICB0aGlzPy5hcnJvd1ByZXY/LmNsYXNzTGlzdC5yZW1vdmUoJyFoaWRkZW4nKVxuICAgICAgICAgICAgICB0aGlzPy5kb3RzPy5jbGFzc0xpc3QucmVtb3ZlKCchaGlkZGVuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtYmxhLnJlSW5pdCh7IGFjdGl2ZTogaXNTY3JvbGxhYmxlIH0pXG4gICAgICAgICAgfSwgMTAwKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2xpZGVyIENvbnRyb2xzXG4gICAgICAgIGlmICh0aGlzLmFycm93TmV4dCkge1xuICAgICAgICAgIHRoaXMuYXJyb3dOZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgZW1ibGEuc2Nyb2xsTmV4dCgpXG4gICAgICAgICAgICB1cGRhdGVTbGlkZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFycm93UHJldikge1xuICAgICAgICAgIHRoaXMuYXJyb3dQcmV2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgZW1ibGEuc2Nyb2xsUHJldigpXG4gICAgICAgICAgICB1cGRhdGVTbGlkZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldFRoZW1lID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmNsYXNzTGlzdC5jb250YWlucygnY2hhbmdlLWNvbG9yJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlQ2xhc3NlcyA9IEFycmF5LmZyb20odGhpcy5jbGFzc0xpc3QpXG4gICAgICAgICAgICBjb25zdCBzbGlkZUNvbG9yID0gdGhpcz8uc2xpZGVzW3RoaXMuY3VycmVudFNsaWRlXT8uZGF0YXNldD8uY29sb3JTY2hlbWUgfHwgJydcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzVG9SZW1vdmUgPSBzbGlkZUNsYXNzZXMuZmluZChjbHMgPT4gY2xzLmluY2x1ZGVzKCd0aGVtZS0nKSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoc2xpZGVDb2xvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzVG9SZW1vdmUpXG4gICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChzbGlkZUNvbG9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwZGF0ZVNsaWRlID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmFycm93UHJldikge1xuICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXYuZGlzYWJsZWQgPSAhZW1ibGEuY2FuU2Nyb2xsUHJldigpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmFycm93TmV4dCkge1xuICAgICAgICAgICAgdGhpcy5hcnJvd05leHQuZGlzYWJsZWQgPSAhZW1ibGEuY2FuU2Nyb2xsTmV4dCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VycmVudFNsaWRlID0gZW1ibGFcbiAgICAgICAgICAgIC5zbGlkZU5vZGVzKClcbiAgICAgICAgICAgIC5maW5kSW5kZXgoKG5vZGUpID0+IG5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnaXMtc25hcHBlZCcpKVxuICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3RvckFsbCgnI2N1cnJlbnRTbGlkZScpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uaW5uZXJIVE1MID0gdGhpcy5jdXJyZW50U2xpZGUgKyAxXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmICh0aGlzLmRvdEl0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLmRvdEl0ZW1zPy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuY3VycmVudFNsaWRlKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5uYXZzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMubmF2cykuZm9yRWFjaCgobmF2KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbnMgPSBuYXYucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJylcbiAgICAgICAgICAgICAgaWYgKGJ1dHRvbnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBidXR0b25zLmZvckVhY2goKGJ1dHRvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5jdXJyZW50U2xpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFRoZW1lKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlbmRlckRvdHMgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICAgICAgbGV0IGRvdEl0ZW1zID0gJydcblxuICAgICAgICAgICAgZW1ibGEuc2xpZGVOb2RlcygpPy5mb3JFYWNoKChzbGlkZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgZG90SXRlbXMgKz1cbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cInNsaWRlci1kb3RcIiB0aXRsZT1cIkdvIHRvIHNsaWRlICcgK1xuICAgICAgICAgICAgICAgIChpbmRleCArIDEpICtcbiAgICAgICAgICAgICAgICAnXCI+PHNwYW4+JyArXG4gICAgICAgICAgICAgICAgKGluZGV4ICsgMSkgK1xuICAgICAgICAgICAgICAgICc8L3NwYW4+PC9idXR0b24+J1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGhpcy5kb3RzLmlubmVySFRNTCA9IGRvdEl0ZW1zXG4gICAgICAgICAgICB0aGlzLmRvdEl0ZW1zID0gdGhpcz8uZG90cz8ucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlci1kb3QnKVxuXG4gICAgICAgICAgICBpZiAodGhpcy5kb3RJdGVtcykge1xuICAgICAgICAgICAgICB0aGlzLmRvdEl0ZW1zPy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGVtYmxhLnNjcm9sbFRvKGluZGV4KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVuZGVyTmF2ID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLm5hdnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5uYXZzKS5mb3JFYWNoKChuYXYpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgYnV0dG9ucyA9IG5hdi5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKVxuICAgICAgICAgICAgICBpZiAoYnV0dG9ucz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMuZm9yRWFjaCgoYnV0dG9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbWJsYS5zY3JvbGxUbyhpbmRleClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2xpZGUgPSBpbmRleFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVtYmxhLm9uKCdzY3JvbGwnLCB1cGRhdGVTbGlkZSlcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRvZ2dsZUFjdGl2ZVdoZW5TY3JvbGxhYmxlKVxuICAgICAgICB0b2dnbGVBY3RpdmVXaGVuU2Nyb2xsYWJsZSgpXG4gICAgICAgIHVwZGF0ZVNsaWRlKClcbiAgICAgICAgcmVuZGVyRG90cygpXG4gICAgICAgIHJlbmRlck5hdigpXG4gICAgICAgIHRoaXMuZWRpdG9yQWN0aW9ucyhlbWJsYSlcbiAgICAgIH1cbiAgICB9XG4gIClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/entrypoints/slideshow.js\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entrypoints/slideshow.js");
/******/ 	
/******/ })()
;