/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Autoplay)\n/* harmony export */ });\nconst defaultOptions = {\n  active: true,\n  breakpoints: {},\n  delay: 4e3,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n};\nfunction normalizeDelay(emblaApi, delay) {\n  const scrollSnaps = emblaApi.scrollSnapList();\n  if (typeof delay === \"number\") {\n    return scrollSnaps.map(() => delay);\n  }\n  return delay(scrollSnaps, emblaApi);\n}\nfunction getAutoplayRootNode(emblaApi, rootNode) {\n  const emblaRootNode = emblaApi.rootNode();\n  return rootNode && rootNode(emblaRootNode) || emblaRootNode;\n}\nfunction Autoplay(userOptions = {}) {\n  let options;\n  let emblaApi;\n  let destroyed;\n  let delay;\n  let timerStartTime = null;\n  let timerId = 0;\n  let autoplayActive = false;\n  let mouseIsOver = false;\n  let playOnDocumentVisible = false;\n  let jump = false;\n  function init(emblaApiInstance, optionsHandler) {\n    emblaApi = emblaApiInstance;\n    const {\n      mergeOptions,\n      optionsAtMedia\n    } = optionsHandler;\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions);\n    const allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    if (emblaApi.scrollSnapList().length <= 1)\n      return;\n    jump = options.jump;\n    destroyed = false;\n    delay = normalizeDelay(emblaApi, options.delay);\n    const {\n      eventStore,\n      ownerDocument\n    } = emblaApi.internalEngine();\n    const isDraggable = !!emblaApi.internalEngine().options.watchDrag;\n    const root = getAutoplayRootNode(emblaApi, options.rootNode);\n    eventStore.add(ownerDocument, \"visibilitychange\", visibilityChange);\n    if (isDraggable) {\n      emblaApi.on(\"pointerDown\", pointerDown);\n    }\n    if (isDraggable && !options.stopOnInteraction) {\n      emblaApi.on(\"pointerUp\", pointerUp);\n    }\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, \"mouseenter\", mouseEnter);\n    }\n    if (options.stopOnMouseEnter && !options.stopOnInteraction) {\n      eventStore.add(root, \"mouseleave\", mouseLeave);\n    }\n    if (options.stopOnFocusIn) {\n      emblaApi.on(\"slideFocusStart\", stopAutoplay);\n    }\n    if (options.stopOnFocusIn && !options.stopOnInteraction) {\n      eventStore.add(emblaApi.containerNode(), \"focusout\", startAutoplay);\n    }\n    if (options.playOnInit)\n      startAutoplay();\n  }\n  function destroy() {\n    emblaApi.off(\"pointerDown\", pointerDown).off(\"pointerUp\", pointerUp).off(\"slideFocusStart\", stopAutoplay);\n    stopAutoplay();\n    destroyed = true;\n    autoplayActive = false;\n  }\n  function setTimer() {\n    const {\n      ownerWindow\n    } = emblaApi.internalEngine();\n    ownerWindow.clearTimeout(timerId);\n    timerId = ownerWindow.setTimeout(next, delay[emblaApi.selectedScrollSnap()]);\n    timerStartTime = new Date().getTime();\n    emblaApi.emit(\"autoplay:timerset\");\n  }\n  function clearTimer() {\n    const {\n      ownerWindow\n    } = emblaApi.internalEngine();\n    ownerWindow.clearTimeout(timerId);\n    timerId = 0;\n    timerStartTime = null;\n    emblaApi.emit(\"autoplay:timerstopped\");\n  }\n  function startAutoplay() {\n    if (destroyed)\n      return;\n    if (documentIsHidden()) {\n      playOnDocumentVisible = true;\n      return;\n    }\n    if (!autoplayActive)\n      emblaApi.emit(\"autoplay:play\");\n    setTimer();\n    autoplayActive = true;\n  }\n  function stopAutoplay() {\n    if (destroyed)\n      return;\n    if (autoplayActive)\n      emblaApi.emit(\"autoplay:stop\");\n    clearTimer();\n    autoplayActive = false;\n  }\n  function visibilityChange() {\n    if (documentIsHidden()) {\n      playOnDocumentVisible = autoplayActive;\n      return stopAutoplay();\n    }\n    if (playOnDocumentVisible)\n      startAutoplay();\n  }\n  function documentIsHidden() {\n    const {\n      ownerDocument\n    } = emblaApi.internalEngine();\n    return ownerDocument.visibilityState === \"hidden\";\n  }\n  function pointerDown() {\n    if (!mouseIsOver)\n      stopAutoplay();\n  }\n  function pointerUp() {\n    if (!mouseIsOver)\n      startAutoplay();\n  }\n  function mouseEnter() {\n    mouseIsOver = true;\n    stopAutoplay();\n  }\n  function mouseLeave() {\n    mouseIsOver = false;\n    startAutoplay();\n  }\n  function play(jumpOverride) {\n    if (typeof jumpOverride !== \"undefined\")\n      jump = jumpOverride;\n    startAutoplay();\n  }\n  function stop() {\n    if (autoplayActive)\n      stopAutoplay();\n  }\n  function reset() {\n    if (autoplayActive)\n      startAutoplay();\n  }\n  function isPlaying() {\n    return autoplayActive;\n  }\n  function next() {\n    const {\n      index\n    } = emblaApi.internalEngine();\n    const nextIndex = index.clone().add(1).get();\n    const lastIndex = emblaApi.scrollSnapList().length - 1;\n    const kill = options.stopOnLastSnap && nextIndex === lastIndex;\n    if (emblaApi.canScrollNext()) {\n      emblaApi.scrollNext(jump);\n    } else {\n      emblaApi.scrollTo(0, jump);\n    }\n    emblaApi.emit(\"autoplay:select\");\n    if (kill)\n      return stopAutoplay();\n    startAutoplay();\n  }\n  function timeUntilNext() {\n    if (!timerStartTime)\n      return null;\n    const currentDelay = delay[emblaApi.selectedScrollSnap()];\n    const timePastSinceStart = new Date().getTime() - timerStartTime;\n    return currentDelay - timePastSinceStart;\n  }\n  const self = {\n    name: \"autoplay\",\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying,\n    timeUntilNext\n  };\n  return self;\n}\nAutoplay.globalOptions = void 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtYXV0b3BsYXkvZXNtL2VtYmxhLWNhcm91c2VsLWF1dG9wbGF5LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTSxpQkFBaUI7QUFBQSxFQUNyQixRQUFRO0FBQUEsRUFDUixhQUFhLENBQUM7QUFBQSxFQUNkLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLGVBQWU7QUFBQSxFQUNmLG1CQUFtQjtBQUFBLEVBQ25CLGtCQUFrQjtBQUFBLEVBQ2xCLGdCQUFnQjtBQUFBLEVBQ2hCLFVBQVU7QUFDWjtBQUVBLFNBQVMsZUFBZSxVQUFVLE9BQU87QUFDdkMsUUFBTSxjQUFjLFNBQVMsZUFBZTtBQUM1QyxNQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLFdBQU8sWUFBWSxJQUFJLE1BQU0sS0FBSztBQUFBLEVBQ3BDO0FBQ0EsU0FBTyxNQUFNLGFBQWEsUUFBUTtBQUNwQztBQUNBLFNBQVMsb0JBQW9CLFVBQVUsVUFBVTtBQUMvQyxRQUFNLGdCQUFnQixTQUFTLFNBQVM7QUFDeEMsU0FBTyxZQUFZLFNBQVMsYUFBYSxLQUFLO0FBQ2hEO0FBRUEsU0FBUyxTQUFTLGNBQWMsQ0FBQyxHQUFHO0FBQ2xDLE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSTtBQUNKLE1BQUk7QUFDSixNQUFJLGlCQUFpQjtBQUNyQixNQUFJLFVBQVU7QUFDZCxNQUFJLGlCQUFpQjtBQUNyQixNQUFJLGNBQWM7QUFDbEIsTUFBSSx3QkFBd0I7QUFDNUIsTUFBSSxPQUFPO0FBQ1gsV0FBUyxLQUFLLGtCQUFrQixnQkFBZ0I7QUFDOUMsZUFBVztBQUNYLFVBQU07QUFBQSxNQUNKO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSTtBQUNKLFVBQU0sY0FBYyxhQUFhLGdCQUFnQixTQUFTLGFBQWE7QUFDdkUsVUFBTSxhQUFhLGFBQWEsYUFBYSxXQUFXO0FBQ3hELGNBQVUsZUFBZSxVQUFVO0FBQ25DLFFBQUksU0FB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U0FBUyxnQkFBZ0I7QUFFTSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpZnktc3RhcnRlci8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC1hdXRvcGxheS9lc20vZW1ibGEtY2Fyb3VzZWwtYXV0b3BsYXkuZXNtLmpzP2ZmNjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFjdGl2ZTogdHJ1ZSxcbiAgYnJlYWtwb2ludHM6IHt9LFxuICBkZWxheTogNDAwMCxcbiAganVtcDogZmFsc2UsXG4gIHBsYXlPbkluaXQ6IHRydWUsXG4gIHN0b3BPbkZvY3VzSW46IHRydWUsXG4gIHN0b3BPbkludGVyYWN0aW9uOiB0cnVlLFxuICBzdG9wT25Nb3VzZUVudGVyOiBmYWxzZSxcbiAgc3RvcE9uTGFzdFNuYXA6IGZhbHNlLFxuICByb290Tm9kZTogbnVsbFxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGVsYXkoZW1ibGFBcGksIGRlbGF5KSB7XG4gIGNvbnN0IHNjcm9sbFNuYXBzID0gZW1ibGFBcGkuc2Nyb2xsU25hcExpc3QoKTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gc2Nyb2xsU25hcHMubWFwKCgpID0+IGRlbGF5KTtcbiAgfVxuICByZXR1cm4gZGVsYXkoc2Nyb2xsU25hcHMsIGVtYmxhQXBpKTtcbn1cbmZ1bmN0aW9uIGdldEF1dG9wbGF5Um9vdE5vZGUoZW1ibGFBcGksIHJvb3ROb2RlKSB7XG4gIGNvbnN0IGVtYmxhUm9vdE5vZGUgPSBlbWJsYUFwaS5yb290Tm9kZSgpO1xuICByZXR1cm4gcm9vdE5vZGUgJiYgcm9vdE5vZGUoZW1ibGFSb290Tm9kZSkgfHwgZW1ibGFSb290Tm9kZTtcbn1cblxuZnVuY3Rpb24gQXV0b3BsYXkodXNlck9wdGlvbnMgPSB7fSkge1xuICBsZXQgb3B0aW9ucztcbiAgbGV0IGVtYmxhQXBpO1xuICBsZXQgZGVzdHJveWVkO1xuICBsZXQgZGVsYXk7XG4gIGxldCB0aW1lclN0YXJ0VGltZSA9IG51bGw7XG4gIGxldCB0aW1lcklkID0gMDtcbiAgbGV0IGF1dG9wbGF5QWN0aXZlID0gZmFsc2U7XG4gIGxldCBtb3VzZUlzT3ZlciA9IGZhbHNlO1xuICBsZXQgcGxheU9uRG9jdW1lbnRWaXNpYmxlID0gZmFsc2U7XG4gIGxldCBqdW1wID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGlJbnN0YW5jZSwgb3B0aW9uc0hhbmRsZXIpIHtcbiAgICBlbWJsYUFwaSA9IGVtYmxhQXBpSW5zdGFuY2U7XG4gICAgY29uc3Qge1xuICAgICAgbWVyZ2VPcHRpb25zLFxuICAgICAgb3B0aW9uc0F0TWVkaWFcbiAgICB9ID0gb3B0aW9uc0hhbmRsZXI7XG4gICAgY29uc3Qgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIEF1dG9wbGF5Lmdsb2JhbE9wdGlvbnMpO1xuICAgIGNvbnN0IGFsbE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UsIHVzZXJPcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9uc0F0TWVkaWEoYWxsT3B0aW9ucyk7XG4gICAgaWYgKGVtYmxhQXBpLnNjcm9sbFNuYXBMaXN0KCkubGVuZ3RoIDw9IDEpIHJldHVybjtcbiAgICBqdW1wID0gb3B0aW9ucy5qdW1wO1xuICAgIGRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIGRlbGF5ID0gbm9ybWFsaXplRGVsYXkoZW1ibGFBcGksIG9wdGlvbnMuZGVsYXkpO1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50U3RvcmUsXG4gICAgICBvd25lckRvY3VtZW50XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIWVtYmxhQXBpLmludGVybmFsRW5naW5lKCkub3B0aW9ucy53YXRjaERyYWc7XG4gICAgY29uc3Qgcm9vdCA9IGdldEF1dG9wbGF5Um9vdE5vZGUoZW1ibGFBcGksIG9wdGlvbnMucm9vdE5vZGUpO1xuICAgIGV2ZW50U3RvcmUuYWRkKG93bmVyRG9jdW1lbnQsICd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgaWYgKGlzRHJhZ2dhYmxlKSB7XG4gICAgICBlbWJsYUFwaS5vbigncG9pbnRlckRvd24nLCBwb2ludGVyRG93bik7XG4gICAgfVxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiAhb3B0aW9ucy5zdG9wT25JbnRlcmFjdGlvbikge1xuICAgICAgZW1ibGFBcGkub24oJ3BvaW50ZXJVcCcsIHBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0b3BPbk1vdXNlRW50ZXIpIHtcbiAgICAgIGV2ZW50U3RvcmUuYWRkKHJvb3QsICdtb3VzZWVudGVyJywgbW91c2VFbnRlcik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0b3BPbk1vdXNlRW50ZXIgJiYgIW9wdGlvbnMuc3RvcE9uSW50ZXJhY3Rpb24pIHtcbiAgICAgIGV2ZW50U3RvcmUuYWRkKHJvb3QsICdtb3VzZWxlYXZlJywgbW91c2VMZWF2ZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0b3BPbkZvY3VzSW4pIHtcbiAgICAgIGVtYmxhQXBpLm9uKCdzbGlkZUZvY3VzU3RhcnQnLCBzdG9wQXV0b3BsYXkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdG9wT25Gb2N1c0luICYmICFvcHRpb25zLnN0b3BPbkludGVyYWN0aW9uKSB7XG4gICAgICBldmVudFN0b3JlLmFkZChlbWJsYUFwaS5jb250YWluZXJOb2RlKCksICdmb2N1c291dCcsIHN0YXJ0QXV0b3BsYXkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wbGF5T25Jbml0KSBzdGFydEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBlbWJsYUFwaS5vZmYoJ3BvaW50ZXJEb3duJywgcG9pbnRlckRvd24pLm9mZigncG9pbnRlclVwJywgcG9pbnRlclVwKS5vZmYoJ3NsaWRlRm9jdXNTdGFydCcsIHN0b3BBdXRvcGxheSk7XG4gICAgc3RvcEF1dG9wbGF5KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBhdXRvcGxheUFjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHNldFRpbWVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyV2luZG93XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgb3duZXJXaW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIHRpbWVySWQgPSBvd25lcldpbmRvdy5zZXRUaW1lb3V0KG5leHQsIGRlbGF5W2VtYmxhQXBpLnNlbGVjdGVkU2Nyb2xsU25hcCgpXSk7XG4gICAgdGltZXJTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBlbWJsYUFwaS5lbWl0KCdhdXRvcGxheTp0aW1lcnNldCcpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJXaW5kb3dcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBvd25lcldpbmRvdy5jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgdGltZXJJZCA9IDA7XG4gICAgdGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgIGVtYmxhQXBpLmVtaXQoJ2F1dG9wbGF5OnRpbWVyc3RvcHBlZCcpO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0QXV0b3BsYXkoKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGlmIChkb2N1bWVudElzSGlkZGVuKCkpIHtcbiAgICAgIHBsYXlPbkRvY3VtZW50VmlzaWJsZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghYXV0b3BsYXlBY3RpdmUpIGVtYmxhQXBpLmVtaXQoJ2F1dG9wbGF5OnBsYXknKTtcbiAgICBzZXRUaW1lcigpO1xuICAgIGF1dG9wbGF5QWN0aXZlID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wQXV0b3BsYXkoKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGlmIChhdXRvcGxheUFjdGl2ZSkgZW1ibGFBcGkuZW1pdCgnYXV0b3BsYXk6c3RvcCcpO1xuICAgIGNsZWFyVGltZXIoKTtcbiAgICBhdXRvcGxheUFjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKGRvY3VtZW50SXNIaWRkZW4oKSkge1xuICAgICAgcGxheU9uRG9jdW1lbnRWaXNpYmxlID0gYXV0b3BsYXlBY3RpdmU7XG4gICAgICByZXR1cm4gc3RvcEF1dG9wbGF5KCk7XG4gICAgfVxuICAgIGlmIChwbGF5T25Eb2N1bWVudFZpc2libGUpIHN0YXJ0QXV0b3BsYXkoKTtcbiAgfVxuICBmdW5jdGlvbiBkb2N1bWVudElzSGlkZGVuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyRG9jdW1lbnRcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJEb3duKCkge1xuICAgIGlmICghbW91c2VJc092ZXIpIHN0b3BBdXRvcGxheSgpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJVcCgpIHtcbiAgICBpZiAoIW1vdXNlSXNPdmVyKSBzdGFydEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gbW91c2VFbnRlcigpIHtcbiAgICBtb3VzZUlzT3ZlciA9IHRydWU7XG4gICAgc3RvcEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gbW91c2VMZWF2ZSgpIHtcbiAgICBtb3VzZUlzT3ZlciA9IGZhbHNlO1xuICAgIHN0YXJ0QXV0b3BsYXkoKTtcbiAgfVxuICBmdW5jdGlvbiBwbGF5KGp1bXBPdmVycmlkZSkge1xuICAgIGlmICh0eXBlb2YganVtcE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJykganVtcCA9IGp1bXBPdmVycmlkZTtcbiAgICBzdGFydEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoYXV0b3BsYXlBY3RpdmUpIHN0b3BBdXRvcGxheSgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmIChhdXRvcGxheUFjdGl2ZSkgc3RhcnRBdXRvcGxheSgpO1xuICB9XG4gIGZ1bmN0aW9uIGlzUGxheWluZygpIHtcbiAgICByZXR1cm4gYXV0b3BsYXlBY3RpdmU7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmRleFxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IGluZGV4LmNsb25lKCkuYWRkKDEpLmdldCgpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGVtYmxhQXBpLnNjcm9sbFNuYXBMaXN0KCkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBraWxsID0gb3B0aW9ucy5zdG9wT25MYXN0U25hcCAmJiBuZXh0SW5kZXggPT09IGxhc3RJbmRleDtcbiAgICBpZiAoZW1ibGFBcGkuY2FuU2Nyb2xsTmV4dCgpKSB7XG4gICAgICBlbWJsYUFwaS5zY3JvbGxOZXh0KGp1bXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWJsYUFwaS5zY3JvbGxUbygwLCBqdW1wKTtcbiAgICB9XG4gICAgZW1ibGFBcGkuZW1pdCgnYXV0b3BsYXk6c2VsZWN0Jyk7XG4gICAgaWYgKGtpbGwpIHJldHVybiBzdG9wQXV0b3BsYXkoKTtcbiAgICBzdGFydEF1dG9wbGF5KCk7XG4gIH1cbiAgZnVuY3Rpb24gdGltZVVudGlsTmV4dCgpIHtcbiAgICBpZiAoIXRpbWVyU3RhcnRUaW1lKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjdXJyZW50RGVsYXkgPSBkZWxheVtlbWJsYUFwaS5zZWxlY3RlZFNjcm9sbFNuYXAoKV07XG4gICAgY29uc3QgdGltZVBhc3RTaW5jZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aW1lclN0YXJ0VGltZTtcbiAgICByZXR1cm4gY3VycmVudERlbGF5IC0gdGltZVBhc3RTaW5jZVN0YXJ0O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbmFtZTogJ2F1dG9wbGF5JyxcbiAgICBvcHRpb25zOiB1c2VyT3B0aW9ucyxcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgcGxheSxcbiAgICBzdG9wLFxuICAgIHJlc2V0LFxuICAgIGlzUGxheWluZyxcbiAgICB0aW1lVW50aWxOZXh0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuQXV0b3BsYXkuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgQXV0b3BsYXkgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1ibGEtY2Fyb3VzZWwtYXV0b3BsYXkuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js\n\n}");

/***/ }),

/***/ "./node_modules/embla-carousel-class-names/esm/embla-carousel-class-names.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/embla-carousel-class-names/esm/embla-carousel-class-names.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ClassNames)\n/* harmony export */ });\nconst defaultOptions = {\n  active: true,\n  breakpoints: {},\n  snapped: \"is-snapped\",\n  inView: \"is-in-view\",\n  draggable: \"is-draggable\",\n  dragging: \"is-dragging\",\n  loop: \"is-loop\"\n};\nfunction normalizeClassNames(classNames) {\n  const normalized = Array.isArray(classNames) ? classNames : [classNames];\n  return normalized.filter(Boolean);\n}\nfunction removeClass(node, classNames) {\n  if (!node || !classNames.length)\n    return;\n  node.classList.remove(...classNames);\n}\nfunction addClass(node, classNames) {\n  if (!node || !classNames.length)\n    return;\n  node.classList.add(...classNames);\n}\nfunction ClassNames(userOptions = {}) {\n  let options;\n  let emblaApi;\n  let root;\n  let slides;\n  let snappedIndexes = [];\n  let inViewIndexes = [];\n  const selectedEvents = [\"select\"];\n  const draggingEvents = [\"pointerDown\", \"pointerUp\"];\n  const inViewEvents = [\"slidesInView\"];\n  const classNames = {\n    snapped: [],\n    inView: [],\n    draggable: [],\n    dragging: [],\n    loop: []\n  };\n  function init(emblaApiInstance, optionsHandler) {\n    emblaApi = emblaApiInstance;\n    const {\n      mergeOptions,\n      optionsAtMedia\n    } = optionsHandler;\n    const optionsBase = mergeOptions(defaultOptions, ClassNames.globalOptions);\n    const allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    root = emblaApi.rootNode();\n    slides = emblaApi.slideNodes();\n    const {\n      watchDrag,\n      loop\n    } = emblaApi.internalEngine().options;\n    const isDraggable = !!watchDrag;\n    if (options.loop && loop) {\n      classNames.loop = normalizeClassNames(options.loop);\n      addClass(root, classNames.loop);\n    }\n    if (options.draggable && isDraggable) {\n      classNames.draggable = normalizeClassNames(options.draggable);\n      addClass(root, classNames.draggable);\n    }\n    if (options.dragging) {\n      classNames.dragging = normalizeClassNames(options.dragging);\n      draggingEvents.forEach((evt) => emblaApi.on(evt, toggleDraggingClass));\n    }\n    if (options.snapped) {\n      classNames.snapped = normalizeClassNames(options.snapped);\n      selectedEvents.forEach((evt) => emblaApi.on(evt, toggleSnappedClasses));\n      toggleSnappedClasses();\n    }\n    if (options.inView) {\n      classNames.inView = normalizeClassNames(options.inView);\n      inViewEvents.forEach((evt) => emblaApi.on(evt, toggleInViewClasses));\n      toggleInViewClasses();\n    }\n  }\n  function destroy() {\n    draggingEvents.forEach((evt) => emblaApi.off(evt, toggleDraggingClass));\n    selectedEvents.forEach((evt) => emblaApi.off(evt, toggleSnappedClasses));\n    inViewEvents.forEach((evt) => emblaApi.off(evt, toggleInViewClasses));\n    removeClass(root, classNames.loop);\n    removeClass(root, classNames.draggable);\n    removeClass(root, classNames.dragging);\n    toggleSlideClasses([], snappedIndexes, classNames.snapped);\n    toggleSlideClasses([], inViewIndexes, classNames.inView);\n    Object.keys(classNames).forEach((classNameKey) => {\n      const key = classNameKey;\n      classNames[key] = [];\n    });\n  }\n  function toggleDraggingClass(_, evt) {\n    const toggleClass = evt === \"pointerDown\" ? addClass : removeClass;\n    toggleClass(root, classNames.dragging);\n  }\n  function toggleSlideClasses(addClassIndexes = [], removeClassIndexes = [], classNames2) {\n    const removeClassSlides = removeClassIndexes.map((index) => slides[index]);\n    const addClassSlides = addClassIndexes.map((index) => slides[index]);\n    removeClassSlides.forEach((slide) => removeClass(slide, classNames2));\n    addClassSlides.forEach((slide) => addClass(slide, classNames2));\n    return addClassIndexes;\n  }\n  function toggleSnappedClasses() {\n    const {\n      slideRegistry\n    } = emblaApi.internalEngine();\n    const newSnappedIndexes = slideRegistry[emblaApi.selectedScrollSnap()];\n    snappedIndexes = toggleSlideClasses(newSnappedIndexes, snappedIndexes, classNames.snapped);\n  }\n  function toggleInViewClasses() {\n    const newInViewIndexes = emblaApi.slidesInView();\n    inViewIndexes = toggleSlideClasses(newInViewIndexes, inViewIndexes, classNames.inView);\n  }\n  const self = {\n    name: \"classNames\",\n    options: userOptions,\n    init,\n    destroy\n  };\n  return self;\n}\nClassNames.globalOptions = void 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtY2xhc3MtbmFtZXMvZXNtL2VtYmxhLWNhcm91c2VsLWNsYXNzLW5hbWVzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTSxpQkFBaUI7QUFBQSxFQUNyQixRQUFRO0FBQUEsRUFDUixhQUFhLENBQUM7QUFBQSxFQUNkLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFdBQVc7QUFBQSxFQUNYLFVBQVU7QUFBQSxFQUNWLE1BQU07QUFDUjtBQUVBLFNBQVMsb0JBQW9CLFlBQVk7QUFDdkMsUUFBTSxhQUFhLE1BQU0sUUFBUSxVQUFVLElBQUksYUFBYSxDQUFDLFVBQVU7QUFDdkUsU0FBTyxXQUFXLE9BQU8sT0FBTztBQUNsQztBQUNBLFNBQVMsWUFBWSxNQUFNLFlBQVk7QUFDckMsTUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXO0FBQVE7QUFDakMsT0FBSyxVQUFVLE9BQU8sR0FBRyxVQUFVO0FBQ3JDO0FBQ0EsU0FBUyxTQUFTLE1BQU0sWUFBWTtBQUNsQyxNQUFJLENBQUMsUUFBUSxDQUFDLFdBQVc7QUFBUTtBQUNqQyxPQUFLLFVBQVUsSUFBSSxHQUFHLFVBQVU7QUFDbEM7QUFFQSxTQUFTLFdBQVcsY0FBYyxDQUFDLEdBQUc7QUFDcEMsTUFBSTtBQUNKLE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSTtBQUNKLE1BQUksaUJBQWlCLENBQUM7QUFDdEIsTUFBSSxnQkFBZ0IsQ0FBQztBQUNyQixRQUFNLGlCQUFpQixDQUFDLFFBQVE7QUFDaEMsUUFBTSxpQkFBaUIsQ0FBQyxlQUFlLFdBQVc7QUFDbEQsUUFBTSxlQUFlLENBQUMsY0FBYztBQUNwQyxRQUFNLGFBQWE7QUFBQSxJQUNqQixTQUFTLENBQUM7QUFBQSxJQUNWLFFBQVEsQ0FBQztBQUFBLElBQ1QsV0FBVyxDQUFDO0FBQUEsSUFDWixVQUFVLENBQUM7QUFBQSxJQUNYLE1BQU0sQ0FBQztBQUFBLEVBQ1Q7QUFDQSxXQUFTLEtBQUssa0JB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QzNGO0FBQ0EsV0FBUyxzQkFBc0I7QUFDN0IsVUFBTSxtQkFBbUIsU0FBUyxhQUFhO0FBQy9DLG9CQUFnQixtQkFBbUIsa0JBQWtCLGVBQWUsV0FBVyxNQUFNO0FBQUEsRUFDdkY7QUFDQSxRQUFNLE9BQU87QUFBQSxJQUNYLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNUO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxXQUFXLGdCQUFnQjtBQUVNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hvcGlmeS1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL2VtYmxhLWNhcm91c2VsLWNsYXNzLW5hbWVzL2VzbS9lbWJsYS1jYXJvdXNlbC1jbGFzcy1uYW1lcy5lc20uanM/ZWNjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWN0aXZlOiB0cnVlLFxuICBicmVha3BvaW50czoge30sXG4gIHNuYXBwZWQ6ICdpcy1zbmFwcGVkJyxcbiAgaW5WaWV3OiAnaXMtaW4tdmlldycsXG4gIGRyYWdnYWJsZTogJ2lzLWRyYWdnYWJsZScsXG4gIGRyYWdnaW5nOiAnaXMtZHJhZ2dpbmcnLFxuICBsb29wOiAnaXMtbG9vcCdcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoY2xhc3NOYW1lcykge1xuICBjb25zdCBub3JtYWxpemVkID0gQXJyYXkuaXNBcnJheShjbGFzc05hbWVzKSA/IGNsYXNzTmFtZXMgOiBbY2xhc3NOYW1lc107XG4gIHJldHVybiBub3JtYWxpemVkLmZpbHRlcihCb29sZWFuKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZXMpIHtcbiAgaWYgKCFub2RlIHx8ICFjbGFzc05hbWVzLmxlbmd0aCkgcmV0dXJuO1xuICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG59XG5mdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbGFzc05hbWVzKSB7XG4gIGlmICghbm9kZSB8fCAhY2xhc3NOYW1lcy5sZW5ndGgpIHJldHVybjtcbiAgbm9kZS5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xufVxuXG5mdW5jdGlvbiBDbGFzc05hbWVzKHVzZXJPcHRpb25zID0ge30pIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGxldCBlbWJsYUFwaTtcbiAgbGV0IHJvb3Q7XG4gIGxldCBzbGlkZXM7XG4gIGxldCBzbmFwcGVkSW5kZXhlcyA9IFtdO1xuICBsZXQgaW5WaWV3SW5kZXhlcyA9IFtdO1xuICBjb25zdCBzZWxlY3RlZEV2ZW50cyA9IFsnc2VsZWN0J107XG4gIGNvbnN0IGRyYWdnaW5nRXZlbnRzID0gWydwb2ludGVyRG93bicsICdwb2ludGVyVXAnXTtcbiAgY29uc3QgaW5WaWV3RXZlbnRzID0gWydzbGlkZXNJblZpZXcnXTtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IHtcbiAgICBzbmFwcGVkOiBbXSxcbiAgICBpblZpZXc6IFtdLFxuICAgIGRyYWdnYWJsZTogW10sXG4gICAgZHJhZ2dpbmc6IFtdLFxuICAgIGxvb3A6IFtdXG4gIH07XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGlJbnN0YW5jZSwgb3B0aW9uc0hhbmRsZXIpIHtcbiAgICBlbWJsYUFwaSA9IGVtYmxhQXBpSW5zdGFuY2U7XG4gICAgY29uc3Qge1xuICAgICAgbWVyZ2VPcHRpb25zLFxuICAgICAgb3B0aW9uc0F0TWVkaWFcbiAgICB9ID0gb3B0aW9uc0hhbmRsZXI7XG4gICAgY29uc3Qgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIENsYXNzTmFtZXMuZ2xvYmFsT3B0aW9ucyk7XG4gICAgY29uc3QgYWxsT3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zQmFzZSwgdXNlck9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zQXRNZWRpYShhbGxPcHRpb25zKTtcbiAgICByb290ID0gZW1ibGFBcGkucm9vdE5vZGUoKTtcbiAgICBzbGlkZXMgPSBlbWJsYUFwaS5zbGlkZU5vZGVzKCk7XG4gICAgY29uc3Qge1xuICAgICAgd2F0Y2hEcmFnLFxuICAgICAgbG9vcFxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpLm9wdGlvbnM7XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXdhdGNoRHJhZztcbiAgICBpZiAob3B0aW9ucy5sb29wICYmIGxvb3ApIHtcbiAgICAgIGNsYXNzTmFtZXMubG9vcCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy5sb29wKTtcbiAgICAgIGFkZENsYXNzKHJvb3QsIGNsYXNzTmFtZXMubG9vcCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRyYWdnYWJsZSAmJiBpc0RyYWdnYWJsZSkge1xuICAgICAgY2xhc3NOYW1lcy5kcmFnZ2FibGUgPSBub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICAgIGFkZENsYXNzKHJvb3QsIGNsYXNzTmFtZXMuZHJhZ2dhYmxlKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZHJhZ2dpbmcpIHtcbiAgICAgIGNsYXNzTmFtZXMuZHJhZ2dpbmcgPSBub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuZHJhZ2dpbmcpO1xuICAgICAgZHJhZ2dpbmdFdmVudHMuZm9yRWFjaChldnQgPT4gZW1ibGFBcGkub24oZXZ0LCB0b2dnbGVEcmFnZ2luZ0NsYXNzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNuYXBwZWQpIHtcbiAgICAgIGNsYXNzTmFtZXMuc25hcHBlZCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy5zbmFwcGVkKTtcbiAgICAgIHNlbGVjdGVkRXZlbnRzLmZvckVhY2goZXZ0ID0+IGVtYmxhQXBpLm9uKGV2dCwgdG9nZ2xlU25hcHBlZENsYXNzZXMpKTtcbiAgICAgIHRvZ2dsZVNuYXBwZWRDbGFzc2VzKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluVmlldykge1xuICAgICAgY2xhc3NOYW1lcy5pblZpZXcgPSBub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuaW5WaWV3KTtcbiAgICAgIGluVmlld0V2ZW50cy5mb3JFYWNoKGV2dCA9PiBlbWJsYUFwaS5vbihldnQsIHRvZ2dsZUluVmlld0NsYXNzZXMpKTtcbiAgICAgIHRvZ2dsZUluVmlld0NsYXNzZXMoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBkcmFnZ2luZ0V2ZW50cy5mb3JFYWNoKGV2dCA9PiBlbWJsYUFwaS5vZmYoZXZ0LCB0b2dnbGVEcmFnZ2luZ0NsYXNzKSk7XG4gICAgc2VsZWN0ZWRFdmVudHMuZm9yRWFjaChldnQgPT4gZW1ibGFBcGkub2ZmKGV2dCwgdG9nZ2xlU25hcHBlZENsYXNzZXMpKTtcbiAgICBpblZpZXdFdmVudHMuZm9yRWFjaChldnQgPT4gZW1ibGFBcGkub2ZmKGV2dCwgdG9nZ2xlSW5WaWV3Q2xhc3NlcykpO1xuICAgIHJlbW92ZUNsYXNzKHJvb3QsIGNsYXNzTmFtZXMubG9vcCk7XG4gICAgcmVtb3ZlQ2xhc3Mocm9vdCwgY2xhc3NOYW1lcy5kcmFnZ2FibGUpO1xuICAgIHJlbW92ZUNsYXNzKHJvb3QsIGNsYXNzTmFtZXMuZHJhZ2dpbmcpO1xuICAgIHRvZ2dsZVNsaWRlQ2xhc3NlcyhbXSwgc25hcHBlZEluZGV4ZXMsIGNsYXNzTmFtZXMuc25hcHBlZCk7XG4gICAgdG9nZ2xlU2xpZGVDbGFzc2VzKFtdLCBpblZpZXdJbmRleGVzLCBjbGFzc05hbWVzLmluVmlldyk7XG4gICAgT2JqZWN0LmtleXMoY2xhc3NOYW1lcykuZm9yRWFjaChjbGFzc05hbWVLZXkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gY2xhc3NOYW1lS2V5O1xuICAgICAgY2xhc3NOYW1lc1trZXldID0gW107XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRHJhZ2dpbmdDbGFzcyhfLCBldnQpIHtcbiAgICBjb25zdCB0b2dnbGVDbGFzcyA9IGV2dCA9PT0gJ3BvaW50ZXJEb3duJyA/IGFkZENsYXNzIDogcmVtb3ZlQ2xhc3M7XG4gICAgdG9nZ2xlQ2xhc3Mocm9vdCwgY2xhc3NOYW1lcy5kcmFnZ2luZyk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlU2xpZGVDbGFzc2VzKGFkZENsYXNzSW5kZXhlcyA9IFtdLCByZW1vdmVDbGFzc0luZGV4ZXMgPSBbXSwgY2xhc3NOYW1lcykge1xuICAgIGNvbnN0IHJlbW92ZUNsYXNzU2xpZGVzID0gcmVtb3ZlQ2xhc3NJbmRleGVzLm1hcChpbmRleCA9PiBzbGlkZXNbaW5kZXhdKTtcbiAgICBjb25zdCBhZGRDbGFzc1NsaWRlcyA9IGFkZENsYXNzSW5kZXhlcy5tYXAoaW5kZXggPT4gc2xpZGVzW2luZGV4XSk7XG4gICAgcmVtb3ZlQ2xhc3NTbGlkZXMuZm9yRWFjaChzbGlkZSA9PiByZW1vdmVDbGFzcyhzbGlkZSwgY2xhc3NOYW1lcykpO1xuICAgIGFkZENsYXNzU2xpZGVzLmZvckVhY2goc2xpZGUgPT4gYWRkQ2xhc3Moc2xpZGUsIGNsYXNzTmFtZXMpKTtcbiAgICByZXR1cm4gYWRkQ2xhc3NJbmRleGVzO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZVNuYXBwZWRDbGFzc2VzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNsaWRlUmVnaXN0cnlcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBuZXdTbmFwcGVkSW5kZXhlcyA9IHNsaWRlUmVnaXN0cnlbZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCldO1xuICAgIHNuYXBwZWRJbmRleGVzID0gdG9nZ2xlU2xpZGVDbGFzc2VzKG5ld1NuYXBwZWRJbmRleGVzLCBzbmFwcGVkSW5kZXhlcywgY2xhc3NOYW1lcy5zbmFwcGVkKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVJblZpZXdDbGFzc2VzKCkge1xuICAgIGNvbnN0IG5ld0luVmlld0luZGV4ZXMgPSBlbWJsYUFwaS5zbGlkZXNJblZpZXcoKTtcbiAgICBpblZpZXdJbmRleGVzID0gdG9nZ2xlU2xpZGVDbGFzc2VzKG5ld0luVmlld0luZGV4ZXMsIGluVmlld0luZGV4ZXMsIGNsYXNzTmFtZXMuaW5WaWV3KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG5hbWU6ICdjbGFzc05hbWVzJyxcbiAgICBvcHRpb25zOiB1c2VyT3B0aW9ucyxcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5DbGFzc05hbWVzLmdsb2JhbE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7IENsYXNzTmFtZXMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1ibGEtY2Fyb3VzZWwtY2xhc3MtbmFtZXMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNsYXNzTmFtZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/embla-carousel-class-names/esm/embla-carousel-class-names.esm.js\n\n}");

/***/ }),

/***/ "./node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fade)\n/* harmony export */ });\nfunction clampNumber(number, min, max) {\n  return Math.min(Math.max(number, min), max);\n}\nfunction isNumber(value) {\n  return typeof value === \"number\" && !isNaN(value);\n}\nfunction Fade(userOptions = {}) {\n  const fullOpacity = 1;\n  const noOpacity = 0;\n  const fadeFriction = 0.68;\n  let emblaApi;\n  let opacities = [];\n  let fadeToNextDistance;\n  let distanceFromPointerDown = 0;\n  let fadeVelocity = 0;\n  let progress = 0;\n  let shouldFadePair = false;\n  let defaultSettledBehaviour;\n  let defaultProgressBehaviour;\n  function init(emblaApiInstance) {\n    emblaApi = emblaApiInstance;\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    const {\n      scrollBody,\n      containerRect,\n      axis\n    } = emblaApi.internalEngine();\n    const containerSize = axis.measureSize(containerRect);\n    fadeToNextDistance = clampNumber(containerSize * 0.75, 200, 500);\n    shouldFadePair = false;\n    opacities = emblaApi.scrollSnapList().map((_, index) => index === selectedSnap ? fullOpacity : noOpacity);\n    defaultSettledBehaviour = scrollBody.settled;\n    defaultProgressBehaviour = emblaApi.scrollProgress;\n    scrollBody.settled = settled;\n    emblaApi.scrollProgress = scrollProgress;\n    emblaApi.on(\"select\", select).on(\"slideFocus\", fadeToSelectedSnapInstantly).on(\"pointerDown\", pointerDown).on(\"pointerUp\", pointerUp);\n    disableScroll();\n    fadeToSelectedSnapInstantly();\n  }\n  function destroy() {\n    const {\n      scrollBody\n    } = emblaApi.internalEngine();\n    scrollBody.settled = defaultSettledBehaviour;\n    emblaApi.scrollProgress = defaultProgressBehaviour;\n    emblaApi.off(\"select\", select).off(\"slideFocus\", fadeToSelectedSnapInstantly).off(\"pointerDown\", pointerDown).off(\"pointerUp\", pointerUp);\n    emblaApi.slideNodes().forEach((slideNode) => {\n      const slideStyle = slideNode.style;\n      slideStyle.opacity = \"\";\n      slideStyle.transform = \"\";\n      slideStyle.pointerEvents = \"\";\n      if (!slideNode.getAttribute(\"style\"))\n        slideNode.removeAttribute(\"style\");\n    });\n  }\n  function fadeToSelectedSnapInstantly() {\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    setOpacities(selectedSnap, fullOpacity);\n  }\n  function pointerUp() {\n    shouldFadePair = false;\n  }\n  function pointerDown() {\n    shouldFadePair = false;\n    distanceFromPointerDown = 0;\n    fadeVelocity = 0;\n  }\n  function select() {\n    const duration = emblaApi.internalEngine().scrollBody.duration();\n    fadeVelocity = duration ? 0 : fullOpacity;\n    shouldFadePair = true;\n    if (!duration)\n      fadeToSelectedSnapInstantly();\n  }\n  function getSlideTransform(position) {\n    const {\n      axis\n    } = emblaApi.internalEngine();\n    const translateAxis = axis.scroll.toUpperCase();\n    return `translate${translateAxis}(${axis.direction(position)}px)`;\n  }\n  function disableScroll() {\n    const {\n      translate,\n      slideLooper\n    } = emblaApi.internalEngine();\n    translate.clear();\n    translate.toggleActive(false);\n    slideLooper.loopPoints.forEach(({\n      translate: translate2\n    }) => {\n      translate2.clear();\n      translate2.toggleActive(false);\n    });\n  }\n  function lockExcessiveScroll(fadeIndex) {\n    const {\n      scrollSnaps,\n      location,\n      target\n    } = emblaApi.internalEngine();\n    if (!isNumber(fadeIndex) || opacities[fadeIndex] < 0.5)\n      return;\n    location.set(scrollSnaps[fadeIndex]);\n    target.set(location);\n  }\n  function setOpacities(fadeIndex, velocity) {\n    const scrollSnaps = emblaApi.scrollSnapList();\n    scrollSnaps.forEach((_, indexA) => {\n      const absVelocity = Math.abs(velocity);\n      const currentOpacity = opacities[indexA];\n      const isFadeIndex = indexA === fadeIndex;\n      const nextOpacity = isFadeIndex ? currentOpacity + absVelocity : currentOpacity - absVelocity;\n      const clampedOpacity = clampNumber(nextOpacity, noOpacity, fullOpacity);\n      opacities[indexA] = clampedOpacity;\n      const fadePair = isFadeIndex && shouldFadePair;\n      const indexB = emblaApi.previousScrollSnap();\n      if (fadePair)\n        opacities[indexB] = 1 - clampedOpacity;\n      if (isFadeIndex)\n        setProgress(fadeIndex, clampedOpacity);\n      setOpacity(indexA);\n    });\n  }\n  function setOpacity(index) {\n    const slidesInSnap = emblaApi.internalEngine().slideRegistry[index];\n    const {\n      scrollSnaps,\n      containerRect\n    } = emblaApi.internalEngine();\n    const opacity = opacities[index];\n    slidesInSnap.forEach((slideIndex) => {\n      const slideStyle = emblaApi.slideNodes()[slideIndex].style;\n      const roundedOpacity = parseFloat(opacity.toFixed(2));\n      const hasOpacity = roundedOpacity > noOpacity;\n      const position = hasOpacity ? scrollSnaps[index] : containerRect.width + 2;\n      const transform = getSlideTransform(position);\n      if (hasOpacity)\n        slideStyle.transform = transform;\n      slideStyle.opacity = roundedOpacity.toString();\n      slideStyle.pointerEvents = opacity > 0.5 ? \"auto\" : \"none\";\n      if (!hasOpacity)\n        slideStyle.transform = transform;\n    });\n  }\n  function setProgress(fadeIndex, opacity) {\n    const {\n      index,\n      dragHandler,\n      scrollSnaps\n    } = emblaApi.internalEngine();\n    const pointerDown2 = dragHandler.pointerDown();\n    const snapFraction = 1 / (scrollSnaps.length - 1);\n    let indexA = fadeIndex;\n    let indexB = pointerDown2 ? emblaApi.selectedScrollSnap() : emblaApi.previousScrollSnap();\n    if (pointerDown2 && indexA === indexB) {\n      const reverseSign = Math.sign(distanceFromPointerDown) * -1;\n      indexA = indexB;\n      indexB = index.clone().set(indexB).add(reverseSign).get();\n    }\n    const currentPosition = indexB * snapFraction;\n    const diffPosition = (indexA - indexB) * snapFraction;\n    progress = currentPosition + diffPosition * opacity;\n  }\n  function getFadeIndex() {\n    const {\n      dragHandler,\n      index,\n      scrollBody\n    } = emblaApi.internalEngine();\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    if (!dragHandler.pointerDown())\n      return selectedSnap;\n    const directionSign = Math.sign(scrollBody.velocity());\n    const distanceSign = Math.sign(distanceFromPointerDown);\n    const nextSnap = index.clone().set(selectedSnap).add(directionSign * -1).get();\n    if (!directionSign || !distanceSign)\n      return null;\n    return distanceSign === directionSign ? nextSnap : selectedSnap;\n  }\n  function fade(emblaApi2) {\n    const {\n      dragHandler,\n      scrollBody\n    } = emblaApi2.internalEngine();\n    const pointerDown2 = dragHandler.pointerDown();\n    const velocity = scrollBody.velocity();\n    const duration = scrollBody.duration();\n    const fadeIndex = getFadeIndex();\n    const noFadeIndex = !isNumber(fadeIndex);\n    if (pointerDown2) {\n      if (!velocity)\n        return;\n      distanceFromPointerDown += velocity;\n      fadeVelocity = Math.abs(velocity / fadeToNextDistance);\n      lockExcessiveScroll(fadeIndex);\n    }\n    if (!pointerDown2) {\n      if (!duration || noFadeIndex)\n        return;\n      fadeVelocity += (fullOpacity - opacities[fadeIndex]) / duration;\n      fadeVelocity *= fadeFriction;\n    }\n    if (noFadeIndex)\n      return;\n    setOpacities(fadeIndex, fadeVelocity);\n  }\n  function settled() {\n    const {\n      target,\n      location\n    } = emblaApi.internalEngine();\n    const diffToTarget = target.get() - location.get();\n    const notReachedTarget = Math.abs(diffToTarget) >= 1;\n    const fadeIndex = getFadeIndex();\n    const noFadeIndex = !isNumber(fadeIndex);\n    fade(emblaApi);\n    if (noFadeIndex || notReachedTarget)\n      return false;\n    return opacities[fadeIndex] > 0.999;\n  }\n  function scrollProgress() {\n    return progress;\n  }\n  const self = {\n    name: \"fade\",\n    options: userOptions,\n    init,\n    destroy\n  };\n  return self;\n}\nFade.globalOptions = void 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtZmFkZS9lc20vZW1ibGEtY2Fyb3VzZWwtZmFkZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVMsWUFBWSxRQUFRLEtBQUssS0FBSztBQUNyQyxTQUFPLEtBQUssSUFBSSxLQUFLLElBQUksUUFBUSxHQUFHLEdBQUcsR0FBRztBQUM1QztBQUNBLFNBQVMsU0FBUyxPQUFPO0FBQ3ZCLFNBQU8sT0FBTyxVQUFVLFlBQVksQ0FBQyxNQUFNLEtBQUs7QUFDbEQ7QUFFQSxTQUFTLEtBQUssY0FBYyxDQUFDLEdBQUc7QUFDOUIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sWUFBWTtBQUNsQixRQUFNLGVBQWU7QUFDckIsTUFBSTtBQUNKLE1BQUksWUFBWSxDQUFDO0FBQ2pCLE1BQUk7QUFDSixNQUFJLDBCQUEwQjtBQUM5QixNQUFJLGVBQWU7QUFDbkIsTUFBSSxXQUFXO0FBQ2YsTUFBSSxpQkFBaUI7QUFDckIsTUFBSTtBQUNKLE1BQUk7QUFDSixXQUFTLEtBQUssa0JBQWtCO0FBQzlCLGVBQVc7QUFDWCxVQUFNLGVBQWUsU0FBUyxtQkFBbUI7QUFDakQsVUFBTTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSSxTQUFTLGVBQWU7QUFDNUIsVUFBTSxnQkFBZ0IsS0FBSyxZQUFZLGFBQWE7QUFDcEQseUJBQXFCLFlBQVksZ0JBQWdCLE1BQU0sS0FBSyxHQUFHO0FBQy9ELHFCQUFpQjtBQUNqQixnQkFBWSxTQUFTLGVBQWUsRUFBRSxJQUFJLENBQUMsR0FBRyxVQUFVLFVBQVUsZUFBZSxjQUFjLFNBQVM7QUFDeEcsOEJBQTBCLFdBQVc7QUFDckMsK0JBQTJCLFNBQVM7QUFDcEMsZUFBVyxVQUFVO0FBQ3JCLGFBQVMsaUJBQWlCO0FBQzFCLGFBQVMsR0FBRyxVQUFVLE1BQU0sRUFBRSxHQUFHLGNBQWMsMkJBQTJCLEVBQUUsR0FBRyxlQUFlLFdBQVcsRUFBRSxHQUFHLGFBQWEsU0FBUztBQUNwSSxrQkFBYztBQUNkLGdDQUE0QjtBQUFBLEVBQzlCO0FBQ0EsV0FBUyxVQUFVO0FBQ2pCLFVBQU07QUFBQSxNQUNKO0FBQUEsSUFDRixJQUFJLFNBQVMsZUFBZTtBQUM1QixlQUFXLFVBQVU7QUFDckIsYUFBUyxpQkFBaUI7QUFDMUIsYUFBUyxJQUFJLFVBQVUsTUFBTSxFQUFFLElBQUksY0FBYywyQkFBMkIsRUFBRSxJQUFJLGVBQWUsV0FBVyxFQUFFLElBQUksYUFBYSxTQUFTO0FBQ3hJLGFBQVMsV0FBVyxFQUFFLFFBQVEsZUFBYTtBQUN6QyxZQUFNLGFBQWEsVUFBVTtBQUM3QixpQkFBVyxVQUFVO0FBQ3JCLGlCQUFXLFlBQVk7QUFDdkIsaUJBQVcsZ0JBQWdCO0FBQzNCLFVBQUksQ0FBQyxVQUFVLGFBQWEsT0FBTztBQUFHLGtCQUFVLGdCQUFnQixPQUFPO0FBQUEsSUFDekUsQ0FBQztBQUFBLEVBQ0g7QUFDQSxXQUFTLDhCQUE4QjtBQUNyQyxVQUFNLGVBQWUsU0FBUyxtQkFBbUI7QUFDakQsaUJBQWEsY0FBYyxXQUFXO0FBQUEsRUFDeEM7QUFDQSxXQUFTLFlBQVk7QUFDbkIscUJBQWlCO0FBQUEsRUFDbkI7QUFDQSxXQUFTLGNBQWM7QUFDckIscUJBQWlCO0FBQ2pCLDhCQUEwQjtBQUMxQixtQkFBZTtBQUFBLEVBQ2pCO0FBQ0EsV0FBUyxTQUFTO0FBQ2hCLFVBQU0sV0FBVyxTQUFTLGVBQWUsRUFBRSxXQUFXLFNBQVM7QUFDL0QsbUJBQWUsV0FBVyxJQUFJO0FBQzlCLHFCQUFpQjtBQUNqQixRQUFJLENBQUM7QUFBVSxrQ0FBNEI7QUFBQSxFQUM3QztBQUNBLFdBQVMsa0JBQWtCLFVBQVU7QUFDbkMsVUFBTTtBQUFBLE1BQ0o7QUFBQSxJQUNGLElBQUksU0FBUyxlQUFlO0FBQzVCLFVBQU0sZ0JBQWdCLEtBQUssT0FBTyxZQUFZO0FBQzlDLFdBQU8sWUFBWSxpQkFBaUIsS0FBSyxVQUFVLFFBQVE7QUFBQSxFQUM3RDtBQUNBLFdBQVMsZ0JBQWdCO0FBQ3ZCLFVBQU07QUFBQSxNQUNKO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSSxTQUFTLGVBQWU7QUFDNUIsY0FBVSxNQUFNO0FBQ2hCLGNBQVUsYUFBYSxLQUFLO0FBQzVCLGdCQUFZLFdBQVcsUUFBUSxDQUFDO0FBQUEsTUFDOUIsV0FBQUE7QUFBQSxJQUNGLE1BQU07QUFDSixNQUFBQSxXQUFVLE1BQU07QUFDaEIsTUFBQUEsV0FBVSxhQUFhLEtBQUs7QUFBQSxJQUM5QixDQUFDO0FBQUEsRUFDSDtBQUNBLFdBQVMsb0JBQW9CLFdBQVc7QUFDdEMsVUFBTTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSSxTQUFTLGVBQWU7QUFDNUIsUUFBSSxDQUFDLFNBQVMsU0FBUyxLQUFLLFVBQVUsU0FBUyxJQUFJO0FBQUs7QUFDeEQsYUFBUyxJQUFJLFlBQVksU0FBUyxDQUFDO0FBQ25DLFdBQU8sSUFBSSxRQUFRO0FBQUEsRUFDckI7QUFDQSxXQUFTLGFBQWEsV0FBVyxVQUFVO0FBQ3pDLFVBQU0sY0FBYyxTQUFTLGVBQWU7QUFDNUMsZ0JBQVksUUFBUSxDQUFDLEdBQUcsV0FBVztBQUNqQyxZQUFNLGNBQWMsS0FBSyxJQUFJLFFBQVE7QUFDckMsWUFBTSxpQkFBaUIsVUFBVSxNQUFNO0FBQ3ZDLFlBQU0sY0FBYyxXQUFXO0FBQy9CLFlBQU0sY0FBYyxjQUFjLGlCQUFpQixjQUFjLGlCQUFpQjtBQUNsRixZQUFNLGlCQUFpQixZQUFZLGFBQWEsV0FBVyxXQUFXO0FBQ3RFLGdCQUFVLE1BQU0sSUFBSTtBQUNwQixZQUFNLFdBQVcsZUFBZTtBQUNoQyxZQUFNLFNBQVMsU0FBUyxtQkFBbUI7QUFDM0MsVUFBSTtBQUFVLGtCQUFVLE1BQU0sSUFBSSxJQUFJO0FBQ3RDLFVBQUk7QUFBYSxvQkFBWSxXQUFXLGNBQWM7QUFDdEQsaUJBQVcsTUFBTTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNIO0FBQ0EsV0FBUyxXQUFXLE9BQU87QUFDekIsVUFBTSxlQUFlLFNBQVMsZUFBZSxFQUFFLGNBQWMsS0FBSztBQUNsRSxVQUFNO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFBQSxJQUNGLElBQUksU0FBUyxlQUFlO0FBQzVCLFVBQU0sVUFBVSxVQUFVLEtBQUs7QUFDL0IsaUJBQWEsUUFBUSxnQkFBYztBQUNqQyxZQUFNLGFBQWEsU0FBUyxXQUFXLEVBQUUsVUFBVSxFQUFFO0FBQ3JELFlBQU0saUJBQWlCLFdBQVcsUUFBUSxRQUFRLENBQUMsQ0FBQztBQUNwRCxZQUFNLGFBQWEsaUJBQWlCO0FBQ3BDLFlBQU0sV0FBVyxhQUFhLFlBQVksS0FBSyxJQUFJLGNBQWMsUUFBUTtBQUN6RSxZQUFNLFlBQVksa0JBQWtCLFFBQVE7QUFDNUMsVUFBSTtBQUFZLG1CQUFXLFlBQVk7QUFDdkMsaUJBQVcsVUFBVSxlQUFlLFNBQVM7QUFDN0MsaUJBQVcsZ0JBQWdCLFVBQVUsTUFBTSxTQUFTO0FBQ3BELFVBQUksQ0FBQztBQUFZLG1CQUFXLFlBQVk7QUFBQSxJQUMxQyxDQUFDO0FBQUEsRUFDSDtBQUNBLFdBQVMsWUFBWSxXQUFXLFNBQVM7QUFDdkMsVUFBTTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSSxTQUFTLGVBQWU7QUFDNUIsVUFBTUMsZUFBYyxZQUFZLFlBQVk7QUFDNUMsVUFBTSxlQUFlLEtBQUssWUFBWSxTQUFTO0FBQy9DLFFBQUksU0FBUztBQUNiLFFBQUksU0FBU0EsZUFBYyxTQUFTLG1CQUFtQixJQUFJLFNBQVMsbUJBQW1CO0FBQ3ZGLFFBQUlBLGdCQUFlLFdBQVcsUUFBUTtBQUNwQyxZQUFNLGNBQWMsS0FBSyxLQUFLLHVCQUF1QixJQUFJO0FBQ3pELGVBQVM7QUFDVCxlQUFTLE1BQU0sTUFBTSxFQUFFLElBQUksTUFBTSxFQUFFLElBQUksV0FBVyxFQUFFLElBQUk7QUFBQSxJQUMxRDtBQUNBLFVBQU0sa0JBQWtCLFNBQVM7QUFDakMsVUFBTSxnQkFBZ0IsU0FBUyxVQUFVO0FBQ3pDLGVBQVcsa0JBQWtCLGVBQWU7QUFBQSxFQUM5QztBQUNBLFdBQVMsZUFBZTtBQUN0QixVQUFNO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixJQUFJLFNBQVMsZUFBZTtBQUM1QixVQUFNLGVBQWUsU0FBUyxtQkFBbUI7QUFDakQsUUFBSSxDQUFDLFlBQVksWUFBWTtBQUFHLGFBQU87QUFDdkMsVUFBTSxnQkFBZ0IsS0FBSyxLQUFLLFdBQVcsU0FBUyxDQUFDO0FBQ3JELFVBQU0sZUFBZSxLQUFLLEtBQUssdUJBQXVCO0FBQ3RELFVBQU0sV0FBVyxNQUFNLE1BQU0sRUFBRSxJQUFJLFlBQVksRUFBRSxJQUFJLGdCQUFnQixFQUFFLEVBQUUsSUFBSTtBQUM3RSxRQUFJLENBQUMsaUJBQWlCLENBQUM7QUFBYyxhQUFPO0FBQzVDLFdBQU8saUJBQWlCLGdCQUFnQixXQUFXO0FBQUEsRUFDckQ7QUFDQSxXQUFTLEtBQUtDLFdBQVU7QUFDdEIsVUFBTTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsSUFDRixJQUFJQSxVQUFTLGVBQWU7QUFDNUIsVUFBTUQsZUFBYyxZQUFZLFlBQVk7QUFDNUMsVUFBTSxXQUFXLFdBQVcsU0FBUztBQUNyQyxVQUFNLFdBQVcsV0FBVyxTQUFTO0FBQ3JDLFVBQU0sWUFBWSxhQUFhO0FBQy9CLFVBQU0sY0FBYyxDQUFDLFNBQVMsU0FBUztBQUN2QyxRQUFJQSxjQUFhO0FBQ2YsVUFBSSxDQUFDO0FBQVU7QUFDZixpQ0FBMkI7QUFDM0IscUJBQWUsS0FBSyxJQUFJLFdBQVcsa0JBQWtCO0FBQ3JELDBCQUFvQixTQUFTO0FBQUEsSUFDL0I7QUFDQSxRQUFJLENBQUNBLGNBQWE7QUFDaEIsVUFBSSxDQUFDLFlBQVk7QUFBYTtBQUM5Qix1QkFBaUIsY0FBYyxVQUFVLFNBQVMsS0FBSztBQUN2RCxzQkFBZ0I7QUFBQSxJQUNsQjtBQUNBLFFBQUk7QUFBYTtBQUNqQixpQkFBYSxXQUFXLFlBQVk7QUFBQSxFQUN0QztBQUNBLFdBQVMsVUFBVTtBQUNqQixVQUFNO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFBQSxJQUNGLElBQUksU0FBUyxlQUFlO0FBQzVCLFVBQU0sZUFBZSxPQUFPLElBQUksSUFBSSxTQUFTLElBQUk7QUFDakQsVUFBTSxtQkFBbUIsS0FBSyxJQUFJLFlBQVksS0FBSztBQUNuRCxVQUFNLFlBQVksYUFBYTtBQUMvQixVQUFNLGNBQWMsQ0FBQyxTQUFTLFNBQVM7QUFDdkMsU0FBSyxRQUFRO0FBQ2IsUUFBSSxlQUFlO0FBQWtCLGFBQU87QUFDNUMsV0FBTyxVQUFVLFNBQVMsSUFBSTtBQUFBLEVBQ2hDO0FBQ0EsV0FBUyxpQkFBaUI7QUFDeEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLE9BQU87QUFBQSxJQUNYLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNUO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxLQUFLLGdCQUFnQjtBQUVNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hvcGlmeS1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL2VtYmxhLWNhcm91c2VsLWZhZGUvZXNtL2VtYmxhLWNhcm91c2VsLWZhZGUuZXNtLmpzPzBiNjgiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY2xhbXBOdW1iZXIobnVtYmVyLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtYmVyLCBtaW4pLCBtYXgpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gRmFkZSh1c2VyT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZ1bGxPcGFjaXR5ID0gMTtcbiAgY29uc3Qgbm9PcGFjaXR5ID0gMDtcbiAgY29uc3QgZmFkZUZyaWN0aW9uID0gMC42ODtcbiAgbGV0IGVtYmxhQXBpO1xuICBsZXQgb3BhY2l0aWVzID0gW107XG4gIGxldCBmYWRlVG9OZXh0RGlzdGFuY2U7XG4gIGxldCBkaXN0YW5jZUZyb21Qb2ludGVyRG93biA9IDA7XG4gIGxldCBmYWRlVmVsb2NpdHkgPSAwO1xuICBsZXQgcHJvZ3Jlc3MgPSAwO1xuICBsZXQgc2hvdWxkRmFkZVBhaXIgPSBmYWxzZTtcbiAgbGV0IGRlZmF1bHRTZXR0bGVkQmVoYXZpb3VyO1xuICBsZXQgZGVmYXVsdFByb2dyZXNzQmVoYXZpb3VyO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpSW5zdGFuY2UpIHtcbiAgICBlbWJsYUFwaSA9IGVtYmxhQXBpSW5zdGFuY2U7XG4gICAgY29uc3Qgc2VsZWN0ZWRTbmFwID0gZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsQm9keSxcbiAgICAgIGNvbnRhaW5lclJlY3QsXG4gICAgICBheGlzXG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGF4aXMubWVhc3VyZVNpemUoY29udGFpbmVyUmVjdCk7XG4gICAgZmFkZVRvTmV4dERpc3RhbmNlID0gY2xhbXBOdW1iZXIoY29udGFpbmVyU2l6ZSAqIDAuNzUsIDIwMCwgNTAwKTtcbiAgICBzaG91bGRGYWRlUGFpciA9IGZhbHNlO1xuICAgIG9wYWNpdGllcyA9IGVtYmxhQXBpLnNjcm9sbFNuYXBMaXN0KCkubWFwKChfLCBpbmRleCkgPT4gaW5kZXggPT09IHNlbGVjdGVkU25hcCA/IGZ1bGxPcGFjaXR5IDogbm9PcGFjaXR5KTtcbiAgICBkZWZhdWx0U2V0dGxlZEJlaGF2aW91ciA9IHNjcm9sbEJvZHkuc2V0dGxlZDtcbiAgICBkZWZhdWx0UHJvZ3Jlc3NCZWhhdmlvdXIgPSBlbWJsYUFwaS5zY3JvbGxQcm9ncmVzcztcbiAgICBzY3JvbGxCb2R5LnNldHRsZWQgPSBzZXR0bGVkO1xuICAgIGVtYmxhQXBpLnNjcm9sbFByb2dyZXNzID0gc2Nyb2xsUHJvZ3Jlc3M7XG4gICAgZW1ibGFBcGkub24oJ3NlbGVjdCcsIHNlbGVjdCkub24oJ3NsaWRlRm9jdXMnLCBmYWRlVG9TZWxlY3RlZFNuYXBJbnN0YW50bHkpLm9uKCdwb2ludGVyRG93bicsIHBvaW50ZXJEb3duKS5vbigncG9pbnRlclVwJywgcG9pbnRlclVwKTtcbiAgICBkaXNhYmxlU2Nyb2xsKCk7XG4gICAgZmFkZVRvU2VsZWN0ZWRTbmFwSW5zdGFudGx5KCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxCb2R5XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgc2Nyb2xsQm9keS5zZXR0bGVkID0gZGVmYXVsdFNldHRsZWRCZWhhdmlvdXI7XG4gICAgZW1ibGFBcGkuc2Nyb2xsUHJvZ3Jlc3MgPSBkZWZhdWx0UHJvZ3Jlc3NCZWhhdmlvdXI7XG4gICAgZW1ibGFBcGkub2ZmKCdzZWxlY3QnLCBzZWxlY3QpLm9mZignc2xpZGVGb2N1cycsIGZhZGVUb1NlbGVjdGVkU25hcEluc3RhbnRseSkub2ZmKCdwb2ludGVyRG93bicsIHBvaW50ZXJEb3duKS5vZmYoJ3BvaW50ZXJVcCcsIHBvaW50ZXJVcCk7XG4gICAgZW1ibGFBcGkuc2xpZGVOb2RlcygpLmZvckVhY2goc2xpZGVOb2RlID0+IHtcbiAgICAgIGNvbnN0IHNsaWRlU3R5bGUgPSBzbGlkZU5vZGUuc3R5bGU7XG4gICAgICBzbGlkZVN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgIHNsaWRlU3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICBzbGlkZVN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIGlmICghc2xpZGVOb2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkgc2xpZGVOb2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmYWRlVG9TZWxlY3RlZFNuYXBJbnN0YW50bHkoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRTbmFwID0gZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgc2V0T3BhY2l0aWVzKHNlbGVjdGVkU25hcCwgZnVsbE9wYWNpdHkpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJVcCgpIHtcbiAgICBzaG91bGRGYWRlUGFpciA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJEb3duKCkge1xuICAgIHNob3VsZEZhZGVQYWlyID0gZmFsc2U7XG4gICAgZGlzdGFuY2VGcm9tUG9pbnRlckRvd24gPSAwO1xuICAgIGZhZGVWZWxvY2l0eSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKS5zY3JvbGxCb2R5LmR1cmF0aW9uKCk7XG4gICAgZmFkZVZlbG9jaXR5ID0gZHVyYXRpb24gPyAwIDogZnVsbE9wYWNpdHk7XG4gICAgc2hvdWxkRmFkZVBhaXIgPSB0cnVlO1xuICAgIGlmICghZHVyYXRpb24pIGZhZGVUb1NlbGVjdGVkU25hcEluc3RhbnRseSgpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNsaWRlVHJhbnNmb3JtKHBvc2l0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXhpc1xuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZUF4aXMgPSBheGlzLnNjcm9sbC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBgdHJhbnNsYXRlJHt0cmFuc2xhdGVBeGlzfSgke2F4aXMuZGlyZWN0aW9uKHBvc2l0aW9uKX1weClgO1xuICB9XG4gIGZ1bmN0aW9uIGRpc2FibGVTY3JvbGwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNsYXRlLFxuICAgICAgc2xpZGVMb29wZXJcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICB0cmFuc2xhdGUuY2xlYXIoKTtcbiAgICB0cmFuc2xhdGUudG9nZ2xlQWN0aXZlKGZhbHNlKTtcbiAgICBzbGlkZUxvb3Blci5sb29wUG9pbnRzLmZvckVhY2goKHtcbiAgICAgIHRyYW5zbGF0ZVxuICAgIH0pID0+IHtcbiAgICAgIHRyYW5zbGF0ZS5jbGVhcigpO1xuICAgICAgdHJhbnNsYXRlLnRvZ2dsZUFjdGl2ZShmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbG9ja0V4Y2Vzc2l2ZVNjcm9sbChmYWRlSW5kZXgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxTbmFwcyxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGFyZ2V0XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgaWYgKCFpc051bWJlcihmYWRlSW5kZXgpIHx8IG9wYWNpdGllc1tmYWRlSW5kZXhdIDwgMC41KSByZXR1cm47XG4gICAgbG9jYXRpb24uc2V0KHNjcm9sbFNuYXBzW2ZhZGVJbmRleF0pO1xuICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHNldE9wYWNpdGllcyhmYWRlSW5kZXgsIHZlbG9jaXR5KSB7XG4gICAgY29uc3Qgc2Nyb2xsU25hcHMgPSBlbWJsYUFwaS5zY3JvbGxTbmFwTGlzdCgpO1xuICAgIHNjcm9sbFNuYXBzLmZvckVhY2goKF8sIGluZGV4QSkgPT4ge1xuICAgICAgY29uc3QgYWJzVmVsb2NpdHkgPSBNYXRoLmFicyh2ZWxvY2l0eSk7XG4gICAgICBjb25zdCBjdXJyZW50T3BhY2l0eSA9IG9wYWNpdGllc1tpbmRleEFdO1xuICAgICAgY29uc3QgaXNGYWRlSW5kZXggPSBpbmRleEEgPT09IGZhZGVJbmRleDtcbiAgICAgIGNvbnN0IG5leHRPcGFjaXR5ID0gaXNGYWRlSW5kZXggPyBjdXJyZW50T3BhY2l0eSArIGFic1ZlbG9jaXR5IDogY3VycmVudE9wYWNpdHkgLSBhYnNWZWxvY2l0eTtcbiAgICAgIGNvbnN0IGNsYW1wZWRPcGFjaXR5ID0gY2xhbXBOdW1iZXIobmV4dE9wYWNpdHksIG5vT3BhY2l0eSwgZnVsbE9wYWNpdHkpO1xuICAgICAgb3BhY2l0aWVzW2luZGV4QV0gPSBjbGFtcGVkT3BhY2l0eTtcbiAgICAgIGNvbnN0IGZhZGVQYWlyID0gaXNGYWRlSW5kZXggJiYgc2hvdWxkRmFkZVBhaXI7XG4gICAgICBjb25zdCBpbmRleEIgPSBlbWJsYUFwaS5wcmV2aW91c1Njcm9sbFNuYXAoKTtcbiAgICAgIGlmIChmYWRlUGFpcikgb3BhY2l0aWVzW2luZGV4Ql0gPSAxIC0gY2xhbXBlZE9wYWNpdHk7XG4gICAgICBpZiAoaXNGYWRlSW5kZXgpIHNldFByb2dyZXNzKGZhZGVJbmRleCwgY2xhbXBlZE9wYWNpdHkpO1xuICAgICAgc2V0T3BhY2l0eShpbmRleEEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNldE9wYWNpdHkoaW5kZXgpIHtcbiAgICBjb25zdCBzbGlkZXNJblNuYXAgPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpLnNsaWRlUmVnaXN0cnlbaW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbFNuYXBzLFxuICAgICAgY29udGFpbmVyUmVjdFxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IG9wYWNpdHkgPSBvcGFjaXRpZXNbaW5kZXhdO1xuICAgIHNsaWRlc0luU25hcC5mb3JFYWNoKHNsaWRlSW5kZXggPT4ge1xuICAgICAgY29uc3Qgc2xpZGVTdHlsZSA9IGVtYmxhQXBpLnNsaWRlTm9kZXMoKVtzbGlkZUluZGV4XS5zdHlsZTtcbiAgICAgIGNvbnN0IHJvdW5kZWRPcGFjaXR5ID0gcGFyc2VGbG9hdChvcGFjaXR5LnRvRml4ZWQoMikpO1xuICAgICAgY29uc3QgaGFzT3BhY2l0eSA9IHJvdW5kZWRPcGFjaXR5ID4gbm9PcGFjaXR5O1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBoYXNPcGFjaXR5ID8gc2Nyb2xsU25hcHNbaW5kZXhdIDogY29udGFpbmVyUmVjdC53aWR0aCArIDI7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRTbGlkZVRyYW5zZm9ybShwb3NpdGlvbik7XG4gICAgICBpZiAoaGFzT3BhY2l0eSkgc2xpZGVTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICBzbGlkZVN0eWxlLm9wYWNpdHkgPSByb3VuZGVkT3BhY2l0eS50b1N0cmluZygpO1xuICAgICAgc2xpZGVTdHlsZS5wb2ludGVyRXZlbnRzID0gb3BhY2l0eSA+IDAuNSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgIGlmICghaGFzT3BhY2l0eSkgc2xpZGVTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0UHJvZ3Jlc3MoZmFkZUluZGV4LCBvcGFjaXR5KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXgsXG4gICAgICBkcmFnSGFuZGxlcixcbiAgICAgIHNjcm9sbFNuYXBzXG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgcG9pbnRlckRvd24gPSBkcmFnSGFuZGxlci5wb2ludGVyRG93bigpO1xuICAgIGNvbnN0IHNuYXBGcmFjdGlvbiA9IDEgLyAoc2Nyb2xsU25hcHMubGVuZ3RoIC0gMSk7XG4gICAgbGV0IGluZGV4QSA9IGZhZGVJbmRleDtcbiAgICBsZXQgaW5kZXhCID0gcG9pbnRlckRvd24gPyBlbWJsYUFwaS5zZWxlY3RlZFNjcm9sbFNuYXAoKSA6IGVtYmxhQXBpLnByZXZpb3VzU2Nyb2xsU25hcCgpO1xuICAgIGlmIChwb2ludGVyRG93biAmJiBpbmRleEEgPT09IGluZGV4Qikge1xuICAgICAgY29uc3QgcmV2ZXJzZVNpZ24gPSBNYXRoLnNpZ24oZGlzdGFuY2VGcm9tUG9pbnRlckRvd24pICogLTE7XG4gICAgICBpbmRleEEgPSBpbmRleEI7XG4gICAgICBpbmRleEIgPSBpbmRleC5jbG9uZSgpLnNldChpbmRleEIpLmFkZChyZXZlcnNlU2lnbikuZ2V0KCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvbiA9IGluZGV4QiAqIHNuYXBGcmFjdGlvbjtcbiAgICBjb25zdCBkaWZmUG9zaXRpb24gPSAoaW5kZXhBIC0gaW5kZXhCKSAqIHNuYXBGcmFjdGlvbjtcbiAgICBwcm9ncmVzcyA9IGN1cnJlbnRQb3NpdGlvbiArIGRpZmZQb3NpdGlvbiAqIG9wYWNpdHk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmFkZUluZGV4KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYWdIYW5kbGVyLFxuICAgICAgaW5kZXgsXG4gICAgICBzY3JvbGxCb2R5XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRTbmFwID0gZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgaWYgKCFkcmFnSGFuZGxlci5wb2ludGVyRG93bigpKSByZXR1cm4gc2VsZWN0ZWRTbmFwO1xuICAgIGNvbnN0IGRpcmVjdGlvblNpZ24gPSBNYXRoLnNpZ24oc2Nyb2xsQm9keS52ZWxvY2l0eSgpKTtcbiAgICBjb25zdCBkaXN0YW5jZVNpZ24gPSBNYXRoLnNpZ24oZGlzdGFuY2VGcm9tUG9pbnRlckRvd24pO1xuICAgIGNvbnN0IG5leHRTbmFwID0gaW5kZXguY2xvbmUoKS5zZXQoc2VsZWN0ZWRTbmFwKS5hZGQoZGlyZWN0aW9uU2lnbiAqIC0xKS5nZXQoKTtcbiAgICBpZiAoIWRpcmVjdGlvblNpZ24gfHwgIWRpc3RhbmNlU2lnbikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGRpc3RhbmNlU2lnbiA9PT0gZGlyZWN0aW9uU2lnbiA/IG5leHRTbmFwIDogc2VsZWN0ZWRTbmFwO1xuICB9XG4gIGZ1bmN0aW9uIGZhZGUoZW1ibGFBcGkpIHtcbiAgICBjb25zdCB7XG4gICAgICBkcmFnSGFuZGxlcixcbiAgICAgIHNjcm9sbEJvZHlcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBwb2ludGVyRG93biA9IGRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCk7XG4gICAgY29uc3QgdmVsb2NpdHkgPSBzY3JvbGxCb2R5LnZlbG9jaXR5KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBzY3JvbGxCb2R5LmR1cmF0aW9uKCk7XG4gICAgY29uc3QgZmFkZUluZGV4ID0gZ2V0RmFkZUluZGV4KCk7XG4gICAgY29uc3Qgbm9GYWRlSW5kZXggPSAhaXNOdW1iZXIoZmFkZUluZGV4KTtcbiAgICBpZiAocG9pbnRlckRvd24pIHtcbiAgICAgIGlmICghdmVsb2NpdHkpIHJldHVybjtcbiAgICAgIGRpc3RhbmNlRnJvbVBvaW50ZXJEb3duICs9IHZlbG9jaXR5O1xuICAgICAgZmFkZVZlbG9jaXR5ID0gTWF0aC5hYnModmVsb2NpdHkgLyBmYWRlVG9OZXh0RGlzdGFuY2UpO1xuICAgICAgbG9ja0V4Y2Vzc2l2ZVNjcm9sbChmYWRlSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoIXBvaW50ZXJEb3duKSB7XG4gICAgICBpZiAoIWR1cmF0aW9uIHx8IG5vRmFkZUluZGV4KSByZXR1cm47XG4gICAgICBmYWRlVmVsb2NpdHkgKz0gKGZ1bGxPcGFjaXR5IC0gb3BhY2l0aWVzW2ZhZGVJbmRleF0pIC8gZHVyYXRpb247XG4gICAgICBmYWRlVmVsb2NpdHkgKj0gZmFkZUZyaWN0aW9uO1xuICAgIH1cbiAgICBpZiAobm9GYWRlSW5kZXgpIHJldHVybjtcbiAgICBzZXRPcGFjaXRpZXMoZmFkZUluZGV4LCBmYWRlVmVsb2NpdHkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldHRsZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgbG9jYXRpb25cbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBkaWZmVG9UYXJnZXQgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBub3RSZWFjaGVkVGFyZ2V0ID0gTWF0aC5hYnMoZGlmZlRvVGFyZ2V0KSA+PSAxO1xuICAgIGNvbnN0IGZhZGVJbmRleCA9IGdldEZhZGVJbmRleCgpO1xuICAgIGNvbnN0IG5vRmFkZUluZGV4ID0gIWlzTnVtYmVyKGZhZGVJbmRleCk7XG4gICAgZmFkZShlbWJsYUFwaSk7XG4gICAgaWYgKG5vRmFkZUluZGV4IHx8IG5vdFJlYWNoZWRUYXJnZXQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb3BhY2l0aWVzW2ZhZGVJbmRleF0gPiAwLjk5OTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxQcm9ncmVzcygpIHtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBuYW1lOiAnZmFkZScsXG4gICAgb3B0aW9uczogdXNlck9wdGlvbnMsXG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuRmFkZS5nbG9iYWxPcHRpb25zID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBGYWRlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmxhLWNhcm91c2VsLWZhZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbInRyYW5zbGF0ZSIsInBvaW50ZXJEb3duIiwiZW1ibGFBcGkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js\n\n}");

/***/ }),

/***/ "./node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction isNumber(subject) {\n  return typeof subject === \"number\";\n}\nfunction isString(subject) {\n  return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n  return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n  return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n  return Math.abs(n);\n}\nfunction mathSign(n) {\n  return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n  return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n  if (valueB === 0 || valueA === 0)\n    return 0;\n  if (mathAbs(valueB) <= mathAbs(valueA))\n    return 0;\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n  return mathAbs(diff / valueB);\n}\nfunction roundToTwoDecimals(num) {\n  return Math.round(num * 100) / 100;\n}\nfunction arrayKeys(array) {\n  return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n  return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n  return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n  return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n  return Array.from(Array(n), (_, i) => startAt + i);\n}\nfunction objectKeys(object) {\n  return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key];\n      const valueB = currentObject[key];\n      const areObjects = isObject(valueA) && isObject(valueB);\n      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n    });\n    return mergedObjects;\n  }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n  return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n  const predefined = {\n    start,\n    center,\n    end\n  };\n  function start() {\n    return 0;\n  }\n  function center(n) {\n    return end(n) / 2;\n  }\n  function end(n) {\n    return viewSize - n;\n  }\n  function measure(n, index) {\n    if (isString(align))\n      return predefined[align](n);\n    return align(viewSize, n, index);\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\nfunction EventStore() {\n  let listeners = [];\n  function add(node, type, handler, options = {\n    passive: true\n  }) {\n    let removeListener;\n    if (\"addEventListener\" in node) {\n      node.addEventListener(type, handler, options);\n      removeListener = () => node.removeEventListener(type, handler, options);\n    } else {\n      const legacyMediaQueryList = node;\n      legacyMediaQueryList.addListener(handler);\n      removeListener = () => legacyMediaQueryList.removeListener(handler);\n    }\n    listeners.push(removeListener);\n    return self;\n  }\n  function clear() {\n    listeners = listeners.filter((remove) => remove());\n  }\n  const self = {\n    add,\n    clear\n  };\n  return self;\n}\nfunction Animations(ownerDocument, ownerWindow, update, render) {\n  const documentVisibleHandler = EventStore();\n  const fixedTimeStep = 1e3 / 60;\n  let lastTimeStamp = null;\n  let accumulatedTime = 0;\n  let animationId = 0;\n  function init() {\n    documentVisibleHandler.add(ownerDocument, \"visibilitychange\", () => {\n      if (ownerDocument.hidden)\n        reset();\n    });\n  }\n  function destroy() {\n    stop();\n    documentVisibleHandler.clear();\n  }\n  function animate(timeStamp) {\n    if (!animationId)\n      return;\n    if (!lastTimeStamp) {\n      lastTimeStamp = timeStamp;\n      update();\n      update();\n    }\n    const timeElapsed = timeStamp - lastTimeStamp;\n    lastTimeStamp = timeStamp;\n    accumulatedTime += timeElapsed;\n    while (accumulatedTime >= fixedTimeStep) {\n      update();\n      accumulatedTime -= fixedTimeStep;\n    }\n    const alpha = accumulatedTime / fixedTimeStep;\n    render(alpha);\n    if (animationId) {\n      animationId = ownerWindow.requestAnimationFrame(animate);\n    }\n  }\n  function start() {\n    if (animationId)\n      return;\n    animationId = ownerWindow.requestAnimationFrame(animate);\n  }\n  function stop() {\n    ownerWindow.cancelAnimationFrame(animationId);\n    lastTimeStamp = null;\n    accumulatedTime = 0;\n    animationId = 0;\n  }\n  function reset() {\n    lastTimeStamp = null;\n    accumulatedTime = 0;\n  }\n  const self = {\n    init,\n    destroy,\n    start,\n    stop,\n    update,\n    render\n  };\n  return self;\n}\nfunction Axis(axis, contentDirection) {\n  const isRightToLeft = contentDirection === \"rtl\";\n  const isVertical = axis === \"y\";\n  const scroll = isVertical ? \"y\" : \"x\";\n  const cross = isVertical ? \"x\" : \"y\";\n  const sign = !isVertical && isRightToLeft ? -1 : 1;\n  const startEdge = getStartEdge();\n  const endEdge = getEndEdge();\n  function measureSize(nodeRect) {\n    const {\n      height,\n      width\n    } = nodeRect;\n    return isVertical ? height : width;\n  }\n  function getStartEdge() {\n    if (isVertical)\n      return \"top\";\n    return isRightToLeft ? \"right\" : \"left\";\n  }\n  function getEndEdge() {\n    if (isVertical)\n      return \"bottom\";\n    return isRightToLeft ? \"left\" : \"right\";\n  }\n  function direction(n) {\n    return n * sign;\n  }\n  const self = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n    direction\n  };\n  return self;\n}\nfunction Limit(min = 0, max = 0) {\n  const length = mathAbs(min - max);\n  function reachedMin(n) {\n    return n < min;\n  }\n  function reachedMax(n) {\n    return n > max;\n  }\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n  function constrain(n) {\n    if (!reachedAny(n))\n      return n;\n    return reachedMin(n) ? min : max;\n  }\n  function removeOffset(n) {\n    if (!length)\n      return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n  const self = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset\n  };\n  return self;\n}\nfunction Counter(max, start, loop) {\n  const {\n    constrain\n  } = Limit(0, max);\n  const loopEnd = max + 1;\n  let counter = withinLimit(start);\n  function withinLimit(n) {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n  }\n  function get() {\n    return counter;\n  }\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n  function add(n) {\n    return clone().set(get() + n);\n  }\n  function clone() {\n    return Counter(max, get(), loop);\n  }\n  const self = {\n    get,\n    set,\n    add,\n    clone\n  };\n  return self;\n}\nfunction DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n  const {\n    cross: crossAxis,\n    direction\n  } = axis;\n  const focusNodes = [\"INPUT\", \"SELECT\", \"TEXTAREA\"];\n  const nonPassiveEvent = {\n    passive: false\n  };\n  const initEvents = EventStore();\n  const dragEvents = EventStore();\n  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n  const snapForceBoost = {\n    mouse: 300,\n    touch: 400\n  };\n  const freeForceBoost = {\n    mouse: 500,\n    touch: 600\n  };\n  const baseSpeed = dragFree ? 43 : 25;\n  let isMoving = false;\n  let startScroll = 0;\n  let startCross = 0;\n  let pointerIsDown = false;\n  let preventScroll = false;\n  let preventClick = false;\n  let isMouse = false;\n  function init(emblaApi) {\n    if (!watchDrag)\n      return;\n    function downIfAllowed(evt) {\n      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt))\n        down(evt);\n    }\n    const node = rootNode;\n    initEvents.add(node, \"dragstart\", (evt) => evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", () => void 0, nonPassiveEvent).add(node, \"touchend\", () => void 0).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n  }\n  function destroy() {\n    initEvents.clear();\n    dragEvents.clear();\n  }\n  function addDragEvents() {\n    const node = isMouse ? ownerDocument : rootNode;\n    dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n  }\n  function isFocusNode(node) {\n    const nodeName = node.nodeName || \"\";\n    return focusNodes.includes(nodeName);\n  }\n  function forceBoost() {\n    const boost = dragFree ? freeForceBoost : snapForceBoost;\n    const type = isMouse ? \"mouse\" : \"touch\";\n    return boost[type];\n  }\n  function allowedForce(force, targetChanged) {\n    const next = index.add(mathSign(force) * -1);\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n    if (dragFree || mathAbs(force) < goToNextThreshold)\n      return baseForce;\n    if (skipSnaps && targetChanged)\n      return baseForce * 0.5;\n    return scrollTarget.byIndex(next.get(), 0).distance;\n  }\n  function down(evt) {\n    const isMouseEvt = isMouseEvent(evt, ownerWindow);\n    isMouse = isMouseEvt;\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n    isMoving = deltaAbs(target.get(), location.get()) >= 2;\n    if (isMouseEvt && evt.button !== 0)\n      return;\n    if (isFocusNode(evt.target))\n      return;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    scrollBody.useFriction(0).useDuration(0);\n    target.set(location);\n    addDragEvents();\n    startScroll = dragTracker.readPoint(evt);\n    startCross = dragTracker.readPoint(evt, crossAxis);\n    eventHandler.emit(\"pointerDown\");\n  }\n  function move(evt) {\n    const isTouchEvt = !isMouseEvent(evt, ownerWindow);\n    if (isTouchEvt && evt.touches.length >= 2)\n      return up(evt);\n    const lastScroll = dragTracker.readPoint(evt);\n    const lastCross = dragTracker.readPoint(evt, crossAxis);\n    const diffScroll = deltaAbs(lastScroll, startScroll);\n    const diffCross = deltaAbs(lastCross, startCross);\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable)\n        return up(evt);\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll)\n        return up(evt);\n    }\n    const diff = dragTracker.pointerMove(evt);\n    if (diffScroll > dragThreshold)\n      preventClick = true;\n    scrollBody.useFriction(0.3).useDuration(0.75);\n    animation.start();\n    target.add(direction(diff));\n    evt.preventDefault();\n  }\n  function up(evt) {\n    const currentLocation = scrollTarget.byDistance(0, false);\n    const targetChanged = currentLocation.index !== index.get();\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n    const force = allowedForce(direction(rawForce), targetChanged);\n    const forceFactor = factorAbs(rawForce, force);\n    const speed = baseSpeed - 10 * forceFactor;\n    const friction = baseFriction + forceFactor / 50;\n    preventScroll = false;\n    pointerIsDown = false;\n    dragEvents.clear();\n    scrollBody.useDuration(speed).useFriction(friction);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    eventHandler.emit(\"pointerUp\");\n  }\n  function click(evt) {\n    if (preventClick) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      preventClick = false;\n    }\n  }\n  function pointerDown() {\n    return pointerIsDown;\n  }\n  const self = {\n    init,\n    destroy,\n    pointerDown\n  };\n  return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n  const logInterval = 170;\n  let startEvent;\n  let lastEvent;\n  function readTime(evt) {\n    return evt.timeStamp;\n  }\n  function readPoint(evt, evtAxis) {\n    const property = evtAxis || axis.scroll;\n    const coord = `client${property === \"x\" ? \"X\" : \"Y\"}`;\n    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n  }\n  function pointerDown(evt) {\n    startEvent = evt;\n    lastEvent = evt;\n    return readPoint(evt);\n  }\n  function pointerMove(evt) {\n    const diff = readPoint(evt) - readPoint(lastEvent);\n    const expired = readTime(evt) - readTime(startEvent) > logInterval;\n    lastEvent = evt;\n    if (expired)\n      startEvent = evt;\n    return diff;\n  }\n  function pointerUp(evt) {\n    if (!startEvent || !lastEvent)\n      return 0;\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n    const diffTime = readTime(evt) - readTime(startEvent);\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n    const force = diffDrag / diffTime;\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n    return isFlick ? force : 0;\n  }\n  const self = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint\n  };\n  return self;\n}\nfunction NodeRects() {\n  function measure(node) {\n    const {\n      offsetTop,\n      offsetLeft,\n      offsetWidth,\n      offsetHeight\n    } = node;\n    const offset = {\n      top: offsetTop,\n      right: offsetLeft + offsetWidth,\n      bottom: offsetTop + offsetHeight,\n      left: offsetLeft,\n      width: offsetWidth,\n      height: offsetHeight\n    };\n    return offset;\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\nfunction PercentOfView(viewSize) {\n  function measure(n) {\n    return viewSize * (n / 100);\n  }\n  const self = {\n    measure\n  };\n  return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n  const observeNodes = [container].concat(slides);\n  let resizeObserver;\n  let containerSize;\n  let slideSizes = [];\n  let destroyed = false;\n  function readSize(node) {\n    return axis.measureSize(nodeRects.measure(node));\n  }\n  function init(emblaApi) {\n    if (!watchResize)\n      return;\n    containerSize = readSize(container);\n    slideSizes = slides.map(readSize);\n    function defaultCallback(entries) {\n      for (const entry of entries) {\n        if (destroyed)\n          return;\n        const isContainer = entry.target === container;\n        const slideIndex = slides.indexOf(entry.target);\n        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n        const newSize = readSize(isContainer ? container : slides[slideIndex]);\n        const diffSize = mathAbs(newSize - lastSize);\n        if (diffSize >= 0.5) {\n          emblaApi.reInit();\n          eventHandler.emit(\"resize\");\n          break;\n        }\n      }\n    }\n    resizeObserver = new ResizeObserver((entries) => {\n      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n        defaultCallback(entries);\n      }\n    });\n    ownerWindow.requestAnimationFrame(() => {\n      observeNodes.forEach((node) => resizeObserver.observe(node));\n    });\n  }\n  function destroy() {\n    destroyed = true;\n    if (resizeObserver)\n      resizeObserver.disconnect();\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\nfunction ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {\n  let scrollVelocity = 0;\n  let scrollDirection = 0;\n  let scrollDuration = baseDuration;\n  let scrollFriction = baseFriction;\n  let rawLocation = location.get();\n  let rawLocationPrevious = 0;\n  function seek() {\n    const displacement = target.get() - location.get();\n    const isInstant = !scrollDuration;\n    let scrollDistance = 0;\n    if (isInstant) {\n      scrollVelocity = 0;\n      previousLocation.set(target);\n      location.set(target);\n      scrollDistance = displacement;\n    } else {\n      previousLocation.set(location);\n      scrollVelocity += displacement / scrollDuration;\n      scrollVelocity *= scrollFriction;\n      rawLocation += scrollVelocity;\n      location.add(scrollVelocity);\n      scrollDistance = rawLocation - rawLocationPrevious;\n    }\n    scrollDirection = mathSign(scrollDistance);\n    rawLocationPrevious = rawLocation;\n    return self;\n  }\n  function settled() {\n    const diff = target.get() - offsetLocation.get();\n    return mathAbs(diff) < 1e-3;\n  }\n  function duration() {\n    return scrollDuration;\n  }\n  function direction() {\n    return scrollDirection;\n  }\n  function velocity() {\n    return scrollVelocity;\n  }\n  function useBaseDuration() {\n    return useDuration(baseDuration);\n  }\n  function useBaseFriction() {\n    return useFriction(baseFriction);\n  }\n  function useDuration(n) {\n    scrollDuration = n;\n    return self;\n  }\n  function useFriction(n) {\n    scrollFriction = n;\n    return self;\n  }\n  const self = {\n    direction,\n    duration,\n    velocity,\n    seek,\n    settled,\n    useBaseFriction,\n    useBaseDuration,\n    useFriction,\n    useDuration\n  };\n  return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n  const pullBackThreshold = percentOfView.measure(10);\n  const edgeOffsetTolerance = percentOfView.measure(50);\n  const frictionLimit = Limit(0.1, 0.99);\n  let disabled = false;\n  function shouldConstrain() {\n    if (disabled)\n      return false;\n    if (!limit.reachedAny(target.get()))\n      return false;\n    if (!limit.reachedAny(location.get()))\n      return false;\n    return true;\n  }\n  function constrain(pointerDown) {\n    if (!shouldConstrain())\n      return;\n    const edge = limit.reachedMin(location.get()) ? \"min\" : \"max\";\n    const diffToEdge = mathAbs(limit[edge] - location.get());\n    const diffToTarget = target.get() - location.get();\n    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n    target.subtract(diffToTarget * friction);\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()));\n      scrollBody.useDuration(25).useBaseFriction();\n    }\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  const self = {\n    shouldConstrain,\n    constrain,\n    toggleActive\n  };\n  return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n  const scrollBounds = Limit(-contentSize + viewSize, 0);\n  const snapsBounded = measureBounded();\n  const scrollContainLimit = findScrollContainLimit();\n  const snapsContained = measureContained();\n  function usePixelTolerance(bound, snap) {\n    return deltaAbs(bound, snap) <= 1;\n  }\n  function findScrollContainLimit() {\n    const startSnap = snapsBounded[0];\n    const endSnap = arrayLast(snapsBounded);\n    const min = snapsBounded.lastIndexOf(startSnap);\n    const max = snapsBounded.indexOf(endSnap) + 1;\n    return Limit(min, max);\n  }\n  function measureBounded() {\n    return snapsAligned.map((snapAligned, index) => {\n      const {\n        min,\n        max\n      } = scrollBounds;\n      const snap = scrollBounds.constrain(snapAligned);\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(snapsAligned, index);\n      if (isFirst)\n        return max;\n      if (isLast)\n        return min;\n      if (usePixelTolerance(min, snap))\n        return min;\n      if (usePixelTolerance(max, snap))\n        return max;\n      return snap;\n    }).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));\n  }\n  function measureContained() {\n    if (contentSize <= viewSize + pixelTolerance)\n      return [scrollBounds.max];\n    if (containScroll === \"keepSnaps\")\n      return snapsBounded;\n    const {\n      min,\n      max\n    } = scrollContainLimit;\n    return snapsBounded.slice(min, max);\n  }\n  const self = {\n    snapsContained,\n    scrollContainLimit\n  };\n  return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n  const max = scrollSnaps[0];\n  const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n  const limit = Limit(min, max);\n  const self = {\n    limit\n  };\n  return self;\n}\nfunction ScrollLooper(contentSize, limit, location, vectors) {\n  const jointSafety = 0.1;\n  const min = limit.min + jointSafety;\n  const max = limit.max + jointSafety;\n  const {\n    reachedMin,\n    reachedMax\n  } = Limit(min, max);\n  function shouldLoop(direction) {\n    if (direction === 1)\n      return reachedMax(location.get());\n    if (direction === -1)\n      return reachedMin(location.get());\n    return false;\n  }\n  function loop(direction) {\n    if (!shouldLoop(direction))\n      return;\n    const loopDistance = contentSize * (direction * -1);\n    vectors.forEach((v) => v.add(loopDistance));\n  }\n  const self = {\n    loop\n  };\n  return self;\n}\nfunction ScrollProgress(limit) {\n  const {\n    max,\n    length\n  } = limit;\n  function get(n) {\n    const currentLocation = n - max;\n    return length ? currentLocation / -length : 0;\n  }\n  const self = {\n    get\n  };\n  return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n  const {\n    startEdge,\n    endEdge\n  } = axis;\n  const {\n    groupSlides\n  } = slidesToScroll;\n  const alignments = measureSizes().map(alignment.measure);\n  const snaps = measureUnaligned();\n  const snapsAligned = measureAligned();\n  function measureSizes() {\n    return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n  }\n  function measureUnaligned() {\n    return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));\n  }\n  function measureAligned() {\n    return groupSlides(snaps).map((g) => g[0]).map((snap, index) => snap + alignments[index]);\n  }\n  const self = {\n    snaps,\n    snapsAligned\n  };\n  return self;\n}\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n  const {\n    groupSlides\n  } = slidesToScroll;\n  const {\n    min,\n    max\n  } = scrollContainLimit;\n  const slideRegistry = createSlideRegistry();\n  function createSlideRegistry() {\n    const groupedSlideIndexes = groupSlides(slideIndexes);\n    const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n    if (scrollSnaps.length === 1)\n      return [slideIndexes];\n    if (doNotContain)\n      return groupedSlideIndexes;\n    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(groups, index);\n      if (isFirst) {\n        const range = arrayLast(groups[0]) + 1;\n        return arrayFromNumber(range);\n      }\n      if (isLast) {\n        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n        return arrayFromNumber(range, arrayLast(groups)[0]);\n      }\n      return group;\n    });\n  }\n  const self = {\n    slideRegistry\n  };\n  return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n  const {\n    reachedAny,\n    removeOffset,\n    constrain\n  } = limit;\n  function minDistance(distances) {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];\n  }\n  function findTargetSnap(target) {\n    const distance = loop ? removeOffset(target) : constrain(target);\n    const ascDiffsToSnaps = scrollSnaps.map((snap, index2) => ({\n      diff: shortcut(snap - distance, 0),\n      index: index2\n    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));\n    const {\n      index\n    } = ascDiffsToSnaps[0];\n    return {\n      index,\n      distance\n    };\n  }\n  function shortcut(target, direction) {\n    const targets = [target, target + contentSize, target - contentSize];\n    if (!loop)\n      return target;\n    if (!direction)\n      return minDistance(targets);\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction);\n    if (matchingTargets.length)\n      return minDistance(matchingTargets);\n    return arrayLast(targets) - contentSize;\n  }\n  function byIndex(index, direction) {\n    const diffToSnap = scrollSnaps[index] - targetVector.get();\n    const distance = shortcut(diffToSnap, direction);\n    return {\n      index,\n      distance\n    };\n  }\n  function byDistance(distance, snap) {\n    const target = targetVector.get() + distance;\n    const {\n      index,\n      distance: targetSnapDistance\n    } = findTargetSnap(target);\n    const reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound)\n      return {\n        index,\n        distance\n      };\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n    const snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index,\n      distance: snapDistance\n    };\n  }\n  const self = {\n    byDistance,\n    byIndex,\n    shortcut\n  };\n  return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {\n  function scrollTo(target) {\n    const distanceDiff = target.distance;\n    const indexDiff = target.index !== indexCurrent.get();\n    targetVector.add(distanceDiff);\n    if (distanceDiff) {\n      if (scrollBody.duration()) {\n        animation.start();\n      } else {\n        animation.update();\n        animation.render(1);\n        animation.update();\n      }\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      eventHandler.emit(\"select\");\n    }\n  }\n  function distance(n, snap) {\n    const target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n  function index(n, direction) {\n    const targetIndex = indexCurrent.clone().set(n);\n    const target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n  const self = {\n    distance,\n    index\n  };\n  return self;\n}\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {\n  const focusListenerOptions = {\n    passive: true,\n    capture: true\n  };\n  let lastTabPressTime = 0;\n  function init(emblaApi) {\n    if (!watchFocus)\n      return;\n    function defaultCallback(index) {\n      const nowTime = new Date().getTime();\n      const diffTime = nowTime - lastTabPressTime;\n      if (diffTime > 10)\n        return;\n      eventHandler.emit(\"slideFocusStart\");\n      root.scrollLeft = 0;\n      const group = slideRegistry.findIndex((group2) => group2.includes(index));\n      if (!isNumber(group))\n        return;\n      scrollBody.useDuration(0);\n      scrollTo.index(group, 0);\n      eventHandler.emit(\"slideFocus\");\n    }\n    eventStore.add(document, \"keydown\", registerTabPress, false);\n    slides.forEach((slide, slideIndex) => {\n      eventStore.add(slide, \"focus\", (evt) => {\n        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {\n          defaultCallback(slideIndex);\n        }\n      }, focusListenerOptions);\n    });\n  }\n  function registerTabPress(event) {\n    if (event.code === \"Tab\")\n      lastTabPressTime = new Date().getTime();\n  }\n  const self = {\n    init\n  };\n  return self;\n}\nfunction Vector1D(initialValue) {\n  let value = initialValue;\n  function get() {\n    return value;\n  }\n  function set(n) {\n    value = normalizeInput(n);\n  }\n  function add(n) {\n    value += normalizeInput(n);\n  }\n  function subtract(n) {\n    value -= normalizeInput(n);\n  }\n  function normalizeInput(n) {\n    return isNumber(n) ? n : n.get();\n  }\n  const self = {\n    get,\n    set,\n    add,\n    subtract\n  };\n  return self;\n}\nfunction Translate(axis, container) {\n  const translate = axis.scroll === \"x\" ? x : y;\n  const containerStyle = container.style;\n  let previousTarget = null;\n  let disabled = false;\n  function x(n) {\n    return `translate3d(${n}px,0px,0px)`;\n  }\n  function y(n) {\n    return `translate3d(0px,${n}px,0px)`;\n  }\n  function to(target) {\n    if (disabled)\n      return;\n    const newTarget = roundToTwoDecimals(axis.direction(target));\n    if (newTarget === previousTarget)\n      return;\n    containerStyle.transform = translate(newTarget);\n    previousTarget = newTarget;\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  function clear() {\n    if (disabled)\n      return;\n    containerStyle.transform = \"\";\n    if (!container.getAttribute(\"style\"))\n      container.removeAttribute(\"style\");\n  }\n  const self = {\n    clear,\n    to,\n    toggleActive\n  };\n  return self;\n}\nfunction SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {\n  const roundingSafety = 0.5;\n  const ascItems = arrayKeys(slideSizesWithGaps);\n  const descItems = arrayKeys(slideSizesWithGaps).reverse();\n  const loopPoints = startPoints().concat(endPoints());\n  function removeSlideSizes(indexes, from) {\n    return indexes.reduce((a, i) => {\n      return a - slideSizesWithGaps[i];\n    }, from);\n  }\n  function slidesInGap(indexes, gap) {\n    return indexes.reduce((a, i) => {\n      const remainingGap = removeSlideSizes(a, gap);\n      return remainingGap > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n  function findSlideBounds(offset) {\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + roundingSafety + offset,\n      end: snap + viewSize - roundingSafety + offset\n    }));\n  }\n  function findLoopPoints(indexes, offset, isEndEdge) {\n    const slideBounds = findSlideBounds(offset);\n    return indexes.map((index) => {\n      const initial = isEndEdge ? 0 : -contentSize;\n      const altered = isEndEdge ? contentSize : 0;\n      const boundEdge = isEndEdge ? \"end\" : \"start\";\n      const loopPoint = slideBounds[index][boundEdge];\n      return {\n        index,\n        loopPoint,\n        slideLocation: Vector1D(-1),\n        translate: Translate(axis, slides[index]),\n        target: () => location.get() > loopPoint ? initial : altered\n      };\n    });\n  }\n  function startPoints() {\n    const gap = scrollSnaps[0];\n    const indexes = slidesInGap(descItems, gap);\n    return findLoopPoints(indexes, contentSize, false);\n  }\n  function endPoints() {\n    const gap = viewSize - scrollSnaps[0] - 1;\n    const indexes = slidesInGap(ascItems, gap);\n    return findLoopPoints(indexes, -contentSize, true);\n  }\n  function canLoop() {\n    return loopPoints.every(({\n      index\n    }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index);\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n    });\n  }\n  function loop() {\n    loopPoints.forEach((loopPoint) => {\n      const {\n        target,\n        translate,\n        slideLocation\n      } = loopPoint;\n      const shiftLocation = target();\n      if (shiftLocation === slideLocation.get())\n        return;\n      translate.to(shiftLocation);\n      slideLocation.set(shiftLocation);\n    });\n  }\n  function clear() {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear());\n  }\n  const self = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints\n  };\n  return self;\n}\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n  let mutationObserver;\n  let destroyed = false;\n  function init(emblaApi) {\n    if (!watchSlides)\n      return;\n    function defaultCallback(mutations) {\n      for (const mutation of mutations) {\n        if (mutation.type === \"childList\") {\n          emblaApi.reInit();\n          eventHandler.emit(\"slidesChanged\");\n          break;\n        }\n      }\n    }\n    mutationObserver = new MutationObserver((mutations) => {\n      if (destroyed)\n        return;\n      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n        defaultCallback(mutations);\n      }\n    });\n    mutationObserver.observe(container, {\n      childList: true\n    });\n  }\n  function destroy() {\n    if (mutationObserver)\n      mutationObserver.disconnect();\n    destroyed = true;\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n  const intersectionEntryMap = {};\n  let inViewCache = null;\n  let notInViewCache = null;\n  let intersectionObserver;\n  let destroyed = false;\n  function init() {\n    intersectionObserver = new IntersectionObserver((entries) => {\n      if (destroyed)\n        return;\n      entries.forEach((entry) => {\n        const index = slides.indexOf(entry.target);\n        intersectionEntryMap[index] = entry;\n      });\n      inViewCache = null;\n      notInViewCache = null;\n      eventHandler.emit(\"slidesInView\");\n    }, {\n      root: container.parentElement,\n      threshold\n    });\n    slides.forEach((slide) => intersectionObserver.observe(slide));\n  }\n  function destroy() {\n    if (intersectionObserver)\n      intersectionObserver.disconnect();\n    destroyed = true;\n  }\n  function createInViewList(inView) {\n    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {\n      const index = parseInt(slideIndex);\n      const {\n        isIntersecting\n      } = intersectionEntryMap[index];\n      const inViewMatch = inView && isIntersecting;\n      const notInViewMatch = !inView && !isIntersecting;\n      if (inViewMatch || notInViewMatch)\n        list.push(index);\n      return list;\n    }, []);\n  }\n  function get(inView = true) {\n    if (inView && inViewCache)\n      return inViewCache;\n    if (!inView && notInViewCache)\n      return notInViewCache;\n    const slideIndexes = createInViewList(inView);\n    if (inView)\n      inViewCache = slideIndexes;\n    if (!inView)\n      notInViewCache = slideIndexes;\n    return slideIndexes;\n  }\n  const self = {\n    init,\n    destroy,\n    get\n  };\n  return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n  const {\n    measureSize,\n    startEdge,\n    endEdge\n  } = axis;\n  const withEdgeGap = slideRects[0] && readEdgeGap;\n  const startGap = measureStartGap();\n  const endGap = measureEndGap();\n  const slideSizes = slideRects.map(measureSize);\n  const slideSizesWithGaps = measureWithGaps();\n  function measureStartGap() {\n    if (!withEdgeGap)\n      return 0;\n    const slideRect = slideRects[0];\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n  }\n  function measureEndGap() {\n    if (!withEdgeGap)\n      return 0;\n    const style = ownerWindow.getComputedStyle(arrayLast(slides));\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n  }\n  function measureWithGaps() {\n    return slideRects.map((rect, index, rects) => {\n      const isFirst = !index;\n      const isLast = arrayIsLastIndex(rects, index);\n      if (isFirst)\n        return slideSizes[index] + startGap;\n      if (isLast)\n        return slideSizes[index] + endGap;\n      return rects[index + 1][startEdge] - rect[startEdge];\n    }).map(mathAbs);\n  }\n  const self = {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  };\n  return self;\n}\nfunction SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n  const {\n    startEdge,\n    endEdge,\n    direction\n  } = axis;\n  const groupByNumber = isNumber(slidesToScroll);\n  function byNumber(array, groupSize) {\n    return arrayKeys(array).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));\n  }\n  function bySize(array) {\n    if (!array.length)\n      return [];\n    return arrayKeys(array).reduce((groups, rectB, index) => {\n      const rectA = arrayLast(groups) || 0;\n      const isFirst = rectA === 0;\n      const isLast = rectB === arrayLastIndex(array);\n      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n      const gapA = !loop && isFirst ? direction(startGap) : 0;\n      const gapB = !loop && isLast ? direction(endGap) : 0;\n      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n      if (index && chunkSize > viewSize + pixelTolerance)\n        groups.push(rectB);\n      if (isLast)\n        groups.push(array.length);\n      return groups;\n    }, []).map((currentSize, index, groups) => {\n      const previousSize = Math.max(groups[index - 1] || 0);\n      return array.slice(previousSize, currentSize);\n    });\n  }\n  function groupSlides(array) {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n  }\n  const self = {\n    groupSlides\n  };\n  return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {\n  const {\n    align,\n    axis: scrollAxis,\n    direction,\n    startIndex,\n    loop,\n    duration,\n    dragFree,\n    dragThreshold,\n    inViewThreshold,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n    watchResize,\n    watchSlides,\n    watchDrag,\n    watchFocus\n  } = options;\n  const pixelTolerance = 2;\n  const nodeRects = NodeRects();\n  const containerRect = nodeRects.measure(container);\n  const slideRects = slides.map(nodeRects.measure);\n  const axis = Axis(scrollAxis, direction);\n  const viewSize = axis.measureSize(containerRect);\n  const percentOfView = PercentOfView(viewSize);\n  const alignment = Alignment(align, viewSize);\n  const containSnaps = !loop && !!containScroll;\n  const readEdgeGap = loop || !!containScroll;\n  const {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n  const {\n    snaps,\n    snapsAligned\n  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  const {\n    snapsContained,\n    scrollContainLimit\n  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n  const {\n    limit\n  } = ScrollLimit(contentSize, scrollSnaps, loop);\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n  const indexPrevious = index.clone();\n  const slideIndexes = arrayKeys(slides);\n  const update = ({\n    dragHandler,\n    scrollBody: scrollBody2,\n    scrollBounds,\n    options: {\n      loop: loop2\n    }\n  }) => {\n    if (!loop2)\n      scrollBounds.constrain(dragHandler.pointerDown());\n    scrollBody2.seek();\n  };\n  const render = ({\n    scrollBody: scrollBody2,\n    translate,\n    location: location2,\n    offsetLocation: offsetLocation2,\n    previousLocation: previousLocation2,\n    scrollLooper,\n    slideLooper,\n    dragHandler,\n    animation: animation2,\n    eventHandler: eventHandler2,\n    scrollBounds,\n    options: {\n      loop: loop2\n    }\n  }, alpha) => {\n    const shouldSettle = scrollBody2.settled();\n    const withinBounds = !scrollBounds.shouldConstrain();\n    const hasSettled = loop2 ? shouldSettle : shouldSettle && withinBounds;\n    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();\n    if (hasSettledAndIdle)\n      animation2.stop();\n    const interpolatedLocation = location2.get() * alpha + previousLocation2.get() * (1 - alpha);\n    offsetLocation2.set(interpolatedLocation);\n    if (loop2) {\n      scrollLooper.loop(scrollBody2.direction());\n      slideLooper.loop();\n    }\n    translate.to(offsetLocation2.get());\n    if (hasSettledAndIdle)\n      eventHandler2.emit(\"settle\");\n    if (!hasSettled)\n      eventHandler2.emit(\"scroll\");\n  };\n  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), (alpha) => render(engine, alpha));\n  const friction = 0.68;\n  const startLocation = scrollSnaps[index.get()];\n  const location = Vector1D(startLocation);\n  const previousLocation = Vector1D(startLocation);\n  const offsetLocation = Vector1D(startLocation);\n  const target = Vector1D(startLocation);\n  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);\n  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n  const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);\n  const scrollProgress = ScrollProgress(limit);\n  const eventStore = EventStore();\n  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n  const {\n    slideRegistry\n  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);\n  const engine = {\n    ownerDocument,\n    ownerWindow,\n    eventHandler,\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n    eventStore,\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    offsetLocation,\n    previousLocation,\n    options,\n    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n    scrollBody,\n    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),\n    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),\n    scrollProgress,\n    scrollSnapList: scrollSnaps.map(scrollProgress.get),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n    slideFocus,\n    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n    slidesInView,\n    slideIndexes,\n    slideRegistry,\n    slidesToScroll,\n    target,\n    translate: Translate(axis, container)\n  };\n  return engine;\n}\nfunction EventHandler() {\n  let listeners = {};\n  let api;\n  function init(emblaApi) {\n    api = emblaApi;\n  }\n  function getListeners(evt) {\n    return listeners[evt] || [];\n  }\n  function emit(evt) {\n    getListeners(evt).forEach((e) => e(api, evt));\n    return self;\n  }\n  function on(evt, cb) {\n    listeners[evt] = getListeners(evt).concat([cb]);\n    return self;\n  }\n  function off(evt, cb) {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb);\n    return self;\n  }\n  function clear() {\n    listeners = {};\n  }\n  const self = {\n    init,\n    emit,\n    off,\n    on,\n    clear\n  };\n  return self;\n}\nconst defaultOptions = {\n  align: \"center\",\n  axis: \"x\",\n  container: null,\n  slides: null,\n  containScroll: \"trimSnaps\",\n  direction: \"ltr\",\n  slidesToScroll: 1,\n  inViewThreshold: 0,\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startIndex: 0,\n  active: true,\n  watchDrag: true,\n  watchResize: true,\n  watchSlides: true,\n  watchFocus: true\n};\nfunction OptionsHandler(ownerWindow) {\n  function mergeOptions(optionsA, optionsB) {\n    return objectsMergeDeep(optionsA, optionsB || {});\n  }\n  function optionsAtMedia(options) {\n    const optionsAtMedia2 = options.breakpoints || {};\n    const matchedMediaOptions = objectKeys(optionsAtMedia2).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia2[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});\n    return mergeOptions(options, matchedMediaOptions);\n  }\n  function optionsMediaQueries(optionsList) {\n    return optionsList.map((options) => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n  }\n  const self = {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  };\n  return self;\n}\nfunction PluginsHandler(optionsHandler) {\n  let activePlugins = [];\n  function init(emblaApi, plugins) {\n    activePlugins = plugins.filter(({\n      options\n    }) => optionsHandler.optionsAtMedia(options).active !== false);\n    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));\n    return plugins.reduce((map, plugin) => Object.assign(map, {\n      [plugin.name]: plugin\n    }), {});\n  }\n  function destroy() {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy());\n  }\n  const self = {\n    init,\n    destroy\n  };\n  return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n  const ownerDocument = root.ownerDocument;\n  const ownerWindow = ownerDocument.defaultView;\n  const optionsHandler = OptionsHandler(ownerWindow);\n  const pluginsHandler = PluginsHandler(optionsHandler);\n  const mediaHandlers = EventStore();\n  const eventHandler = EventHandler();\n  const {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  } = optionsHandler;\n  const {\n    on,\n    off,\n    emit\n  } = eventHandler;\n  const reInit = reActivate;\n  let destroyed = false;\n  let engine;\n  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n  let options = mergeOptions(optionsBase);\n  let pluginList = [];\n  let pluginApis;\n  let container;\n  let slides;\n  function storeElements() {\n    const {\n      container: userContainer,\n      slides: userSlides\n    } = options;\n    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n    container = customContainer || root.children[0];\n    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n    slides = [].slice.call(customSlides || container.children);\n  }\n  function createEngine(options2) {\n    const engine2 = Engine(root, container, slides, ownerDocument, ownerWindow, options2, eventHandler);\n    if (options2.loop && !engine2.slideLooper.canLoop()) {\n      const optionsWithoutLoop = Object.assign({}, options2, {\n        loop: false\n      });\n      return createEngine(optionsWithoutLoop);\n    }\n    return engine2;\n  }\n  function activate(withOptions, withPlugins) {\n    if (destroyed)\n      return;\n    optionsBase = mergeOptions(optionsBase, withOptions);\n    options = optionsAtMedia(optionsBase);\n    pluginList = withPlugins || pluginList;\n    storeElements();\n    engine = createEngine(options);\n    optionsMediaQueries([optionsBase, ...pluginList.map(({\n      options: options2\n    }) => options2)]).forEach((query) => mediaHandlers.add(query, \"change\", reActivate));\n    if (!options.active)\n      return;\n    engine.translate.to(engine.location.get());\n    engine.animation.init();\n    engine.slidesInView.init();\n    engine.slideFocus.init(self);\n    engine.eventHandler.init(self);\n    engine.resizeHandler.init(self);\n    engine.slidesHandler.init(self);\n    if (engine.options.loop)\n      engine.slideLooper.loop();\n    if (container.offsetParent && slides.length)\n      engine.dragHandler.init(self);\n    pluginApis = pluginsHandler.init(self, pluginList);\n  }\n  function reActivate(withOptions, withPlugins) {\n    const startIndex = selectedScrollSnap();\n    deActivate();\n    activate(mergeOptions({\n      startIndex\n    }, withOptions), withPlugins);\n    eventHandler.emit(\"reInit\");\n  }\n  function deActivate() {\n    engine.dragHandler.destroy();\n    engine.eventStore.clear();\n    engine.translate.clear();\n    engine.slideLooper.clear();\n    engine.resizeHandler.destroy();\n    engine.slidesHandler.destroy();\n    engine.slidesInView.destroy();\n    engine.animation.destroy();\n    pluginsHandler.destroy();\n    mediaHandlers.clear();\n  }\n  function destroy() {\n    if (destroyed)\n      return;\n    destroyed = true;\n    mediaHandlers.clear();\n    deActivate();\n    eventHandler.emit(\"destroy\");\n    eventHandler.clear();\n  }\n  function scrollTo(index, jump, direction) {\n    if (!options.active || destroyed)\n      return;\n    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n    engine.scrollTo.index(index, direction || 0);\n  }\n  function scrollNext(jump) {\n    const next = engine.index.add(1).get();\n    scrollTo(next, jump, -1);\n  }\n  function scrollPrev(jump) {\n    const prev = engine.index.add(-1).get();\n    scrollTo(prev, jump, 1);\n  }\n  function canScrollNext() {\n    const next = engine.index.add(1).get();\n    return next !== selectedScrollSnap();\n  }\n  function canScrollPrev() {\n    const prev = engine.index.add(-1).get();\n    return prev !== selectedScrollSnap();\n  }\n  function scrollSnapList() {\n    return engine.scrollSnapList;\n  }\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.offsetLocation.get());\n  }\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n  function slidesInView() {\n    return engine.slidesInView.get();\n  }\n  function slidesNotInView() {\n    return engine.slidesInView.get(false);\n  }\n  function plugins() {\n    return pluginApis;\n  }\n  function internalEngine() {\n    return engine;\n  }\n  function rootNode() {\n    return root;\n  }\n  function containerNode() {\n    return container;\n  }\n  function slideNodes() {\n    return slides;\n  }\n  const self = {\n    canScrollNext,\n    canScrollPrev,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    emit,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView\n  };\n  activate(userOptions, userPlugins);\n  setTimeout(() => eventHandler.emit(\"init\"), 0);\n  return self;\n}\nEmblaCarousel.globalOptions = void 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBUyxTQUFTLFNBQVM7QUFDekIsU0FBTyxPQUFPLFlBQVk7QUFDNUI7QUFDQSxTQUFTLFNBQVMsU0FBUztBQUN6QixTQUFPLE9BQU8sWUFBWTtBQUM1QjtBQUNBLFNBQVMsVUFBVSxTQUFTO0FBQzFCLFNBQU8sT0FBTyxZQUFZO0FBQzVCO0FBQ0EsU0FBUyxTQUFTLFNBQVM7QUFDekIsU0FBTyxPQUFPLFVBQVUsU0FBUyxLQUFLLE9BQU8sTUFBTTtBQUNyRDtBQUNBLFNBQVMsUUFBUSxHQUFHO0FBQ2xCLFNBQU8sS0FBSyxJQUFJLENBQUM7QUFDbkI7QUFDQSxTQUFTLFNBQVMsR0FBRztBQUNuQixTQUFPLEtBQUssS0FBSyxDQUFDO0FBQ3BCO0FBQ0EsU0FBUyxTQUFTLFFBQVEsUUFBUTtBQUNoQyxTQUFPLFFBQVEsU0FBUyxNQUFNO0FBQ2hDO0FBQ0EsU0FBUyxVQUFVLFFBQVEsUUFBUTtBQUNqQyxNQUFJLFdBQVcsS0FBSyxXQUFXO0FBQUcsV0FBTztBQUN6QyxNQUFJLFFBQVEsTUFBTSxLQUFLLFFBQVEsTUFBTTtBQUFHLFdBQU87QUFDL0MsUUFBTSxPQUFPLFNBQVMsUUFBUSxNQUFNLEdBQUcsUUFBUSxNQUFNLENBQUM7QUFDdEQsU0FBTyxRQUFRLE9BQU8sTUFBTTtBQUM5QjtBQUNBLFNBQVMsbUJBQW1CLEtBQUs7QUFDL0IsU0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLElBQUk7QUFDakM7QUFDQSxTQUFTLFVBQVUsT0FBTztBQUN4QixTQUFPLFdBQVcsS0FBSyxFQUFFLElBQUksTUFBTTtBQUNyQztBQUNBLFNBQVMsVUFBVSxPQUFPO0FBQ3hCLFNBQU8sTUFBTSxlQUFlLEtBQUssQ0FBQztBQUNwQztBQUNBLFNBQVMsZUFBZSxPQUFPO0FBQzdCLFNBQU8sS0FBSyxJQUFJLEdBQUcsTUFBTSxTQUFTLENBQUM7QUFD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VDtBQUNBLFFBQU0sT0FBTztBQUFBLElBQ1g7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxXQUFTLGFBQWEsV0FBVztBQUNqQyxhQUFXLE1BQU0sYUFBYSxLQUFLLE1BQU0sR0FBRyxDQUFDO0FBQzdDLFNBQU87QUFDVDtBQUNBLGNBQWMsZ0JBQWdCO0FBRU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waWZ5LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcz85NmYxIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzTnVtYmVyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbihzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ2Jvb2xlYW4nO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmZ1bmN0aW9uIG1hdGhBYnMobikge1xuICByZXR1cm4gTWF0aC5hYnMobik7XG59XG5mdW5jdGlvbiBtYXRoU2lnbihuKSB7XG4gIHJldHVybiBNYXRoLnNpZ24obik7XG59XG5mdW5jdGlvbiBkZWx0YUFicyh2YWx1ZUIsIHZhbHVlQSkge1xuICByZXR1cm4gbWF0aEFicyh2YWx1ZUIgLSB2YWx1ZUEpO1xufVxuZnVuY3Rpb24gZmFjdG9yQWJzKHZhbHVlQiwgdmFsdWVBKSB7XG4gIGlmICh2YWx1ZUIgPT09IDAgfHwgdmFsdWVBID09PSAwKSByZXR1cm4gMDtcbiAgaWYgKG1hdGhBYnModmFsdWVCKSA8PSBtYXRoQWJzKHZhbHVlQSkpIHJldHVybiAwO1xuICBjb25zdCBkaWZmID0gZGVsdGFBYnMobWF0aEFicyh2YWx1ZUIpLCBtYXRoQWJzKHZhbHVlQSkpO1xuICByZXR1cm4gbWF0aEFicyhkaWZmIC8gdmFsdWVCKTtcbn1cbmZ1bmN0aW9uIHJvdW5kVG9Ud29EZWNpbWFscyhudW0pIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMTAwKSAvIDEwMDtcbn1cbmZ1bmN0aW9uIGFycmF5S2V5cyhhcnJheSkge1xuICByZXR1cm4gb2JqZWN0S2V5cyhhcnJheSkubWFwKE51bWJlcik7XG59XG5mdW5jdGlvbiBhcnJheUxhc3QoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5W2FycmF5TGFzdEluZGV4KGFycmF5KV07XG59XG5mdW5jdGlvbiBhcnJheUxhc3RJbmRleChhcnJheSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBhcnJheUlzTGFzdEluZGV4KGFycmF5LCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPT09IGFycmF5TGFzdEluZGV4KGFycmF5KTtcbn1cbmZ1bmN0aW9uIGFycmF5RnJvbU51bWJlcihuLCBzdGFydEF0ID0gMCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShBcnJheShuKSwgKF8sIGkpID0+IHN0YXJ0QXQgKyBpKTtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xufVxuZnVuY3Rpb24gb2JqZWN0c01lcmdlRGVlcChvYmplY3RBLCBvYmplY3RCKSB7XG4gIHJldHVybiBbb2JqZWN0QSwgb2JqZWN0Ql0ucmVkdWNlKChtZXJnZWRPYmplY3RzLCBjdXJyZW50T2JqZWN0KSA9PiB7XG4gICAgb2JqZWN0S2V5cyhjdXJyZW50T2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZUEgPSBtZXJnZWRPYmplY3RzW2tleV07XG4gICAgICBjb25zdCB2YWx1ZUIgPSBjdXJyZW50T2JqZWN0W2tleV07XG4gICAgICBjb25zdCBhcmVPYmplY3RzID0gaXNPYmplY3QodmFsdWVBKSAmJiBpc09iamVjdCh2YWx1ZUIpO1xuICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gYXJlT2JqZWN0cyA/IG9iamVjdHNNZXJnZURlZXAodmFsdWVBLCB2YWx1ZUIpIDogdmFsdWVCO1xuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWRPYmplY3RzO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdykge1xuICByZXR1cm4gdHlwZW9mIG93bmVyV2luZG93Lk1vdXNlRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIGV2dCBpbnN0YW5jZW9mIG93bmVyV2luZG93Lk1vdXNlRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIEFsaWdubWVudChhbGlnbiwgdmlld1NpemUpIHtcbiAgY29uc3QgcHJlZGVmaW5lZCA9IHtcbiAgICBzdGFydCxcbiAgICBjZW50ZXIsXG4gICAgZW5kXG4gIH07XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNlbnRlcihuKSB7XG4gICAgcmV0dXJuIGVuZChuKSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZW5kKG4pIHtcbiAgICByZXR1cm4gdmlld1NpemUgLSBuO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmUobiwgaW5kZXgpIHtcbiAgICBpZiAoaXNTdHJpbmcoYWxpZ24pKSByZXR1cm4gcHJlZGVmaW5lZFthbGlnbl0obik7XG4gICAgcmV0dXJuIGFsaWduKHZpZXdTaXplLCBuLCBpbmRleCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFdmVudFN0b3JlKCkge1xuICBsZXQgbGlzdGVuZXJzID0gW107XG4gIGZ1bmN0aW9uIGFkZChub2RlLCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSkge1xuICAgIGxldCByZW1vdmVMaXN0ZW5lcjtcbiAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG5vZGUpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyID0gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZWdhY3lNZWRpYVF1ZXJ5TGlzdCA9IG5vZGU7XG4gICAgICBsZWdhY3lNZWRpYVF1ZXJ5TGlzdC5hZGRMaXN0ZW5lcihoYW5kbGVyKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyID0gKCkgPT4gbGVnYWN5TWVkaWFRdWVyeUxpc3QucmVtb3ZlTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGxpc3RlbmVycy5wdXNoKHJlbW92ZUxpc3RlbmVyKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKHJlbW92ZSA9PiByZW1vdmUoKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBhZGQsXG4gICAgY2xlYXJcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbnMob3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHVwZGF0ZSwgcmVuZGVyKSB7XG4gIGNvbnN0IGRvY3VtZW50VmlzaWJsZUhhbmRsZXIgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGZpeGVkVGltZVN0ZXAgPSAxMDAwIC8gNjA7XG4gIGxldCBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgbGV0IGFjY3VtdWxhdGVkVGltZSA9IDA7XG4gIGxldCBhbmltYXRpb25JZCA9IDA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5hZGQob3duZXJEb2N1bWVudCwgJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpZiAob3duZXJEb2N1bWVudC5oaWRkZW4pIHJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBzdG9wKCk7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFuaW1hdGUodGltZVN0YW1wKSB7XG4gICAgaWYgKCFhbmltYXRpb25JZCkgcmV0dXJuO1xuICAgIGlmICghbGFzdFRpbWVTdGFtcCkge1xuICAgICAgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gdGltZVN0YW1wIC0gbGFzdFRpbWVTdGFtcDtcbiAgICBsYXN0VGltZVN0YW1wID0gdGltZVN0YW1wO1xuICAgIGFjY3VtdWxhdGVkVGltZSArPSB0aW1lRWxhcHNlZDtcbiAgICB3aGlsZSAoYWNjdW11bGF0ZWRUaW1lID49IGZpeGVkVGltZVN0ZXApIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgYWNjdW11bGF0ZWRUaW1lIC09IGZpeGVkVGltZVN0ZXA7XG4gICAgfVxuICAgIGNvbnN0IGFscGhhID0gYWNjdW11bGF0ZWRUaW1lIC8gZml4ZWRUaW1lU3RlcDtcbiAgICByZW5kZXIoYWxwaGEpO1xuICAgIGlmIChhbmltYXRpb25JZCkge1xuICAgICAgYW5pbWF0aW9uSWQgPSBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGlmIChhbmltYXRpb25JZCkgcmV0dXJuO1xuICAgIGFuaW1hdGlvbklkID0gb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgb3duZXJXaW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWQpO1xuICAgIGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICAgIGFjY3VtdWxhdGVkVGltZSA9IDA7XG4gICAgYW5pbWF0aW9uSWQgPSAwO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICAgIGFjY3VtdWxhdGVkVGltZSA9IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICB1cGRhdGUsXG4gICAgcmVuZGVyXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBBeGlzKGF4aXMsIGNvbnRlbnREaXJlY3Rpb24pIHtcbiAgY29uc3QgaXNSaWdodFRvTGVmdCA9IGNvbnRlbnREaXJlY3Rpb24gPT09ICdydGwnO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gYXhpcyA9PT0gJ3knO1xuICBjb25zdCBzY3JvbGwgPSBpc1ZlcnRpY2FsID8gJ3knIDogJ3gnO1xuICBjb25zdCBjcm9zcyA9IGlzVmVydGljYWwgPyAneCcgOiAneSc7XG4gIGNvbnN0IHNpZ24gPSAhaXNWZXJ0aWNhbCAmJiBpc1JpZ2h0VG9MZWZ0ID8gLTEgOiAxO1xuICBjb25zdCBzdGFydEVkZ2UgPSBnZXRTdGFydEVkZ2UoKTtcbiAgY29uc3QgZW5kRWRnZSA9IGdldEVuZEVkZ2UoKTtcbiAgZnVuY3Rpb24gbWVhc3VyZVNpemUobm9kZVJlY3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBub2RlUmVjdDtcbiAgICByZXR1cm4gaXNWZXJ0aWNhbCA/IGhlaWdodCA6IHdpZHRoO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXJ0RWRnZSgpIHtcbiAgICBpZiAoaXNWZXJ0aWNhbCkgcmV0dXJuICd0b3AnO1xuICAgIHJldHVybiBpc1JpZ2h0VG9MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgfVxuICBmdW5jdGlvbiBnZXRFbmRFZGdlKCkge1xuICAgIGlmIChpc1ZlcnRpY2FsKSByZXR1cm4gJ2JvdHRvbSc7XG4gICAgcmV0dXJuIGlzUmlnaHRUb0xlZnQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbihuKSB7XG4gICAgcmV0dXJuIG4gKiBzaWduO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2Nyb2xsLFxuICAgIGNyb3NzLFxuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlLFxuICAgIG1lYXN1cmVTaXplLFxuICAgIGRpcmVjdGlvblxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gTGltaXQobWluID0gMCwgbWF4ID0gMCkge1xuICBjb25zdCBsZW5ndGggPSBtYXRoQWJzKG1pbiAtIG1heCk7XG4gIGZ1bmN0aW9uIHJlYWNoZWRNaW4obikge1xuICAgIHJldHVybiBuIDwgbWluO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWNoZWRNYXgobikge1xuICAgIHJldHVybiBuID4gbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHJlYWNoZWRBbnkobikge1xuICAgIHJldHVybiByZWFjaGVkTWluKG4pIHx8IHJlYWNoZWRNYXgobik7XG4gIH1cbiAgZnVuY3Rpb24gY29uc3RyYWluKG4pIHtcbiAgICBpZiAoIXJlYWNoZWRBbnkobikpIHJldHVybiBuO1xuICAgIHJldHVybiByZWFjaGVkTWluKG4pID8gbWluIDogbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9mZnNldChuKSB7XG4gICAgaWYgKCFsZW5ndGgpIHJldHVybiBuO1xuICAgIHJldHVybiBuIC0gbGVuZ3RoICogTWF0aC5jZWlsKChuIC0gbWF4KSAvIGxlbmd0aCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsZW5ndGgsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBjb25zdHJhaW4sXG4gICAgcmVhY2hlZEFueSxcbiAgICByZWFjaGVkTWF4LFxuICAgIHJlYWNoZWRNaW4sXG4gICAgcmVtb3ZlT2Zmc2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBDb3VudGVyKG1heCwgc3RhcnQsIGxvb3ApIHtcbiAgY29uc3Qge1xuICAgIGNvbnN0cmFpblxuICB9ID0gTGltaXQoMCwgbWF4KTtcbiAgY29uc3QgbG9vcEVuZCA9IG1heCArIDE7XG4gIGxldCBjb3VudGVyID0gd2l0aGluTGltaXQoc3RhcnQpO1xuICBmdW5jdGlvbiB3aXRoaW5MaW1pdChuKSB7XG4gICAgcmV0dXJuICFsb29wID8gY29uc3RyYWluKG4pIDogbWF0aEFicygobG9vcEVuZCArIG4pICUgbG9vcEVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgY291bnRlciA9IHdpdGhpbkxpbWl0KG4pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChuKSB7XG4gICAgcmV0dXJuIGNsb25lKCkuc2V0KGdldCgpICsgbik7XG4gIH1cbiAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIENvdW50ZXIobWF4LCBnZXQoKSwgbG9vcCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBjbG9uZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ0hhbmRsZXIoYXhpcywgcm9vdE5vZGUsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB0YXJnZXQsIGRyYWdUcmFja2VyLCBsb2NhdGlvbiwgYW5pbWF0aW9uLCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCBpbmRleCwgZXZlbnRIYW5kbGVyLCBwZXJjZW50T2ZWaWV3LCBkcmFnRnJlZSwgZHJhZ1RocmVzaG9sZCwgc2tpcFNuYXBzLCBiYXNlRnJpY3Rpb24sIHdhdGNoRHJhZykge1xuICBjb25zdCB7XG4gICAgY3Jvc3M6IGNyb3NzQXhpcyxcbiAgICBkaXJlY3Rpb25cbiAgfSA9IGF4aXM7XG4gIGNvbnN0IGZvY3VzTm9kZXMgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuICBjb25zdCBub25QYXNzaXZlRXZlbnQgPSB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfTtcbiAgY29uc3QgaW5pdEV2ZW50cyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZHJhZ0V2ZW50cyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZ29Ub05leHRUaHJlc2hvbGQgPSBMaW1pdCg1MCwgMjI1KS5jb25zdHJhaW4ocGVyY2VudE9mVmlldy5tZWFzdXJlKDIwKSk7XG4gIGNvbnN0IHNuYXBGb3JjZUJvb3N0ID0ge1xuICAgIG1vdXNlOiAzMDAsXG4gICAgdG91Y2g6IDQwMFxuICB9O1xuICBjb25zdCBmcmVlRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogNTAwLFxuICAgIHRvdWNoOiA2MDBcbiAgfTtcbiAgY29uc3QgYmFzZVNwZWVkID0gZHJhZ0ZyZWUgPyA0MyA6IDI1O1xuICBsZXQgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgbGV0IHN0YXJ0U2Nyb2xsID0gMDtcbiAgbGV0IHN0YXJ0Q3Jvc3MgPSAwO1xuICBsZXQgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICBsZXQgcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICBsZXQgcHJldmVudENsaWNrID0gZmFsc2U7XG4gIGxldCBpc01vdXNlID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBpZiAoIXdhdGNoRHJhZykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRvd25JZkFsbG93ZWQoZXZ0KSB7XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoRHJhZykgfHwgd2F0Y2hEcmFnKGVtYmxhQXBpLCBldnQpKSBkb3duKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSByb290Tm9kZTtcbiAgICBpbml0RXZlbnRzLmFkZChub2RlLCAnZHJhZ3N0YXJ0JywgZXZ0ID0+IGV2dC5wcmV2ZW50RGVmYXVsdCgpLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2htb3ZlJywgKCkgPT4gdW5kZWZpbmVkLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCAoKSA9PiB1bmRlZmluZWQpLmFkZChub2RlLCAndG91Y2hzdGFydCcsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAnbW91c2Vkb3duJywgZG93bklmQWxsb3dlZCkuYWRkKG5vZGUsICd0b3VjaGNhbmNlbCcsIHVwKS5hZGQobm9kZSwgJ2NvbnRleHRtZW51JywgdXApLmFkZChub2RlLCAnY2xpY2snLCBjbGljaywgdHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpbml0RXZlbnRzLmNsZWFyKCk7XG4gICAgZHJhZ0V2ZW50cy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZERyYWdFdmVudHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGlzTW91c2UgPyBvd25lckRvY3VtZW50IDogcm9vdE5vZGU7XG4gICAgZHJhZ0V2ZW50cy5hZGQobm9kZSwgJ3RvdWNobW92ZScsIG1vdmUsIG5vblBhc3NpdmVFdmVudCkuYWRkKG5vZGUsICd0b3VjaGVuZCcsIHVwKS5hZGQobm9kZSwgJ21vdXNlbW92ZScsIG1vdmUsIG5vblBhc3NpdmVFdmVudCkuYWRkKG5vZGUsICdtb3VzZXVwJywgdXApO1xuICB9XG4gIGZ1bmN0aW9uIGlzRm9jdXNOb2RlKG5vZGUpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUgfHwgJyc7XG4gICAgcmV0dXJuIGZvY3VzTm9kZXMuaW5jbHVkZXMobm9kZU5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcmNlQm9vc3QoKSB7XG4gICAgY29uc3QgYm9vc3QgPSBkcmFnRnJlZSA/IGZyZWVGb3JjZUJvb3N0IDogc25hcEZvcmNlQm9vc3Q7XG4gICAgY29uc3QgdHlwZSA9IGlzTW91c2UgPyAnbW91c2UnIDogJ3RvdWNoJztcbiAgICByZXR1cm4gYm9vc3RbdHlwZV07XG4gIH1cbiAgZnVuY3Rpb24gYWxsb3dlZEZvcmNlKGZvcmNlLCB0YXJnZXRDaGFuZ2VkKSB7XG4gICAgY29uc3QgbmV4dCA9IGluZGV4LmFkZChtYXRoU2lnbihmb3JjZSkgKiAtMSk7XG4gICAgY29uc3QgYmFzZUZvcmNlID0gc2Nyb2xsVGFyZ2V0LmJ5RGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSkuZGlzdGFuY2U7XG4gICAgaWYgKGRyYWdGcmVlIHx8IG1hdGhBYnMoZm9yY2UpIDwgZ29Ub05leHRUaHJlc2hvbGQpIHJldHVybiBiYXNlRm9yY2U7XG4gICAgaWYgKHNraXBTbmFwcyAmJiB0YXJnZXRDaGFuZ2VkKSByZXR1cm4gYmFzZUZvcmNlICogMC41O1xuICAgIHJldHVybiBzY3JvbGxUYXJnZXQuYnlJbmRleChuZXh0LmdldCgpLCAwKS5kaXN0YW5jZTtcbiAgfVxuICBmdW5jdGlvbiBkb3duKGV2dCkge1xuICAgIGNvbnN0IGlzTW91c2VFdnQgPSBpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdyk7XG4gICAgaXNNb3VzZSA9IGlzTW91c2VFdnQ7XG4gICAgcHJldmVudENsaWNrID0gZHJhZ0ZyZWUgJiYgaXNNb3VzZUV2dCAmJiAhZXZ0LmJ1dHRvbnMgJiYgaXNNb3Zpbmc7XG4gICAgaXNNb3ZpbmcgPSBkZWx0YUFicyh0YXJnZXQuZ2V0KCksIGxvY2F0aW9uLmdldCgpKSA+PSAyO1xuICAgIGlmIChpc01vdXNlRXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICBpZiAoaXNGb2N1c05vZGUoZXZ0LnRhcmdldCkpIHJldHVybjtcbiAgICBwb2ludGVySXNEb3duID0gdHJ1ZTtcbiAgICBkcmFnVHJhY2tlci5wb2ludGVyRG93bihldnQpO1xuICAgIHNjcm9sbEJvZHkudXNlRnJpY3Rpb24oMCkudXNlRHVyYXRpb24oMCk7XG4gICAgdGFyZ2V0LnNldChsb2NhdGlvbik7XG4gICAgYWRkRHJhZ0V2ZW50cygpO1xuICAgIHN0YXJ0U2Nyb2xsID0gZHJhZ1RyYWNrZXIucmVhZFBvaW50KGV2dCk7XG4gICAgc3RhcnRDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3BvaW50ZXJEb3duJyk7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZShldnQpIHtcbiAgICBjb25zdCBpc1RvdWNoRXZ0ID0gIWlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KTtcbiAgICBpZiAoaXNUb3VjaEV2dCAmJiBldnQudG91Y2hlcy5sZW5ndGggPj0gMikgcmV0dXJuIHVwKGV2dCk7XG4gICAgY29uc3QgbGFzdFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIGNvbnN0IGxhc3RDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgY29uc3QgZGlmZlNjcm9sbCA9IGRlbHRhQWJzKGxhc3RTY3JvbGwsIHN0YXJ0U2Nyb2xsKTtcbiAgICBjb25zdCBkaWZmQ3Jvc3MgPSBkZWx0YUFicyhsYXN0Q3Jvc3MsIHN0YXJ0Q3Jvc3MpO1xuICAgIGlmICghcHJldmVudFNjcm9sbCAmJiAhaXNNb3VzZSkge1xuICAgICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuIHVwKGV2dCk7XG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZGlmZlNjcm9sbCA+IGRpZmZDcm9zcztcbiAgICAgIGlmICghcHJldmVudFNjcm9sbCkgcmV0dXJuIHVwKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBkcmFnVHJhY2tlci5wb2ludGVyTW92ZShldnQpO1xuICAgIGlmIChkaWZmU2Nyb2xsID4gZHJhZ1RocmVzaG9sZCkgcHJldmVudENsaWNrID0gdHJ1ZTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDAuMykudXNlRHVyYXRpb24oMC43NSk7XG4gICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgdGFyZ2V0LmFkZChkaXJlY3Rpb24oZGlmZikpO1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwKGV2dCkge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKDAsIGZhbHNlKTtcbiAgICBjb25zdCB0YXJnZXRDaGFuZ2VkID0gY3VycmVudExvY2F0aW9uLmluZGV4ICE9PSBpbmRleC5nZXQoKTtcbiAgICBjb25zdCByYXdGb3JjZSA9IGRyYWdUcmFja2VyLnBvaW50ZXJVcChldnQpICogZm9yY2VCb29zdCgpO1xuICAgIGNvbnN0IGZvcmNlID0gYWxsb3dlZEZvcmNlKGRpcmVjdGlvbihyYXdGb3JjZSksIHRhcmdldENoYW5nZWQpO1xuICAgIGNvbnN0IGZvcmNlRmFjdG9yID0gZmFjdG9yQWJzKHJhd0ZvcmNlLCBmb3JjZSk7XG4gICAgY29uc3Qgc3BlZWQgPSBiYXNlU3BlZWQgLSAxMCAqIGZvcmNlRmFjdG9yO1xuICAgIGNvbnN0IGZyaWN0aW9uID0gYmFzZUZyaWN0aW9uICsgZm9yY2VGYWN0b3IgLyA1MDtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgICBzY3JvbGxCb2R5LnVzZUR1cmF0aW9uKHNwZWVkKS51c2VGcmljdGlvbihmcmljdGlvbik7XG4gICAgc2Nyb2xsVG8uZGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSk7XG4gICAgaXNNb3VzZSA9IGZhbHNlO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyVXAnKTtcbiAgfVxuICBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICBpZiAocHJldmVudENsaWNrKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHByZXZlbnRDbGljayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bigpIHtcbiAgICByZXR1cm4gcG9pbnRlcklzRG93bjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveSxcbiAgICBwb2ludGVyRG93blxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ1RyYWNrZXIoYXhpcywgb3duZXJXaW5kb3cpIHtcbiAgY29uc3QgbG9nSW50ZXJ2YWwgPSAxNzA7XG4gIGxldCBzdGFydEV2ZW50O1xuICBsZXQgbGFzdEV2ZW50O1xuICBmdW5jdGlvbiByZWFkVGltZShldnQpIHtcbiAgICByZXR1cm4gZXZ0LnRpbWVTdGFtcDtcbiAgfVxuICBmdW5jdGlvbiByZWFkUG9pbnQoZXZ0LCBldnRBeGlzKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBldnRBeGlzIHx8IGF4aXMuc2Nyb2xsO1xuICAgIGNvbnN0IGNvb3JkID0gYGNsaWVudCR7cHJvcGVydHkgPT09ICd4JyA/ICdYJyA6ICdZJ31gO1xuICAgIHJldHVybiAoaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpID8gZXZ0IDogZXZ0LnRvdWNoZXNbMF0pW2Nvb3JkXTtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bihldnQpIHtcbiAgICBzdGFydEV2ZW50ID0gZXZ0O1xuICAgIGxhc3RFdmVudCA9IGV2dDtcbiAgICByZXR1cm4gcmVhZFBvaW50KGV2dCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1vdmUoZXZ0KSB7XG4gICAgY29uc3QgZGlmZiA9IHJlYWRQb2ludChldnQpIC0gcmVhZFBvaW50KGxhc3RFdmVudCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IHJlYWRUaW1lKGV2dCkgLSByZWFkVGltZShzdGFydEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGxhc3RFdmVudCA9IGV2dDtcbiAgICBpZiAoZXhwaXJlZCkgc3RhcnRFdmVudCA9IGV2dDtcbiAgICByZXR1cm4gZGlmZjtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyVXAoZXZ0KSB7XG4gICAgaWYgKCFzdGFydEV2ZW50IHx8ICFsYXN0RXZlbnQpIHJldHVybiAwO1xuICAgIGNvbnN0IGRpZmZEcmFnID0gcmVhZFBvaW50KGxhc3RFdmVudCkgLSByZWFkUG9pbnQoc3RhcnRFdmVudCk7XG4gICAgY29uc3QgZGlmZlRpbWUgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IHJlYWRUaW1lKGV2dCkgLSByZWFkVGltZShsYXN0RXZlbnQpID4gbG9nSW50ZXJ2YWw7XG4gICAgY29uc3QgZm9yY2UgPSBkaWZmRHJhZyAvIGRpZmZUaW1lO1xuICAgIGNvbnN0IGlzRmxpY2sgPSBkaWZmVGltZSAmJiAhZXhwaXJlZCAmJiBtYXRoQWJzKGZvcmNlKSA+IDAuMTtcbiAgICByZXR1cm4gaXNGbGljayA/IGZvcmNlIDogMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHBvaW50ZXJEb3duLFxuICAgIHBvaW50ZXJNb3ZlLFxuICAgIHBvaW50ZXJVcCxcbiAgICByZWFkUG9pbnRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIE5vZGVSZWN0cygpIHtcbiAgZnVuY3Rpb24gbWVhc3VyZShub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0VG9wLFxuICAgICAgb2Zmc2V0TGVmdCxcbiAgICAgIG9mZnNldFdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoLFxuICAgICAgYm90dG9tOiBvZmZzZXRUb3AgKyBvZmZzZXRIZWlnaHQsXG4gICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgd2lkdGg6IG9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHRcbiAgICB9O1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBQZXJjZW50T2ZWaWV3KHZpZXdTaXplKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobikge1xuICAgIHJldHVybiB2aWV3U2l6ZSAqIChuIC8gMTAwKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lYXN1cmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFJlc2l6ZUhhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIG93bmVyV2luZG93LCBzbGlkZXMsIGF4aXMsIHdhdGNoUmVzaXplLCBub2RlUmVjdHMpIHtcbiAgY29uc3Qgb2JzZXJ2ZU5vZGVzID0gW2NvbnRhaW5lcl0uY29uY2F0KHNsaWRlcyk7XG4gIGxldCByZXNpemVPYnNlcnZlcjtcbiAgbGV0IGNvbnRhaW5lclNpemU7XG4gIGxldCBzbGlkZVNpemVzID0gW107XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcmVhZFNpemUobm9kZSkge1xuICAgIHJldHVybiBheGlzLm1lYXN1cmVTaXplKG5vZGVSZWN0cy5tZWFzdXJlKG5vZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFJlc2l6ZSkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclNpemUgPSByZWFkU2l6ZShjb250YWluZXIpO1xuICAgIHNsaWRlU2l6ZXMgPSBzbGlkZXMubWFwKHJlYWRTaXplKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZW50cmllcykge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNDb250YWluZXIgPSBlbnRyeS50YXJnZXQgPT09IGNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IHNsaWRlcy5pbmRleE9mKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGxhc3RTaXplID0gaXNDb250YWluZXIgPyBjb250YWluZXJTaXplIDogc2xpZGVTaXplc1tzbGlkZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHJlYWRTaXplKGlzQ29udGFpbmVyID8gY29udGFpbmVyIDogc2xpZGVzW3NsaWRlSW5kZXhdKTtcbiAgICAgICAgY29uc3QgZGlmZlNpemUgPSBtYXRoQWJzKG5ld1NpemUgLSBsYXN0U2l6ZSk7XG4gICAgICAgIGlmIChkaWZmU2l6ZSA+PSAwLjUpIHtcbiAgICAgICAgICBlbWJsYUFwaS5yZUluaXQoKTtcbiAgICAgICAgICBldmVudEhhbmRsZXIuZW1pdCgncmVzaXplJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoUmVzaXplKSB8fCB3YXRjaFJlc2l6ZShlbWJsYUFwaSwgZW50cmllcykpIHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKGVudHJpZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG93bmVyV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBvYnNlcnZlTm9kZXMuZm9yRWFjaChub2RlID0+IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpZiAocmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHByZXZpb3VzTG9jYXRpb24sIHRhcmdldCwgYmFzZUR1cmF0aW9uLCBiYXNlRnJpY3Rpb24pIHtcbiAgbGV0IHNjcm9sbFZlbG9jaXR5ID0gMDtcbiAgbGV0IHNjcm9sbERpcmVjdGlvbiA9IDA7XG4gIGxldCBzY3JvbGxEdXJhdGlvbiA9IGJhc2VEdXJhdGlvbjtcbiAgbGV0IHNjcm9sbEZyaWN0aW9uID0gYmFzZUZyaWN0aW9uO1xuICBsZXQgcmF3TG9jYXRpb24gPSBsb2NhdGlvbi5nZXQoKTtcbiAgbGV0IHJhd0xvY2F0aW9uUHJldmlvdXMgPSAwO1xuICBmdW5jdGlvbiBzZWVrKCkge1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRhcmdldC5nZXQoKSAtIGxvY2F0aW9uLmdldCgpO1xuICAgIGNvbnN0IGlzSW5zdGFudCA9ICFzY3JvbGxEdXJhdGlvbjtcbiAgICBsZXQgc2Nyb2xsRGlzdGFuY2UgPSAwO1xuICAgIGlmIChpc0luc3RhbnQpIHtcbiAgICAgIHNjcm9sbFZlbG9jaXR5ID0gMDtcbiAgICAgIHByZXZpb3VzTG9jYXRpb24uc2V0KHRhcmdldCk7XG4gICAgICBsb2NhdGlvbi5zZXQodGFyZ2V0KTtcbiAgICAgIHNjcm9sbERpc3RhbmNlID0gZGlzcGxhY2VtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0xvY2F0aW9uLnNldChsb2NhdGlvbik7XG4gICAgICBzY3JvbGxWZWxvY2l0eSArPSBkaXNwbGFjZW1lbnQgLyBzY3JvbGxEdXJhdGlvbjtcbiAgICAgIHNjcm9sbFZlbG9jaXR5ICo9IHNjcm9sbEZyaWN0aW9uO1xuICAgICAgcmF3TG9jYXRpb24gKz0gc2Nyb2xsVmVsb2NpdHk7XG4gICAgICBsb2NhdGlvbi5hZGQoc2Nyb2xsVmVsb2NpdHkpO1xuICAgICAgc2Nyb2xsRGlzdGFuY2UgPSByYXdMb2NhdGlvbiAtIHJhd0xvY2F0aW9uUHJldmlvdXM7XG4gICAgfVxuICAgIHNjcm9sbERpcmVjdGlvbiA9IG1hdGhTaWduKHNjcm9sbERpc3RhbmNlKTtcbiAgICByYXdMb2NhdGlvblByZXZpb3VzID0gcmF3TG9jYXRpb247XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gc2V0dGxlZCgpIHtcbiAgICBjb25zdCBkaWZmID0gdGFyZ2V0LmdldCgpIC0gb2Zmc2V0TG9jYXRpb24uZ2V0KCk7XG4gICAgcmV0dXJuIG1hdGhBYnMoZGlmZikgPCAwLjAwMTtcbiAgfVxuICBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRHVyYXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBzY3JvbGxEaXJlY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gdmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHNjcm9sbFZlbG9jaXR5O1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJhc2VEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdXNlRHVyYXRpb24oYmFzZUR1cmF0aW9uKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VCYXNlRnJpY3Rpb24oKSB7XG4gICAgcmV0dXJuIHVzZUZyaWN0aW9uKGJhc2VGcmljdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRHVyYXRpb24obikge1xuICAgIHNjcm9sbER1cmF0aW9uID0gbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiB1c2VGcmljdGlvbihuKSB7XG4gICAgc2Nyb2xsRnJpY3Rpb24gPSBuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZGlyZWN0aW9uLFxuICAgIGR1cmF0aW9uLFxuICAgIHZlbG9jaXR5LFxuICAgIHNlZWssXG4gICAgc2V0dGxlZCxcbiAgICB1c2VCYXNlRnJpY3Rpb24sXG4gICAgdXNlQmFzZUR1cmF0aW9uLFxuICAgIHVzZUZyaWN0aW9uLFxuICAgIHVzZUR1cmF0aW9uXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxCb3VuZHMobGltaXQsIGxvY2F0aW9uLCB0YXJnZXQsIHNjcm9sbEJvZHksIHBlcmNlbnRPZlZpZXcpIHtcbiAgY29uc3QgcHVsbEJhY2tUaHJlc2hvbGQgPSBwZXJjZW50T2ZWaWV3Lm1lYXN1cmUoMTApO1xuICBjb25zdCBlZGdlT2Zmc2V0VG9sZXJhbmNlID0gcGVyY2VudE9mVmlldy5tZWFzdXJlKDUwKTtcbiAgY29uc3QgZnJpY3Rpb25MaW1pdCA9IExpbWl0KDAuMSwgMC45OSk7XG4gIGxldCBkaXNhYmxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBzaG91bGRDb25zdHJhaW4oKSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFsaW1pdC5yZWFjaGVkQW55KHRhcmdldC5nZXQoKSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWxpbWl0LnJlYWNoZWRBbnkobG9jYXRpb24uZ2V0KCkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY29uc3RyYWluKHBvaW50ZXJEb3duKSB7XG4gICAgaWYgKCFzaG91bGRDb25zdHJhaW4oKSkgcmV0dXJuO1xuICAgIGNvbnN0IGVkZ2UgPSBsaW1pdC5yZWFjaGVkTWluKGxvY2F0aW9uLmdldCgpKSA/ICdtaW4nIDogJ21heCc7XG4gICAgY29uc3QgZGlmZlRvRWRnZSA9IG1hdGhBYnMobGltaXRbZWRnZV0gLSBsb2NhdGlvbi5nZXQoKSk7XG4gICAgY29uc3QgZGlmZlRvVGFyZ2V0ID0gdGFyZ2V0LmdldCgpIC0gbG9jYXRpb24uZ2V0KCk7XG4gICAgY29uc3QgZnJpY3Rpb24gPSBmcmljdGlvbkxpbWl0LmNvbnN0cmFpbihkaWZmVG9FZGdlIC8gZWRnZU9mZnNldFRvbGVyYW5jZSk7XG4gICAgdGFyZ2V0LnN1YnRyYWN0KGRpZmZUb1RhcmdldCAqIGZyaWN0aW9uKTtcbiAgICBpZiAoIXBvaW50ZXJEb3duICYmIG1hdGhBYnMoZGlmZlRvVGFyZ2V0KSA8IHB1bGxCYWNrVGhyZXNob2xkKSB7XG4gICAgICB0YXJnZXQuc2V0KGxpbWl0LmNvbnN0cmFpbih0YXJnZXQuZ2V0KCkpKTtcbiAgICAgIHNjcm9sbEJvZHkudXNlRHVyYXRpb24oMjUpLnVzZUJhc2VGcmljdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVBY3RpdmUoYWN0aXZlKSB7XG4gICAgZGlzYWJsZWQgPSAhYWN0aXZlO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2hvdWxkQ29uc3RyYWluLFxuICAgIGNvbnN0cmFpbixcbiAgICB0b2dnbGVBY3RpdmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbENvbnRhaW4odmlld1NpemUsIGNvbnRlbnRTaXplLCBzbmFwc0FsaWduZWQsIGNvbnRhaW5TY3JvbGwsIHBpeGVsVG9sZXJhbmNlKSB7XG4gIGNvbnN0IHNjcm9sbEJvdW5kcyA9IExpbWl0KC1jb250ZW50U2l6ZSArIHZpZXdTaXplLCAwKTtcbiAgY29uc3Qgc25hcHNCb3VuZGVkID0gbWVhc3VyZUJvdW5kZWQoKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbkxpbWl0ID0gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpO1xuICBjb25zdCBzbmFwc0NvbnRhaW5lZCA9IG1lYXN1cmVDb250YWluZWQoKTtcbiAgZnVuY3Rpb24gdXNlUGl4ZWxUb2xlcmFuY2UoYm91bmQsIHNuYXApIHtcbiAgICByZXR1cm4gZGVsdGFBYnMoYm91bmQsIHNuYXApIDw9IDE7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpIHtcbiAgICBjb25zdCBzdGFydFNuYXAgPSBzbmFwc0JvdW5kZWRbMF07XG4gICAgY29uc3QgZW5kU25hcCA9IGFycmF5TGFzdChzbmFwc0JvdW5kZWQpO1xuICAgIGNvbnN0IG1pbiA9IHNuYXBzQm91bmRlZC5sYXN0SW5kZXhPZihzdGFydFNuYXApO1xuICAgIGNvbnN0IG1heCA9IHNuYXBzQm91bmRlZC5pbmRleE9mKGVuZFNuYXApICsgMTtcbiAgICByZXR1cm4gTGltaXQobWluLCBtYXgpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVCb3VuZGVkKCkge1xuICAgIHJldHVybiBzbmFwc0FsaWduZWQubWFwKChzbmFwQWxpZ25lZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluLFxuICAgICAgICBtYXhcbiAgICAgIH0gPSBzY3JvbGxCb3VuZHM7XG4gICAgICBjb25zdCBzbmFwID0gc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihzbmFwQWxpZ25lZCk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChzbmFwc0FsaWduZWQsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gbWF4O1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIG1pbjtcbiAgICAgIGlmICh1c2VQaXhlbFRvbGVyYW5jZShtaW4sIHNuYXApKSByZXR1cm4gbWluO1xuICAgICAgaWYgKHVzZVBpeGVsVG9sZXJhbmNlKG1heCwgc25hcCkpIHJldHVybiBtYXg7XG4gICAgICByZXR1cm4gc25hcDtcbiAgICB9KS5tYXAoc2Nyb2xsQm91bmQgPT4gcGFyc2VGbG9hdChzY3JvbGxCb3VuZC50b0ZpeGVkKDMpKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUNvbnRhaW5lZCgpIHtcbiAgICBpZiAoY29udGVudFNpemUgPD0gdmlld1NpemUgKyBwaXhlbFRvbGVyYW5jZSkgcmV0dXJuIFtzY3JvbGxCb3VuZHMubWF4XTtcbiAgICBpZiAoY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcycpIHJldHVybiBzbmFwc0JvdW5kZWQ7XG4gICAgY29uc3Qge1xuICAgICAgbWluLFxuICAgICAgbWF4XG4gICAgfSA9IHNjcm9sbENvbnRhaW5MaW1pdDtcbiAgICByZXR1cm4gc25hcHNCb3VuZGVkLnNsaWNlKG1pbiwgbWF4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNuYXBzQ29udGFpbmVkLFxuICAgIHNjcm9sbENvbnRhaW5MaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTGltaXQoY29udGVudFNpemUsIHNjcm9sbFNuYXBzLCBsb29wKSB7XG4gIGNvbnN0IG1heCA9IHNjcm9sbFNuYXBzWzBdO1xuICBjb25zdCBtaW4gPSBsb29wID8gbWF4IC0gY29udGVudFNpemUgOiBhcnJheUxhc3Qoc2Nyb2xsU25hcHMpO1xuICBjb25zdCBsaW1pdCA9IExpbWl0KG1pbiwgbWF4KTtcbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTG9vcGVyKGNvbnRlbnRTaXplLCBsaW1pdCwgbG9jYXRpb24sIHZlY3RvcnMpIHtcbiAgY29uc3Qgam9pbnRTYWZldHkgPSAwLjE7XG4gIGNvbnN0IG1pbiA9IGxpbWl0Lm1pbiArIGpvaW50U2FmZXR5O1xuICBjb25zdCBtYXggPSBsaW1pdC5tYXggKyBqb2ludFNhZmV0eTtcbiAgY29uc3Qge1xuICAgIHJlYWNoZWRNaW4sXG4gICAgcmVhY2hlZE1heFxuICB9ID0gTGltaXQobWluLCBtYXgpO1xuICBmdW5jdGlvbiBzaG91bGRMb29wKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHJldHVybiByZWFjaGVkTWF4KGxvY2F0aW9uLmdldCgpKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkgcmV0dXJuIHJlYWNoZWRNaW4obG9jYXRpb24uZ2V0KCkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBsb29wKGRpcmVjdGlvbikge1xuICAgIGlmICghc2hvdWxkTG9vcChkaXJlY3Rpb24pKSByZXR1cm47XG4gICAgY29uc3QgbG9vcERpc3RhbmNlID0gY29udGVudFNpemUgKiAoZGlyZWN0aW9uICogLTEpO1xuICAgIHZlY3RvcnMuZm9yRWFjaCh2ID0+IHYuYWRkKGxvb3BEaXN0YW5jZSkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbG9vcFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpIHtcbiAgY29uc3Qge1xuICAgIG1heCxcbiAgICBsZW5ndGhcbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBnZXQobikge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IG4gLSBtYXg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IGN1cnJlbnRMb2NhdGlvbiAvIC1sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxTbmFwcyhheGlzLCBhbGlnbm1lbnQsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlc1RvU2Nyb2xsKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3Qge1xuICAgIGdyb3VwU2xpZGVzXG4gIH0gPSBzbGlkZXNUb1Njcm9sbDtcbiAgY29uc3QgYWxpZ25tZW50cyA9IG1lYXN1cmVTaXplcygpLm1hcChhbGlnbm1lbnQubWVhc3VyZSk7XG4gIGNvbnN0IHNuYXBzID0gbWVhc3VyZVVuYWxpZ25lZCgpO1xuICBjb25zdCBzbmFwc0FsaWduZWQgPSBtZWFzdXJlQWxpZ25lZCgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZXMoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNsaWRlUmVjdHMpLm1hcChyZWN0cyA9PiBhcnJheUxhc3QocmVjdHMpW2VuZEVkZ2VdIC0gcmVjdHNbMF1bc3RhcnRFZGdlXSkubWFwKG1hdGhBYnMpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVVbmFsaWduZWQoKSB7XG4gICAgcmV0dXJuIHNsaWRlUmVjdHMubWFwKHJlY3QgPT4gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gcmVjdFtzdGFydEVkZ2VdKS5tYXAoc25hcCA9PiAtbWF0aEFicyhzbmFwKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUFsaWduZWQoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNuYXBzKS5tYXAoZyA9PiBnWzBdKS5tYXAoKHNuYXAsIGluZGV4KSA9PiBzbmFwICsgYWxpZ25tZW50c1tpbmRleF0pO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc25hcHMsXG4gICAgc25hcHNBbGlnbmVkXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZVJlZ2lzdHJ5KGNvbnRhaW5TbmFwcywgY29udGFpblNjcm9sbCwgc2Nyb2xsU25hcHMsIHNjcm9sbENvbnRhaW5MaW1pdCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlSW5kZXhlcykge1xuICBjb25zdCB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfSA9IHNsaWRlc1RvU2Nyb2xsO1xuICBjb25zdCB7XG4gICAgbWluLFxuICAgIG1heFxuICB9ID0gc2Nyb2xsQ29udGFpbkxpbWl0O1xuICBjb25zdCBzbGlkZVJlZ2lzdHJ5ID0gY3JlYXRlU2xpZGVSZWdpc3RyeSgpO1xuICBmdW5jdGlvbiBjcmVhdGVTbGlkZVJlZ2lzdHJ5KCkge1xuICAgIGNvbnN0IGdyb3VwZWRTbGlkZUluZGV4ZXMgPSBncm91cFNsaWRlcyhzbGlkZUluZGV4ZXMpO1xuICAgIGNvbnN0IGRvTm90Q29udGFpbiA9ICFjb250YWluU25hcHMgfHwgY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcyc7XG4gICAgaWYgKHNjcm9sbFNuYXBzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIFtzbGlkZUluZGV4ZXNdO1xuICAgIGlmIChkb05vdENvbnRhaW4pIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzO1xuICAgIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzLnNsaWNlKG1pbiwgbWF4KS5tYXAoKGdyb3VwLCBpbmRleCwgZ3JvdXBzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChncm91cHMsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gYXJyYXlMYXN0KGdyb3Vwc1swXSkgKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhcnJheUxhc3RJbmRleChzbGlkZUluZGV4ZXMpIC0gYXJyYXlMYXN0KGdyb3VwcylbMF0gKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlLCBhcnJheUxhc3QoZ3JvdXBzKVswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbGlkZVJlZ2lzdHJ5XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUYXJnZXQobG9vcCwgc2Nyb2xsU25hcHMsIGNvbnRlbnRTaXplLCBsaW1pdCwgdGFyZ2V0VmVjdG9yKSB7XG4gIGNvbnN0IHtcbiAgICByZWFjaGVkQW55LFxuICAgIHJlbW92ZU9mZnNldCxcbiAgICBjb25zdHJhaW5cbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBtaW5EaXN0YW5jZShkaXN0YW5jZXMpIHtcbiAgICByZXR1cm4gZGlzdGFuY2VzLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IG1hdGhBYnMoYSkgLSBtYXRoQWJzKGIpKVswXTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGxvb3AgPyByZW1vdmVPZmZzZXQodGFyZ2V0KSA6IGNvbnN0cmFpbih0YXJnZXQpO1xuICAgIGNvbnN0IGFzY0RpZmZzVG9TbmFwcyA9IHNjcm9sbFNuYXBzLm1hcCgoc25hcCwgaW5kZXgpID0+ICh7XG4gICAgICBkaWZmOiBzaG9ydGN1dChzbmFwIC0gZGlzdGFuY2UsIDApLFxuICAgICAgaW5kZXhcbiAgICB9KSkuc29ydCgoZDEsIGQyKSA9PiBtYXRoQWJzKGQxLmRpZmYpIC0gbWF0aEFicyhkMi5kaWZmKSk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXhcbiAgICB9ID0gYXNjRGlmZnNUb1NuYXBzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzaG9ydGN1dCh0YXJnZXQsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldHMgPSBbdGFyZ2V0LCB0YXJnZXQgKyBjb250ZW50U2l6ZSwgdGFyZ2V0IC0gY29udGVudFNpemVdO1xuICAgIGlmICghbG9vcCkgcmV0dXJuIHRhcmdldDtcbiAgICBpZiAoIWRpcmVjdGlvbikgcmV0dXJuIG1pbkRpc3RhbmNlKHRhcmdldHMpO1xuICAgIGNvbnN0IG1hdGNoaW5nVGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKHQgPT4gbWF0aFNpZ24odCkgPT09IGRpcmVjdGlvbik7XG4gICAgaWYgKG1hdGNoaW5nVGFyZ2V0cy5sZW5ndGgpIHJldHVybiBtaW5EaXN0YW5jZShtYXRjaGluZ1RhcmdldHMpO1xuICAgIHJldHVybiBhcnJheUxhc3QodGFyZ2V0cykgLSBjb250ZW50U2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBieUluZGV4KGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBkaWZmVG9TbmFwID0gc2Nyb2xsU25hcHNbaW5kZXhdIC0gdGFyZ2V0VmVjdG9yLmdldCgpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gc2hvcnRjdXQoZGlmZlRvU25hcCwgZGlyZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnlEaXN0YW5jZShkaXN0YW5jZSwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFZlY3Rvci5nZXQoKSArIGRpc3RhbmNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2U6IHRhcmdldFNuYXBEaXN0YW5jZVxuICAgIH0gPSBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpO1xuICAgIGNvbnN0IHJlYWNoZWRCb3VuZCA9ICFsb29wICYmIHJlYWNoZWRBbnkodGFyZ2V0KTtcbiAgICBpZiAoIXNuYXAgfHwgcmVhY2hlZEJvdW5kKSByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gICAgY29uc3QgZGlmZlRvU25hcCA9IHNjcm9sbFNuYXBzW2luZGV4XSAtIHRhcmdldFNuYXBEaXN0YW5jZTtcbiAgICBjb25zdCBzbmFwRGlzdGFuY2UgPSBkaXN0YW5jZSArIHNob3J0Y3V0KGRpZmZUb1NuYXAsIDApO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlOiBzbmFwRGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYnlEaXN0YW5jZSxcbiAgICBieUluZGV4LFxuICAgIHNob3J0Y3V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUbyhhbmltYXRpb24sIGluZGV4Q3VycmVudCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXRWZWN0b3IsIGV2ZW50SGFuZGxlcikge1xuICBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZURpZmYgPSB0YXJnZXQuZGlzdGFuY2U7XG4gICAgY29uc3QgaW5kZXhEaWZmID0gdGFyZ2V0LmluZGV4ICE9PSBpbmRleEN1cnJlbnQuZ2V0KCk7XG4gICAgdGFyZ2V0VmVjdG9yLmFkZChkaXN0YW5jZURpZmYpO1xuICAgIGlmIChkaXN0YW5jZURpZmYpIHtcbiAgICAgIGlmIChzY3JvbGxCb2R5LmR1cmF0aW9uKCkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb24udXBkYXRlKCk7XG4gICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoMSk7XG4gICAgICAgIGFuaW1hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4RGlmZikge1xuICAgICAgaW5kZXhQcmV2aW91cy5zZXQoaW5kZXhDdXJyZW50LmdldCgpKTtcbiAgICAgIGluZGV4Q3VycmVudC5zZXQodGFyZ2V0LmluZGV4KTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzZWxlY3QnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGlzdGFuY2Uobiwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKG4sIHNuYXApO1xuICAgIHNjcm9sbFRvKHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5kZXgobiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpbmRleEN1cnJlbnQuY2xvbmUoKS5zZXQobik7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgodGFyZ2V0SW5kZXguZ2V0KCksIGRpcmVjdGlvbik7XG4gICAgc2Nyb2xsVG8odGFyZ2V0KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGRpc3RhbmNlLFxuICAgIGluZGV4XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZUZvY3VzKHJvb3QsIHNsaWRlcywgc2xpZGVSZWdpc3RyeSwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIGV2ZW50U3RvcmUsIGV2ZW50SGFuZGxlciwgd2F0Y2hGb2N1cykge1xuICBjb25zdCBmb2N1c0xpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICBwYXNzaXZlOiB0cnVlLFxuICAgIGNhcHR1cmU6IHRydWVcbiAgfTtcbiAgbGV0IGxhc3RUYWJQcmVzc1RpbWUgPSAwO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaEZvY3VzKSByZXR1cm47XG4gICAgZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKGluZGV4KSB7XG4gICAgICBjb25zdCBub3dUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBkaWZmVGltZSA9IG5vd1RpbWUgLSBsYXN0VGFiUHJlc3NUaW1lO1xuICAgICAgaWYgKGRpZmZUaW1lID4gMTApIHJldHVybjtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZUZvY3VzU3RhcnQnKTtcbiAgICAgIHJvb3Quc2Nyb2xsTGVmdCA9IDA7XG4gICAgICBjb25zdCBncm91cCA9IHNsaWRlUmVnaXN0cnkuZmluZEluZGV4KGdyb3VwID0+IGdyb3VwLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICBpZiAoIWlzTnVtYmVyKGdyb3VwKSkgcmV0dXJuO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigwKTtcbiAgICAgIHNjcm9sbFRvLmluZGV4KGdyb3VwLCAwKTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZUZvY3VzJyk7XG4gICAgfVxuICAgIGV2ZW50U3RvcmUuYWRkKGRvY3VtZW50LCAna2V5ZG93bicsIHJlZ2lzdGVyVGFiUHJlc3MsIGZhbHNlKTtcbiAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGV2ZW50U3RvcmUuYWRkKHNsaWRlLCAnZm9jdXMnLCBldnQgPT4ge1xuICAgICAgICBpZiAoaXNCb29sZWFuKHdhdGNoRm9jdXMpIHx8IHdhdGNoRm9jdXMoZW1ibGFBcGksIGV2dCkpIHtcbiAgICAgICAgICBkZWZhdWx0Q2FsbGJhY2soc2xpZGVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZvY3VzTGlzdGVuZXJPcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlclRhYlByZXNzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNvZGUgPT09ICdUYWInKSBsYXN0VGFiUHJlc3NUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBWZWN0b3IxRChpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgdmFsdWUgPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHZhbHVlICs9IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnRyYWN0KG4pIHtcbiAgICB2YWx1ZSAtPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVJbnB1dChuKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG4pID8gbiA6IG4uZ2V0KCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBzdWJ0cmFjdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gVHJhbnNsYXRlKGF4aXMsIGNvbnRhaW5lcikge1xuICBjb25zdCB0cmFuc2xhdGUgPSBheGlzLnNjcm9sbCA9PT0gJ3gnID8geCA6IHk7XG4gIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICBsZXQgcHJldmlvdXNUYXJnZXQgPSBudWxsO1xuICBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24geChuKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUzZCgke259cHgsMHB4LDBweClgO1xuICB9XG4gIGZ1bmN0aW9uIHkobikge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoMHB4LCR7bn1weCwwcHgpYDtcbiAgfVxuICBmdW5jdGlvbiB0byh0YXJnZXQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCBuZXdUYXJnZXQgPSByb3VuZFRvVHdvRGVjaW1hbHMoYXhpcy5kaXJlY3Rpb24odGFyZ2V0KSk7XG4gICAgaWYgKG5ld1RhcmdldCA9PT0gcHJldmlvdXNUYXJnZXQpIHJldHVybjtcbiAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGUobmV3VGFyZ2V0KTtcbiAgICBwcmV2aW91c1RhcmdldCA9IG5ld1RhcmdldDtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVBY3RpdmUoYWN0aXZlKSB7XG4gICAgZGlzYWJsZWQgPSAhYWN0aXZlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgIGlmICghY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNsZWFyLFxuICAgIHRvLFxuICAgIHRvZ2dsZUFjdGl2ZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVMb29wZXIoYXhpcywgdmlld1NpemUsIGNvbnRlbnRTaXplLCBzbGlkZVNpemVzLCBzbGlkZVNpemVzV2l0aEdhcHMsIHNuYXBzLCBzY3JvbGxTbmFwcywgbG9jYXRpb24sIHNsaWRlcykge1xuICBjb25zdCByb3VuZGluZ1NhZmV0eSA9IDAuNTtcbiAgY29uc3QgYXNjSXRlbXMgPSBhcnJheUtleXMoc2xpZGVTaXplc1dpdGhHYXBzKTtcbiAgY29uc3QgZGVzY0l0ZW1zID0gYXJyYXlLZXlzKHNsaWRlU2l6ZXNXaXRoR2FwcykucmV2ZXJzZSgpO1xuICBjb25zdCBsb29wUG9pbnRzID0gc3RhcnRQb2ludHMoKS5jb25jYXQoZW5kUG9pbnRzKCkpO1xuICBmdW5jdGlvbiByZW1vdmVTbGlkZVNpemVzKGluZGV4ZXMsIGZyb20pIHtcbiAgICByZXR1cm4gaW5kZXhlcy5yZWR1Y2UoKGEsIGkpID0+IHtcbiAgICAgIHJldHVybiBhIC0gc2xpZGVTaXplc1dpdGhHYXBzW2ldO1xuICAgIH0sIGZyb20pO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc0luR2FwKGluZGV4ZXMsIGdhcCkge1xuICAgIHJldHVybiBpbmRleGVzLnJlZHVjZSgoYSwgaSkgPT4ge1xuICAgICAgY29uc3QgcmVtYWluaW5nR2FwID0gcmVtb3ZlU2xpZGVTaXplcyhhLCBnYXApO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZ0dhcCA+IDAgPyBhLmNvbmNhdChbaV0pIDogYTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNsaWRlQm91bmRzKG9mZnNldCkge1xuICAgIHJldHVybiBzbmFwcy5tYXAoKHNuYXAsIGluZGV4KSA9PiAoe1xuICAgICAgc3RhcnQ6IHNuYXAgLSBzbGlkZVNpemVzW2luZGV4XSArIHJvdW5kaW5nU2FmZXR5ICsgb2Zmc2V0LFxuICAgICAgZW5kOiBzbmFwICsgdmlld1NpemUgLSByb3VuZGluZ1NhZmV0eSArIG9mZnNldFxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCBvZmZzZXQsIGlzRW5kRWRnZSkge1xuICAgIGNvbnN0IHNsaWRlQm91bmRzID0gZmluZFNsaWRlQm91bmRzKG9mZnNldCk7XG4gICAgcmV0dXJuIGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWwgPSBpc0VuZEVkZ2UgPyAwIDogLWNvbnRlbnRTaXplO1xuICAgICAgY29uc3QgYWx0ZXJlZCA9IGlzRW5kRWRnZSA/IGNvbnRlbnRTaXplIDogMDtcbiAgICAgIGNvbnN0IGJvdW5kRWRnZSA9IGlzRW5kRWRnZSA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgIGNvbnN0IGxvb3BQb2ludCA9IHNsaWRlQm91bmRzW2luZGV4XVtib3VuZEVkZ2VdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxvb3BQb2ludCxcbiAgICAgICAgc2xpZGVMb2NhdGlvbjogVmVjdG9yMUQoLTEpLFxuICAgICAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZShheGlzLCBzbGlkZXNbaW5kZXhdKSxcbiAgICAgICAgdGFyZ2V0OiAoKSA9PiBsb2NhdGlvbi5nZXQoKSA+IGxvb3BQb2ludCA/IGluaXRpYWwgOiBhbHRlcmVkXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0UG9pbnRzKCkge1xuICAgIGNvbnN0IGdhcCA9IHNjcm9sbFNuYXBzWzBdO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBzbGlkZXNJbkdhcChkZXNjSXRlbXMsIGdhcCk7XG4gICAgcmV0dXJuIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIGNvbnRlbnRTaXplLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gZW5kUG9pbnRzKCkge1xuICAgIGNvbnN0IGdhcCA9IHZpZXdTaXplIC0gc2Nyb2xsU25hcHNbMF0gLSAxO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBzbGlkZXNJbkdhcChhc2NJdGVtcywgZ2FwKTtcbiAgICByZXR1cm4gZmluZExvb3BQb2ludHMoaW5kZXhlcywgLWNvbnRlbnRTaXplLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5Mb29wKCkge1xuICAgIHJldHVybiBsb29wUG9pbnRzLmV2ZXJ5KCh7XG4gICAgICBpbmRleFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG90aGVySW5kZXhlcyA9IGFzY0l0ZW1zLmZpbHRlcihpID0+IGkgIT09IGluZGV4KTtcbiAgICAgIHJldHVybiByZW1vdmVTbGlkZVNpemVzKG90aGVySW5kZXhlcywgdmlld1NpemUpIDw9IDAuMTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBsb29wKCkge1xuICAgIGxvb3BQb2ludHMuZm9yRWFjaChsb29wUG9pbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgc2xpZGVMb2NhdGlvblxuICAgICAgfSA9IGxvb3BQb2ludDtcbiAgICAgIGNvbnN0IHNoaWZ0TG9jYXRpb24gPSB0YXJnZXQoKTtcbiAgICAgIGlmIChzaGlmdExvY2F0aW9uID09PSBzbGlkZUxvY2F0aW9uLmdldCgpKSByZXR1cm47XG4gICAgICB0cmFuc2xhdGUudG8oc2hpZnRMb2NhdGlvbik7XG4gICAgICBzbGlkZUxvY2F0aW9uLnNldChzaGlmdExvY2F0aW9uKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBsb29wUG9pbnRzLmZvckVhY2gobG9vcFBvaW50ID0+IGxvb3BQb2ludC50cmFuc2xhdGUuY2xlYXIoKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjYW5Mb29wLFxuICAgIGNsZWFyLFxuICAgIGxvb3AsXG4gICAgbG9vcFBvaW50c1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgd2F0Y2hTbGlkZXMpIHtcbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSkge1xuICAgIGlmICghd2F0Y2hTbGlkZXMpIHJldHVybjtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2sobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICBlbWJsYUFwaS5yZUluaXQoKTtcbiAgICAgICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2xpZGVzQ2hhbmdlZCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaFNsaWRlcykgfHwgd2F0Y2hTbGlkZXMoZW1ibGFBcGksIG11dGF0aW9ucykpIHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKG11dGF0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lciwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAobXV0YXRpb25PYnNlcnZlcikgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzSW5WaWV3KGNvbnRhaW5lciwgc2xpZGVzLCBldmVudEhhbmRsZXIsIHRocmVzaG9sZCkge1xuICBjb25zdCBpbnRlcnNlY3Rpb25FbnRyeU1hcCA9IHt9O1xuICBsZXQgaW5WaWV3Q2FjaGUgPSBudWxsO1xuICBsZXQgbm90SW5WaWV3Q2FjaGUgPSBudWxsO1xuICBsZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2xpZGVzLmluZGV4T2YoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgaW50ZXJzZWN0aW9uRW50cnlNYXBbaW5kZXhdID0gZW50cnk7XG4gICAgICB9KTtcbiAgICAgIGluVmlld0NhY2hlID0gbnVsbDtcbiAgICAgIG5vdEluVmlld0NhY2hlID0gbnVsbDtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZXNJblZpZXcnKTtcbiAgICB9LCB7XG4gICAgICByb290OiBjb250YWluZXIucGFyZW50RWxlbWVudCxcbiAgICAgIHRocmVzaG9sZFxuICAgIH0pO1xuICAgIHNsaWRlcy5mb3JFYWNoKHNsaWRlID0+IGludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoc2xpZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChpbnRlcnNlY3Rpb25PYnNlcnZlcikgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW5WaWV3TGlzdChpblZpZXcpIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhpbnRlcnNlY3Rpb25FbnRyeU1hcCkucmVkdWNlKChsaXN0LCBzbGlkZUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHNsaWRlSW5kZXgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0ludGVyc2VjdGluZ1xuICAgICAgfSA9IGludGVyc2VjdGlvbkVudHJ5TWFwW2luZGV4XTtcbiAgICAgIGNvbnN0IGluVmlld01hdGNoID0gaW5WaWV3ICYmIGlzSW50ZXJzZWN0aW5nO1xuICAgICAgY29uc3Qgbm90SW5WaWV3TWF0Y2ggPSAhaW5WaWV3ICYmICFpc0ludGVyc2VjdGluZztcbiAgICAgIGlmIChpblZpZXdNYXRjaCB8fCBub3RJblZpZXdNYXRjaCkgbGlzdC5wdXNoKGluZGV4KTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoaW5WaWV3ID0gdHJ1ZSkge1xuICAgIGlmIChpblZpZXcgJiYgaW5WaWV3Q2FjaGUpIHJldHVybiBpblZpZXdDYWNoZTtcbiAgICBpZiAoIWluVmlldyAmJiBub3RJblZpZXdDYWNoZSkgcmV0dXJuIG5vdEluVmlld0NhY2hlO1xuICAgIGNvbnN0IHNsaWRlSW5kZXhlcyA9IGNyZWF0ZUluVmlld0xpc3QoaW5WaWV3KTtcbiAgICBpZiAoaW5WaWV3KSBpblZpZXdDYWNoZSA9IHNsaWRlSW5kZXhlcztcbiAgICBpZiAoIWluVmlldykgbm90SW5WaWV3Q2FjaGUgPSBzbGlkZUluZGV4ZXM7XG4gICAgcmV0dXJuIHNsaWRlSW5kZXhlcztcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveSxcbiAgICBnZXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlU2l6ZXMoYXhpcywgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzLCByZWFkRWRnZUdhcCwgb3duZXJXaW5kb3cpIHtcbiAgY29uc3Qge1xuICAgIG1lYXN1cmVTaXplLFxuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlXG4gIH0gPSBheGlzO1xuICBjb25zdCB3aXRoRWRnZUdhcCA9IHNsaWRlUmVjdHNbMF0gJiYgcmVhZEVkZ2VHYXA7XG4gIGNvbnN0IHN0YXJ0R2FwID0gbWVhc3VyZVN0YXJ0R2FwKCk7XG4gIGNvbnN0IGVuZEdhcCA9IG1lYXN1cmVFbmRHYXAoKTtcbiAgY29uc3Qgc2xpZGVTaXplcyA9IHNsaWRlUmVjdHMubWFwKG1lYXN1cmVTaXplKTtcbiAgY29uc3Qgc2xpZGVTaXplc1dpdGhHYXBzID0gbWVhc3VyZVdpdGhHYXBzKCk7XG4gIGZ1bmN0aW9uIG1lYXN1cmVTdGFydEdhcCgpIHtcbiAgICBpZiAoIXdpdGhFZGdlR2FwKSByZXR1cm4gMDtcbiAgICBjb25zdCBzbGlkZVJlY3QgPSBzbGlkZVJlY3RzWzBdO1xuICAgIHJldHVybiBtYXRoQWJzKGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdFtzdGFydEVkZ2VdKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlRW5kR2FwKCkge1xuICAgIGlmICghd2l0aEVkZ2VHYXApIHJldHVybiAwO1xuICAgIGNvbnN0IHN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhcnJheUxhc3Qoc2xpZGVzKSk7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShgbWFyZ2luLSR7ZW5kRWRnZX1gKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZVdpdGhHYXBzKCkge1xuICAgIHJldHVybiBzbGlkZVJlY3RzLm1hcCgocmVjdCwgaW5kZXgsIHJlY3RzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChyZWN0cywgaW5kZXgpO1xuICAgICAgaWYgKGlzRmlyc3QpIHJldHVybiBzbGlkZVNpemVzW2luZGV4XSArIHN0YXJ0R2FwO1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIHNsaWRlU2l6ZXNbaW5kZXhdICsgZW5kR2FwO1xuICAgICAgcmV0dXJuIHJlY3RzW2luZGV4ICsgMV1bc3RhcnRFZGdlXSAtIHJlY3Rbc3RhcnRFZGdlXTtcbiAgICB9KS5tYXAobWF0aEFicyk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbGlkZVNpemVzLFxuICAgIHNsaWRlU2l6ZXNXaXRoR2FwcyxcbiAgICBzdGFydEdhcCxcbiAgICBlbmRHYXBcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc1RvU2Nyb2xsKGF4aXMsIHZpZXdTaXplLCBzbGlkZXNUb1Njcm9sbCwgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCwgcGl4ZWxUb2xlcmFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlLFxuICAgIGRpcmVjdGlvblxuICB9ID0gYXhpcztcbiAgY29uc3QgZ3JvdXBCeU51bWJlciA9IGlzTnVtYmVyKHNsaWRlc1RvU2Nyb2xsKTtcbiAgZnVuY3Rpb24gYnlOdW1iZXIoYXJyYXksIGdyb3VwU2l6ZSkge1xuICAgIHJldHVybiBhcnJheUtleXMoYXJyYXkpLmZpbHRlcihpID0+IGkgJSBncm91cFNpemUgPT09IDApLm1hcChpID0+IGFycmF5LnNsaWNlKGksIGkgKyBncm91cFNpemUpKTtcbiAgfVxuICBmdW5jdGlvbiBieVNpemUoYXJyYXkpIHtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnJheUtleXMoYXJyYXkpLnJlZHVjZSgoZ3JvdXBzLCByZWN0QiwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJlY3RBID0gYXJyYXlMYXN0KGdyb3VwcykgfHwgMDtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSByZWN0QSA9PT0gMDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IHJlY3RCID09PSBhcnJheUxhc3RJbmRleChhcnJheSk7XG4gICAgICBjb25zdCBlZGdlQSA9IGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdHNbcmVjdEFdW3N0YXJ0RWRnZV07XG4gICAgICBjb25zdCBlZGdlQiA9IGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdHNbcmVjdEJdW2VuZEVkZ2VdO1xuICAgICAgY29uc3QgZ2FwQSA9ICFsb29wICYmIGlzRmlyc3QgPyBkaXJlY3Rpb24oc3RhcnRHYXApIDogMDtcbiAgICAgIGNvbnN0IGdhcEIgPSAhbG9vcCAmJiBpc0xhc3QgPyBkaXJlY3Rpb24oZW5kR2FwKSA6IDA7XG4gICAgICBjb25zdCBjaHVua1NpemUgPSBtYXRoQWJzKGVkZ2VCIC0gZ2FwQiAtIChlZGdlQSArIGdhcEEpKTtcbiAgICAgIGlmIChpbmRleCAmJiBjaHVua1NpemUgPiB2aWV3U2l6ZSArIHBpeGVsVG9sZXJhbmNlKSBncm91cHMucHVzaChyZWN0Qik7XG4gICAgICBpZiAoaXNMYXN0KSBncm91cHMucHVzaChhcnJheS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LCBbXSkubWFwKChjdXJyZW50U2l6ZSwgaW5kZXgsIGdyb3VwcykgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNTaXplID0gTWF0aC5tYXgoZ3JvdXBzW2luZGV4IC0gMV0gfHwgMCk7XG4gICAgICByZXR1cm4gYXJyYXkuc2xpY2UocHJldmlvdXNTaXplLCBjdXJyZW50U2l6ZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ3JvdXBTbGlkZXMoYXJyYXkpIHtcbiAgICByZXR1cm4gZ3JvdXBCeU51bWJlciA/IGJ5TnVtYmVyKGFycmF5LCBzbGlkZXNUb1Njcm9sbCkgOiBieVNpemUoYXJyYXkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEVuZ2luZShyb290LCBjb250YWluZXIsIHNsaWRlcywgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIG9wdGlvbnMsIGV2ZW50SGFuZGxlcikge1xuICAvLyBPcHRpb25zXG4gIGNvbnN0IHtcbiAgICBhbGlnbixcbiAgICBheGlzOiBzY3JvbGxBeGlzLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGFydEluZGV4LFxuICAgIGxvb3AsXG4gICAgZHVyYXRpb24sXG4gICAgZHJhZ0ZyZWUsXG4gICAgZHJhZ1RocmVzaG9sZCxcbiAgICBpblZpZXdUaHJlc2hvbGQsXG4gICAgc2xpZGVzVG9TY3JvbGw6IGdyb3VwU2xpZGVzLFxuICAgIHNraXBTbmFwcyxcbiAgICBjb250YWluU2Nyb2xsLFxuICAgIHdhdGNoUmVzaXplLFxuICAgIHdhdGNoU2xpZGVzLFxuICAgIHdhdGNoRHJhZyxcbiAgICB3YXRjaEZvY3VzXG4gIH0gPSBvcHRpb25zO1xuICAvLyBNZWFzdXJlbWVudHNcbiAgY29uc3QgcGl4ZWxUb2xlcmFuY2UgPSAyO1xuICBjb25zdCBub2RlUmVjdHMgPSBOb2RlUmVjdHMoKTtcbiAgY29uc3QgY29udGFpbmVyUmVjdCA9IG5vZGVSZWN0cy5tZWFzdXJlKGNvbnRhaW5lcik7XG4gIGNvbnN0IHNsaWRlUmVjdHMgPSBzbGlkZXMubWFwKG5vZGVSZWN0cy5tZWFzdXJlKTtcbiAgY29uc3QgYXhpcyA9IEF4aXMoc2Nyb2xsQXhpcywgZGlyZWN0aW9uKTtcbiAgY29uc3Qgdmlld1NpemUgPSBheGlzLm1lYXN1cmVTaXplKGNvbnRhaW5lclJlY3QpO1xuICBjb25zdCBwZXJjZW50T2ZWaWV3ID0gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSk7XG4gIGNvbnN0IGFsaWdubWVudCA9IEFsaWdubWVudChhbGlnbiwgdmlld1NpemUpO1xuICBjb25zdCBjb250YWluU25hcHMgPSAhbG9vcCAmJiAhIWNvbnRhaW5TY3JvbGw7XG4gIGNvbnN0IHJlYWRFZGdlR2FwID0gbG9vcCB8fCAhIWNvbnRhaW5TY3JvbGw7XG4gIGNvbnN0IHtcbiAgICBzbGlkZVNpemVzLFxuICAgIHNsaWRlU2l6ZXNXaXRoR2FwcyxcbiAgICBzdGFydEdhcCxcbiAgICBlbmRHYXBcbiAgfSA9IFNsaWRlU2l6ZXMoYXhpcywgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzLCByZWFkRWRnZUdhcCwgb3duZXJXaW5kb3cpO1xuICBjb25zdCBzbGlkZXNUb1Njcm9sbCA9IFNsaWRlc1RvU2Nyb2xsKGF4aXMsIHZpZXdTaXplLCBncm91cFNsaWRlcywgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCwgcGl4ZWxUb2xlcmFuY2UpO1xuICBjb25zdCB7XG4gICAgc25hcHMsXG4gICAgc25hcHNBbGlnbmVkXG4gIH0gPSBTY3JvbGxTbmFwcyhheGlzLCBhbGlnbm1lbnQsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlc1RvU2Nyb2xsKTtcbiAgY29uc3QgY29udGVudFNpemUgPSAtYXJyYXlMYXN0KHNuYXBzKSArIGFycmF5TGFzdChzbGlkZVNpemVzV2l0aEdhcHMpO1xuICBjb25zdCB7XG4gICAgc25hcHNDb250YWluZWQsXG4gICAgc2Nyb2xsQ29udGFpbkxpbWl0XG4gIH0gPSBTY3JvbGxDb250YWluKHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc25hcHNBbGlnbmVkLCBjb250YWluU2Nyb2xsLCBwaXhlbFRvbGVyYW5jZSk7XG4gIGNvbnN0IHNjcm9sbFNuYXBzID0gY29udGFpblNuYXBzID8gc25hcHNDb250YWluZWQgOiBzbmFwc0FsaWduZWQ7XG4gIGNvbnN0IHtcbiAgICBsaW1pdFxuICB9ID0gU2Nyb2xsTGltaXQoY29udGVudFNpemUsIHNjcm9sbFNuYXBzLCBsb29wKTtcbiAgLy8gSW5kZXhlc1xuICBjb25zdCBpbmRleCA9IENvdW50ZXIoYXJyYXlMYXN0SW5kZXgoc2Nyb2xsU25hcHMpLCBzdGFydEluZGV4LCBsb29wKTtcbiAgY29uc3QgaW5kZXhQcmV2aW91cyA9IGluZGV4LmNsb25lKCk7XG4gIGNvbnN0IHNsaWRlSW5kZXhlcyA9IGFycmF5S2V5cyhzbGlkZXMpO1xuICAvLyBBbmltYXRpb25cbiAgY29uc3QgdXBkYXRlID0gKHtcbiAgICBkcmFnSGFuZGxlcixcbiAgICBzY3JvbGxCb2R5LFxuICAgIHNjcm9sbEJvdW5kcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBsb29wXG4gICAgfVxuICB9KSA9PiB7XG4gICAgaWYgKCFsb29wKSBzY3JvbGxCb3VuZHMuY29uc3RyYWluKGRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpO1xuICAgIHNjcm9sbEJvZHkuc2VlaygpO1xuICB9O1xuICBjb25zdCByZW5kZXIgPSAoe1xuICAgIHNjcm9sbEJvZHksXG4gICAgdHJhbnNsYXRlLFxuICAgIGxvY2F0aW9uLFxuICAgIG9mZnNldExvY2F0aW9uLFxuICAgIHByZXZpb3VzTG9jYXRpb24sXG4gICAgc2Nyb2xsTG9vcGVyLFxuICAgIHNsaWRlTG9vcGVyLFxuICAgIGRyYWdIYW5kbGVyLFxuICAgIGFuaW1hdGlvbixcbiAgICBldmVudEhhbmRsZXIsXG4gICAgc2Nyb2xsQm91bmRzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGxvb3BcbiAgICB9XG4gIH0sIGFscGhhKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkU2V0dGxlID0gc2Nyb2xsQm9keS5zZXR0bGVkKCk7XG4gICAgY29uc3Qgd2l0aGluQm91bmRzID0gIXNjcm9sbEJvdW5kcy5zaG91bGRDb25zdHJhaW4oKTtcbiAgICBjb25zdCBoYXNTZXR0bGVkID0gbG9vcCA/IHNob3VsZFNldHRsZSA6IHNob3VsZFNldHRsZSAmJiB3aXRoaW5Cb3VuZHM7XG4gICAgY29uc3QgaGFzU2V0dGxlZEFuZElkbGUgPSBoYXNTZXR0bGVkICYmICFkcmFnSGFuZGxlci5wb2ludGVyRG93bigpO1xuICAgIGlmIChoYXNTZXR0bGVkQW5kSWRsZSkgYW5pbWF0aW9uLnN0b3AoKTtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWRMb2NhdGlvbiA9IGxvY2F0aW9uLmdldCgpICogYWxwaGEgKyBwcmV2aW91c0xvY2F0aW9uLmdldCgpICogKDEgLSBhbHBoYSk7XG4gICAgb2Zmc2V0TG9jYXRpb24uc2V0KGludGVycG9sYXRlZExvY2F0aW9uKTtcbiAgICBpZiAobG9vcCkge1xuICAgICAgc2Nyb2xsTG9vcGVyLmxvb3Aoc2Nyb2xsQm9keS5kaXJlY3Rpb24oKSk7XG4gICAgICBzbGlkZUxvb3Blci5sb29wKCk7XG4gICAgfVxuICAgIHRyYW5zbGF0ZS50byhvZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gICAgaWYgKGhhc1NldHRsZWRBbmRJZGxlKSBldmVudEhhbmRsZXIuZW1pdCgnc2V0dGxlJyk7XG4gICAgaWYgKCFoYXNTZXR0bGVkKSBldmVudEhhbmRsZXIuZW1pdCgnc2Nyb2xsJyk7XG4gIH07XG4gIGNvbnN0IGFuaW1hdGlvbiA9IEFuaW1hdGlvbnMob3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csICgpID0+IHVwZGF0ZShlbmdpbmUpLCBhbHBoYSA9PiByZW5kZXIoZW5naW5lLCBhbHBoYSkpO1xuICAvLyBTaGFyZWRcbiAgY29uc3QgZnJpY3Rpb24gPSAwLjY4O1xuICBjb25zdCBzdGFydExvY2F0aW9uID0gc2Nyb2xsU25hcHNbaW5kZXguZ2V0KCldO1xuICBjb25zdCBsb2NhdGlvbiA9IFZlY3RvcjFEKHN0YXJ0TG9jYXRpb24pO1xuICBjb25zdCBwcmV2aW91c0xvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IG9mZnNldExvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHRhcmdldCA9IFZlY3RvcjFEKHN0YXJ0TG9jYXRpb24pO1xuICBjb25zdCBzY3JvbGxCb2R5ID0gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHByZXZpb3VzTG9jYXRpb24sIHRhcmdldCwgZHVyYXRpb24sIGZyaWN0aW9uKTtcbiAgY29uc3Qgc2Nyb2xsVGFyZ2V0ID0gU2Nyb2xsVGFyZ2V0KGxvb3AsIHNjcm9sbFNuYXBzLCBjb250ZW50U2l6ZSwgbGltaXQsIHRhcmdldCk7XG4gIGNvbnN0IHNjcm9sbFRvID0gU2Nyb2xsVG8oYW5pbWF0aW9uLCBpbmRleCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXQsIGV2ZW50SGFuZGxlcik7XG4gIGNvbnN0IHNjcm9sbFByb2dyZXNzID0gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpO1xuICBjb25zdCBldmVudFN0b3JlID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCBzbGlkZXNJblZpZXcgPSBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgaW5WaWV3VGhyZXNob2xkKTtcbiAgY29uc3Qge1xuICAgIHNsaWRlUmVnaXN0cnlcbiAgfSA9IFNsaWRlUmVnaXN0cnkoY29udGFpblNuYXBzLCBjb250YWluU2Nyb2xsLCBzY3JvbGxTbmFwcywgc2Nyb2xsQ29udGFpbkxpbWl0LCBzbGlkZXNUb1Njcm9sbCwgc2xpZGVJbmRleGVzKTtcbiAgY29uc3Qgc2xpZGVGb2N1cyA9IFNsaWRlRm9jdXMocm9vdCwgc2xpZGVzLCBzbGlkZVJlZ2lzdHJ5LCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgZXZlbnRTdG9yZSwgZXZlbnRIYW5kbGVyLCB3YXRjaEZvY3VzKTtcbiAgLy8gRW5naW5lXG4gIGNvbnN0IGVuZ2luZSA9IHtcbiAgICBvd25lckRvY3VtZW50LFxuICAgIG93bmVyV2luZG93LFxuICAgIGV2ZW50SGFuZGxlcixcbiAgICBjb250YWluZXJSZWN0LFxuICAgIHNsaWRlUmVjdHMsXG4gICAgYW5pbWF0aW9uLFxuICAgIGF4aXMsXG4gICAgZHJhZ0hhbmRsZXI6IERyYWdIYW5kbGVyKGF4aXMsIHJvb3QsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB0YXJnZXQsIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSwgbG9jYXRpb24sIGFuaW1hdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIHNjcm9sbFRhcmdldCwgaW5kZXgsIGV2ZW50SGFuZGxlciwgcGVyY2VudE9mVmlldywgZHJhZ0ZyZWUsIGRyYWdUaHJlc2hvbGQsIHNraXBTbmFwcywgZnJpY3Rpb24sIHdhdGNoRHJhZyksXG4gICAgZXZlbnRTdG9yZSxcbiAgICBwZXJjZW50T2ZWaWV3LFxuICAgIGluZGV4LFxuICAgIGluZGV4UHJldmlvdXMsXG4gICAgbGltaXQsXG4gICAgbG9jYXRpb24sXG4gICAgb2Zmc2V0TG9jYXRpb24sXG4gICAgcHJldmlvdXNMb2NhdGlvbixcbiAgICBvcHRpb25zLFxuICAgIHJlc2l6ZUhhbmRsZXI6IFJlc2l6ZUhhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIG93bmVyV2luZG93LCBzbGlkZXMsIGF4aXMsIHdhdGNoUmVzaXplLCBub2RlUmVjdHMpLFxuICAgIHNjcm9sbEJvZHksXG4gICAgc2Nyb2xsQm91bmRzOiBTY3JvbGxCb3VuZHMobGltaXQsIG9mZnNldExvY2F0aW9uLCB0YXJnZXQsIHNjcm9sbEJvZHksIHBlcmNlbnRPZlZpZXcpLFxuICAgIHNjcm9sbExvb3BlcjogU2Nyb2xsTG9vcGVyKGNvbnRlbnRTaXplLCBsaW1pdCwgb2Zmc2V0TG9jYXRpb24sIFtsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHByZXZpb3VzTG9jYXRpb24sIHRhcmdldF0pLFxuICAgIHNjcm9sbFByb2dyZXNzLFxuICAgIHNjcm9sbFNuYXBMaXN0OiBzY3JvbGxTbmFwcy5tYXAoc2Nyb2xsUHJvZ3Jlc3MuZ2V0KSxcbiAgICBzY3JvbGxTbmFwcyxcbiAgICBzY3JvbGxUYXJnZXQsXG4gICAgc2Nyb2xsVG8sXG4gICAgc2xpZGVMb29wZXI6IFNsaWRlTG9vcGVyKGF4aXMsIHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc2xpZGVTaXplcywgc2xpZGVTaXplc1dpdGhHYXBzLCBzbmFwcywgc2Nyb2xsU25hcHMsIG9mZnNldExvY2F0aW9uLCBzbGlkZXMpLFxuICAgIHNsaWRlRm9jdXMsXG4gICAgc2xpZGVzSGFuZGxlcjogU2xpZGVzSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgd2F0Y2hTbGlkZXMpLFxuICAgIHNsaWRlc0luVmlldyxcbiAgICBzbGlkZUluZGV4ZXMsXG4gICAgc2xpZGVSZWdpc3RyeSxcbiAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICB0YXJnZXQsXG4gICAgdHJhbnNsYXRlOiBUcmFuc2xhdGUoYXhpcywgY29udGFpbmVyKVxuICB9O1xuICByZXR1cm4gZW5naW5lO1xufVxuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSB7fTtcbiAgbGV0IGFwaTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSkge1xuICAgIGFwaSA9IGVtYmxhQXBpO1xuICB9XG4gIGZ1bmN0aW9uIGdldExpc3RlbmVycyhldnQpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJzW2V2dF0gfHwgW107XG4gIH1cbiAgZnVuY3Rpb24gZW1pdChldnQpIHtcbiAgICBnZXRMaXN0ZW5lcnMoZXZ0KS5mb3JFYWNoKGUgPT4gZShhcGksIGV2dCkpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIG9uKGV2dCwgY2IpIHtcbiAgICBsaXN0ZW5lcnNbZXZ0XSA9IGdldExpc3RlbmVycyhldnQpLmNvbmNhdChbY2JdKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBvZmYoZXZ0LCBjYikge1xuICAgIGxpc3RlbmVyc1tldnRdID0gZ2V0TGlzdGVuZXJzKGV2dCkuZmlsdGVyKGUgPT4gZSAhPT0gY2IpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxpc3RlbmVycyA9IHt9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBlbWl0LFxuICAgIG9mZixcbiAgICBvbixcbiAgICBjbGVhclxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFsaWduOiAnY2VudGVyJyxcbiAgYXhpczogJ3gnLFxuICBjb250YWluZXI6IG51bGwsXG4gIHNsaWRlczogbnVsbCxcbiAgY29udGFpblNjcm9sbDogJ3RyaW1TbmFwcycsXG4gIGRpcmVjdGlvbjogJ2x0cicsXG4gIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICBpblZpZXdUaHJlc2hvbGQ6IDAsXG4gIGJyZWFrcG9pbnRzOiB7fSxcbiAgZHJhZ0ZyZWU6IGZhbHNlLFxuICBkcmFnVGhyZXNob2xkOiAxMCxcbiAgbG9vcDogZmFsc2UsXG4gIHNraXBTbmFwczogZmFsc2UsXG4gIGR1cmF0aW9uOiAyNSxcbiAgc3RhcnRJbmRleDogMCxcbiAgYWN0aXZlOiB0cnVlLFxuICB3YXRjaERyYWc6IHRydWUsXG4gIHdhdGNoUmVzaXplOiB0cnVlLFxuICB3YXRjaFNsaWRlczogdHJ1ZSxcbiAgd2F0Y2hGb2N1czogdHJ1ZVxufTtcblxuZnVuY3Rpb24gT3B0aW9uc0hhbmRsZXIob3duZXJXaW5kb3cpIHtcbiAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnNBLCBvcHRpb25zQikge1xuICAgIHJldHVybiBvYmplY3RzTWVyZ2VEZWVwKG9wdGlvbnNBLCBvcHRpb25zQiB8fCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gb3B0aW9uc0F0TWVkaWEob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNBdE1lZGlhID0gb3B0aW9ucy5icmVha3BvaW50cyB8fCB7fTtcbiAgICBjb25zdCBtYXRjaGVkTWVkaWFPcHRpb25zID0gb2JqZWN0S2V5cyhvcHRpb25zQXRNZWRpYSkuZmlsdGVyKG1lZGlhID0+IG93bmVyV2luZG93Lm1hdGNoTWVkaWEobWVkaWEpLm1hdGNoZXMpLm1hcChtZWRpYSA9PiBvcHRpb25zQXRNZWRpYVttZWRpYV0pLnJlZHVjZSgoYSwgbWVkaWFPcHRpb24pID0+IG1lcmdlT3B0aW9ucyhhLCBtZWRpYU9wdGlvbiksIHt9KTtcbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIG1hdGNoZWRNZWRpYU9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIG9wdGlvbnNNZWRpYVF1ZXJpZXMob3B0aW9uc0xpc3QpIHtcbiAgICByZXR1cm4gb3B0aW9uc0xpc3QubWFwKG9wdGlvbnMgPT4gb2JqZWN0S2V5cyhvcHRpb25zLmJyZWFrcG9pbnRzIHx8IHt9KSkucmVkdWNlKChhY2MsIG1lZGlhUXVlcmllcykgPT4gYWNjLmNvbmNhdChtZWRpYVF1ZXJpZXMpLCBbXSkubWFwKG93bmVyV2luZG93Lm1hdGNoTWVkaWEpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIG9wdGlvbnNBdE1lZGlhLFxuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFBsdWdpbnNIYW5kbGVyKG9wdGlvbnNIYW5kbGVyKSB7XG4gIGxldCBhY3RpdmVQbHVnaW5zID0gW107XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGksIHBsdWdpbnMpIHtcbiAgICBhY3RpdmVQbHVnaW5zID0gcGx1Z2lucy5maWx0ZXIoKHtcbiAgICAgIG9wdGlvbnNcbiAgICB9KSA9PiBvcHRpb25zSGFuZGxlci5vcHRpb25zQXRNZWRpYShvcHRpb25zKS5hY3RpdmUgIT09IGZhbHNlKTtcbiAgICBhY3RpdmVQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5pbml0KGVtYmxhQXBpLCBvcHRpb25zSGFuZGxlcikpO1xuICAgIHJldHVybiBwbHVnaW5zLnJlZHVjZSgobWFwLCBwbHVnaW4pID0+IE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICBbcGx1Z2luLm5hbWVdOiBwbHVnaW5cbiAgICB9KSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgYWN0aXZlUGx1Z2lucyA9IGFjdGl2ZVBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiBwbHVnaW4uZGVzdHJveSgpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRW1ibGFDYXJvdXNlbChyb290LCB1c2VyT3B0aW9ucywgdXNlclBsdWdpbnMpIHtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IHJvb3Qub3duZXJEb2N1bWVudDtcbiAgY29uc3Qgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBvcHRpb25zSGFuZGxlciA9IE9wdGlvbnNIYW5kbGVyKG93bmVyV2luZG93KTtcbiAgY29uc3QgcGx1Z2luc0hhbmRsZXIgPSBQbHVnaW5zSGFuZGxlcihvcHRpb25zSGFuZGxlcik7XG4gIGNvbnN0IG1lZGlhSGFuZGxlcnMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGV2ZW50SGFuZGxlciA9IEV2ZW50SGFuZGxlcigpO1xuICBjb25zdCB7XG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIG9wdGlvbnNBdE1lZGlhLFxuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXNcbiAgfSA9IG9wdGlvbnNIYW5kbGVyO1xuICBjb25zdCB7XG4gICAgb24sXG4gICAgb2ZmLFxuICAgIGVtaXRcbiAgfSA9IGV2ZW50SGFuZGxlcjtcbiAgY29uc3QgcmVJbml0ID0gcmVBY3RpdmF0ZTtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBsZXQgZW5naW5lO1xuICBsZXQgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIEVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyk7XG4gIGxldCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdGlvbnNCYXNlKTtcbiAgbGV0IHBsdWdpbkxpc3QgPSBbXTtcbiAgbGV0IHBsdWdpbkFwaXM7XG4gIGxldCBjb250YWluZXI7XG4gIGxldCBzbGlkZXM7XG4gIGZ1bmN0aW9uIHN0b3JlRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyOiB1c2VyQ29udGFpbmVyLFxuICAgICAgc2xpZGVzOiB1c2VyU2xpZGVzXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3VzdG9tQ29udGFpbmVyID0gaXNTdHJpbmcodXNlckNvbnRhaW5lcikgPyByb290LnF1ZXJ5U2VsZWN0b3IodXNlckNvbnRhaW5lcikgOiB1c2VyQ29udGFpbmVyO1xuICAgIGNvbnRhaW5lciA9IGN1c3RvbUNvbnRhaW5lciB8fCByb290LmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGN1c3RvbVNsaWRlcyA9IGlzU3RyaW5nKHVzZXJTbGlkZXMpID8gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodXNlclNsaWRlcykgOiB1c2VyU2xpZGVzO1xuICAgIHNsaWRlcyA9IFtdLnNsaWNlLmNhbGwoY3VzdG9tU2xpZGVzIHx8IGNvbnRhaW5lci5jaGlsZHJlbik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRW5naW5lKG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBFbmdpbmUocm9vdCwgY29udGFpbmVyLCBzbGlkZXMsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCBvcHRpb25zLCBldmVudEhhbmRsZXIpO1xuICAgIGlmIChvcHRpb25zLmxvb3AgJiYgIWVuZ2luZS5zbGlkZUxvb3Blci5jYW5Mb29wKCkpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnNXaXRob3V0TG9vcCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgbG9vcDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVuZ2luZShvcHRpb25zV2l0aG91dExvb3ApO1xuICAgIH1cbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG4gIGZ1bmN0aW9uIGFjdGl2YXRlKHdpdGhPcHRpb25zLCB3aXRoUGx1Z2lucykge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBvcHRpb25zQmFzZSA9IG1lcmdlT3B0aW9ucyhvcHRpb25zQmFzZSwgd2l0aE9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zQXRNZWRpYShvcHRpb25zQmFzZSk7XG4gICAgcGx1Z2luTGlzdCA9IHdpdGhQbHVnaW5zIHx8IHBsdWdpbkxpc3Q7XG4gICAgc3RvcmVFbGVtZW50cygpO1xuICAgIGVuZ2luZSA9IGNyZWF0ZUVuZ2luZShvcHRpb25zKTtcbiAgICBvcHRpb25zTWVkaWFRdWVyaWVzKFtvcHRpb25zQmFzZSwgLi4ucGx1Z2luTGlzdC5tYXAoKHtcbiAgICAgIG9wdGlvbnNcbiAgICB9KSA9PiBvcHRpb25zKV0pLmZvckVhY2gocXVlcnkgPT4gbWVkaWFIYW5kbGVycy5hZGQocXVlcnksICdjaGFuZ2UnLCByZUFjdGl2YXRlKSk7XG4gICAgaWYgKCFvcHRpb25zLmFjdGl2ZSkgcmV0dXJuO1xuICAgIGVuZ2luZS50cmFuc2xhdGUudG8oZW5naW5lLmxvY2F0aW9uLmdldCgpKTtcbiAgICBlbmdpbmUuYW5pbWF0aW9uLmluaXQoKTtcbiAgICBlbmdpbmUuc2xpZGVzSW5WaWV3LmluaXQoKTtcbiAgICBlbmdpbmUuc2xpZGVGb2N1cy5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5ldmVudEhhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5zbGlkZXNIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgaWYgKGVuZ2luZS5vcHRpb25zLmxvb3ApIGVuZ2luZS5zbGlkZUxvb3Blci5sb29wKCk7XG4gICAgaWYgKGNvbnRhaW5lci5vZmZzZXRQYXJlbnQgJiYgc2xpZGVzLmxlbmd0aCkgZW5naW5lLmRyYWdIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgcGx1Z2luQXBpcyA9IHBsdWdpbnNIYW5kbGVyLmluaXQoc2VsZiwgcGx1Z2luTGlzdCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVBY3RpdmF0ZSh3aXRoT3B0aW9ucywgd2l0aFBsdWdpbnMpIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGFjdGl2YXRlKG1lcmdlT3B0aW9ucyh7XG4gICAgICBzdGFydEluZGV4XG4gICAgfSwgd2l0aE9wdGlvbnMpLCB3aXRoUGx1Z2lucyk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3JlSW5pdCcpO1xuICB9XG4gIGZ1bmN0aW9uIGRlQWN0aXZhdGUoKSB7XG4gICAgZW5naW5lLmRyYWdIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuZXZlbnRTdG9yZS5jbGVhcigpO1xuICAgIGVuZ2luZS50cmFuc2xhdGUuY2xlYXIoKTtcbiAgICBlbmdpbmUuc2xpZGVMb29wZXIuY2xlYXIoKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLnNsaWRlc0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5zbGlkZXNJblZpZXcuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5hbmltYXRpb24uZGVzdHJveSgpO1xuICAgIHBsdWdpbnNIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdkZXN0cm95Jyk7XG4gICAgZXZlbnRIYW5kbGVyLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsVG8oaW5kZXgsIGp1bXAsIGRpcmVjdGlvbikge1xuICAgIGlmICghb3B0aW9ucy5hY3RpdmUgfHwgZGVzdHJveWVkKSByZXR1cm47XG4gICAgZW5naW5lLnNjcm9sbEJvZHkudXNlQmFzZUZyaWN0aW9uKCkudXNlRHVyYXRpb24oanVtcCA9PT0gdHJ1ZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uKTtcbiAgICBlbmdpbmUuc2Nyb2xsVG8uaW5kZXgoaW5kZXgsIGRpcmVjdGlvbiB8fCAwKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxOZXh0KGp1bXApIHtcbiAgICBjb25zdCBuZXh0ID0gZW5naW5lLmluZGV4LmFkZCgxKS5nZXQoKTtcbiAgICBzY3JvbGxUbyhuZXh0LCBqdW1wLCAtMSk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJldihqdW1wKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHNjcm9sbFRvKHByZXYsIGp1bXAsIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbE5leHQoKSB7XG4gICAgY29uc3QgbmV4dCA9IGVuZ2luZS5pbmRleC5hZGQoMSkuZ2V0KCk7XG4gICAgcmV0dXJuIG5leHQgIT09IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbFByZXYoKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHJldHVybiBwcmV2ICE9PSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxTbmFwTGlzdCgpIHtcbiAgICByZXR1cm4gZW5naW5lLnNjcm9sbFNuYXBMaXN0O1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFByb2dyZXNzKCkge1xuICAgIHJldHVybiBlbmdpbmUuc2Nyb2xsUHJvZ3Jlc3MuZ2V0KGVuZ2luZS5vZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0ZWRTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXguZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJldmlvdXNTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXhQcmV2aW91cy5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNJblZpZXcoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zbGlkZXNJblZpZXcuZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzTm90SW5WaWV3KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2xpZGVzSW5WaWV3LmdldChmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gcGx1Z2lucygpIHtcbiAgICByZXR1cm4gcGx1Z2luQXBpcztcbiAgfVxuICBmdW5jdGlvbiBpbnRlcm5hbEVuZ2luZSgpIHtcbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG4gIGZ1bmN0aW9uIHJvb3ROb2RlKCkge1xuICAgIHJldHVybiByb290O1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRhaW5lck5vZGUoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZU5vZGVzKCkge1xuICAgIHJldHVybiBzbGlkZXM7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjYW5TY3JvbGxOZXh0LFxuICAgIGNhblNjcm9sbFByZXYsXG4gICAgY29udGFpbmVyTm9kZSxcbiAgICBpbnRlcm5hbEVuZ2luZSxcbiAgICBkZXN0cm95LFxuICAgIG9mZixcbiAgICBvbixcbiAgICBlbWl0LFxuICAgIHBsdWdpbnMsXG4gICAgcHJldmlvdXNTY3JvbGxTbmFwLFxuICAgIHJlSW5pdCxcbiAgICByb290Tm9kZSxcbiAgICBzY3JvbGxOZXh0LFxuICAgIHNjcm9sbFByZXYsXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3QsXG4gICAgc2Nyb2xsVG8sXG4gICAgc2VsZWN0ZWRTY3JvbGxTbmFwLFxuICAgIHNsaWRlTm9kZXMsXG4gICAgc2xpZGVzSW5WaWV3LFxuICAgIHNsaWRlc05vdEluVmlld1xuICB9O1xuICBhY3RpdmF0ZSh1c2VyT3B0aW9ucywgdXNlclBsdWdpbnMpO1xuICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50SGFuZGxlci5lbWl0KCdpbml0JyksIDApO1xuICByZXR1cm4gc2VsZjtcbn1cbkVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgRW1ibGFDYXJvdXNlbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJsYS1jYXJvdXNlbC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiaW5kZXgiLCJncm91cCIsInNjcm9sbEJvZHkiLCJsb29wIiwibG9jYXRpb24iLCJvZmZzZXRMb2NhdGlvbiIsInByZXZpb3VzTG9jYXRpb24iLCJhbmltYXRpb24iLCJldmVudEhhbmRsZXIiLCJvcHRpb25zQXRNZWRpYSIsIm9wdGlvbnMiLCJlbmdpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/embla-carousel/esm/embla-carousel.esm.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/cart.js":
/*!*********************************!*\
  !*** ./src/entrypoints/cart.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   refreshCart: () => (/* binding */ refreshCart)\n/* harmony export */ });\nconst updateCartCount = () => {\n  const cartCountItems = document.querySelectorAll(\"#cartCount\");\n  console.log(cartCountItems);\n  cartCountItems.forEach((item) => {\n    const newCartCount = document.querySelector(\"#cartHeader\").dataset.cartCount;\n    let prependContent = \"\";\n    let appendContent = \"\";\n    if (newCartCount > 0) {\n      if (item.dataset.emptyHide) {\n        item.classList.remove(\"hidden\");\n      }\n      if (item.dataset.prepend) {\n        prependContent = item.dataset.prepend;\n      }\n      if (item.dataset.append) {\n        appendContent = item.dataset.append;\n      }\n      item.innerHTML = prependContent + newCartCount + appendContent;\n    } else {\n      if (item.dataset.emptyHide) {\n        item.classList.add(\"hidden\");\n      }\n      item.innerHTML = null;\n    }\n  });\n};\nconst refreshCart = (fullRefresh = false) => {\n  const sectionTitle = \"page_cart-panel\";\n  const cartDrawer = document.querySelector(\"#shopify-section-\" + sectionTitle + \" #cartContent\");\n  if (!cartDrawer) {\n    return false;\n  }\n  fetch(window.Shopify.routes.root + \"?sections=\" + sectionTitle).then((res) => res.json()).then((res) => {\n    const currentCartDrawer = document.querySelector(\"#shopify-section-\" + sectionTitle + \" #cartContent\");\n    var el = document.createElement(\"div\");\n    el.innerHTML = res[sectionTitle];\n    const oldCartCount = document.querySelector(\"#shopify-section-\" + sectionTitle + \" #cartHeader\").dataset.cartCount;\n    const newCartCount = el.querySelector(\"#cartHeader\").dataset.cartCount;\n    const oldlineCount = document.querySelectorAll(\"#shopify-section-\" + sectionTitle + \" #cartLineItem\")?.length;\n    const newlineCount = el.querySelectorAll(\"#shopify-section-\" + sectionTitle + \" #cartLineItem\")?.length;\n    if (newCartCount == 0 || oldCartCount == 0 || oldlineCount !== newlineCount) {\n      fullRefresh = true;\n    }\n    fullRefresh = true;\n    if (fullRefresh) {\n      const cartContent = el.querySelector(\"#cartContent\");\n      const updateItems = document.querySelectorAll(\"#shopify-section-\" + sectionTitle + \" #cartUpdate\");\n      const updatedItems = el.querySelectorAll(\"#shopify-section-\" + sectionTitle + \" #cartUpdate\");\n      console.log(cartContent);\n      console.log(updateItems);\n      console.log(updatedItems);\n      currentCartDrawer.outerHTML = cartContent.outerHTML;\n      updateItems?.forEach((item, index) => {\n        if (updatedItems[index]?.innerHTML && item) {\n          item.innerHTML = updatedItems[index].innerHTML;\n        }\n      });\n      updateCartCount();\n    } else {\n      const updateItems = document.querySelectorAll(\"#shopify-section-\" + sectionTitle + \" #cartUpdate\");\n      const updatedItems = el.querySelectorAll(\"#shopify-section-\" + sectionTitle + \" #cartUpdate\");\n      updateItems?.forEach((item, index) => {\n        if (updatedItems[index]?.innerHTML && item) {\n          item.innerHTML = updatedItems[index].innerHTML;\n        }\n      });\n      updateCartCount();\n    }\n  });\n};\nif (!customElements.get(\"cart-remove-item\")) {\n  customElements.define(\n    \"cart-remove-item\",\n    class CartRemoveItem extends HTMLElement {\n      constructor() {\n        super();\n        this.cartRemoveButton = this.querySelector(\".cart-remove-item\");\n        this.cartRemoveButton.addEventListener(\"click\", (event) => {\n          let formData = {\n            updates: {\n              [event.currentTarget.dataset.itemId]: 0\n            }\n          };\n          if (event.currentTarget.dataset.itemId.includes(\", \")) {\n            const variantIds = event?.currentTarget?.dataset?.itemId.split(\", \")?.filter((item) => item !== \"\");\n            const updatesObj = {};\n            if (variantIds.length > 0) {\n              variantIds.forEach((id) => {\n                updatesObj[id] = 0;\n              });\n            }\n            formData = {\n              updates: updatesObj\n            };\n          }\n          fetch(window.Shopify.routes.root + \"cart/update.js\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(formData)\n          }).then((data) => {\n            refreshCart(true);\n          }).catch((error) => {\n            console.error(\"Error:\", error);\n          });\n        });\n      }\n    }\n  );\n}\nif (!customElements.get(\"cart-quantity-adjust\")) {\n  customElements.define(\n    \"cart-quantity-adjust\",\n    class QuantityAdjust extends HTMLElement {\n      constructor() {\n        super();\n        this.quantityChangeButtons = this.querySelectorAll(\".quantity-change\");\n        this.onQuantityChangeButtonClick = this.onQuantityChangeButtonClick.bind(this);\n        this.quantityChangeButtons.forEach((quantityChangeButton) => {\n          quantityChangeButton.onclick = this.onQuantityChangeButtonClick;\n        });\n      }\n      onQuantityChangeButtonClick(event) {\n        const quantityChangeButton = event.currentTarget;\n        this.getQuantityDivFromChangeButton(quantityChangeButton).classList.add(\n          \"opacity-0\"\n        );\n        const itemId = parseInt(\n          quantityChangeButton.getAttribute(\"data-product-id\")\n        );\n        const itemQuantity = parseInt(\n          quantityChangeButton.getAttribute(\"data-new-quantity\")\n        );\n        let formData = {\n          updates: {\n            [itemId]: itemQuantity\n          }\n        };\n        let successHandler = (response) => {\n          const parent = quantityChangeButton.parentElement;\n          this.getQuantityDivFromChangeButton(quantityChangeButton).innerHTML = itemQuantity;\n          this.getQuantityDivFromChangeButton(\n            quantityChangeButton\n          ).classList.remove(\"opacity-0\");\n          const decreaseQuantityButton = parent.querySelector(\".quantity-down\");\n          decreaseQuantityButton.setAttribute(\n            \"data-new-quantity\",\n            itemQuantity - 1\n          );\n          const increaseQuantityButton = parent.querySelector(\".quantity-up\");\n          increaseQuantityButton.setAttribute(\n            \"data-new-quantity\",\n            itemQuantity + 1\n          );\n          return response.json();\n        };\n        successHandler = successHandler.bind(quantityChangeButton);\n        fetch(window.Shopify.routes.root + \"cart/update.js\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify(formData)\n        }).then((data) => successHandler(data)).then((data) => {\n          refreshCart();\n          document.querySelectorAll(\".cart-item-count\").forEach((element) => {\n            element.innerHTML = data.item_count;\n          });\n        }).catch((error) => {\n          console.error(\"Error:\", error);\n        });\n      }\n      getQuantityDivFromChangeButton(buttonDiv) {\n        const parent = buttonDiv.parentElement;\n        return parent.querySelector(\".quantity-current\");\n      }\n    }\n  );\n}\nif (!customElements.get(\"discount-form\")) {\n  customElements.define(\n    \"discount-form\",\n    class DiscountForm extends HTMLElement {\n      constructor() {\n        super();\n        this.input = this.querySelector('input[type=\"text\"]');\n        this.button = this.querySelector(\"button\");\n        this.statusMessage = this.querySelector(\".discount-status\");\n        this.onInputChange = this.onInputChange.bind(this);\n        this.onSubmit = this.onSubmit.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.updateButtonState();\n        this.input.addEventListener(\"input\", this.onInputChange);\n        this.input.addEventListener(\"keydown\", this.onKeyDown);\n        this.button.addEventListener(\"click\", this.onSubmit);\n      }\n      onKeyDown(event) {\n        if (event.key === \"Enter\") {\n          event.preventDefault();\n          if (!this.button.disabled) {\n            this.onSubmit(event);\n          }\n        }\n      }\n      onInputChange() {\n        this.updateButtonState();\n        if (this.statusMessage) {\n          this.statusMessage.textContent = \"\";\n          this.statusMessage.classList.add(\"hidden\");\n        }\n      }\n      updateButtonState() {\n        const hasValue = this.input.value.trim().length > 0;\n        this.button.disabled = !hasValue;\n        if (hasValue) {\n          this.button.classList.remove(\"opacity-50\", \"cursor-not-allowed\");\n        } else {\n          this.button.classList.add(\"opacity-50\", \"cursor-not-allowed\");\n        }\n      }\n      showStatus(message, isError = false) {\n        if (!this.statusMessage)\n          return;\n        this.statusMessage.textContent = message;\n        this.statusMessage.classList.remove(\"hidden\");\n        if (isError) {\n          this.statusMessage.classList.remove(\"text-green\");\n          this.statusMessage.classList.add(\"text-error\");\n        } else {\n          this.statusMessage.classList.remove(\"text-error\");\n          this.statusMessage.classList.add(\"text-green\");\n        }\n      }\n      onSubmit(event) {\n        event.preventDefault();\n        const discountCode = this.input.value.trim();\n        if (!discountCode)\n          return;\n        this.button.disabled = true;\n        this.button.classList.add(\"opacity-50\");\n        const originalText = this.button.textContent;\n        this.button.textContent = \"Applying...\";\n        let cartBeforeDiscount = null;\n        fetch(window.Shopify.routes.root + \"cart.js\").then((res) => res.json()).then((cart) => {\n          cartBeforeDiscount = cart;\n          return fetch(window.Shopify.routes.root + \"discount/\" + encodeURIComponent(discountCode));\n        }).then(() => {\n          return new Promise((resolve) => setTimeout(resolve, 500));\n        }).then(() => {\n          refreshCart(true);\n          return fetch(window.Shopify.routes.root + \"cart.js\");\n        }).then((res) => res.json()).then((cart) => {\n          this.button.textContent = originalText;\n          this.updateButtonState();\n          if (cart.cart_level_discount_applications && cart.cart_level_discount_applications.length > 0) {\n            const appliedDiscount = cart.cart_level_discount_applications.find(\n              (d) => d.title.toLowerCase() === discountCode.toLowerCase()\n            );\n            if (appliedDiscount) {\n              this.showStatus(`Discount code \"${discountCode}\" applied successfully!`);\n              this.input.value = \"\";\n              return;\n            }\n          }\n          let errorMessage = `Discount code \"${discountCode}\" could not be applied.`;\n          if (!cart.items || cart.items.length === 0) {\n            errorMessage += \" Your cart is empty.\";\n          } else if (cartBeforeDiscount && cart.total_price < 100) {\n            errorMessage += \" This discount may require a minimum purchase amount.\";\n          } else if (cart.items && cart.items.length > 0) {\n            errorMessage += \" This code may be invalid, expired, or not applicable to items in your cart.\";\n          } else {\n            errorMessage += \" Please check the code and try again.\";\n          }\n          this.showStatus(errorMessage, true);\n        }).catch((error) => {\n          console.error(\"Error applying discount:\", error);\n          this.button.textContent = originalText;\n          this.updateButtonState();\n          this.showStatus(\"Error applying discount code. Please check your connection and try again.\", true);\n        });\n      }\n    }\n  );\n}\nif (!customElements.get(\"discount-remove\")) {\n  customElements.define(\n    \"discount-remove\",\n    class DiscountRemove extends HTMLElement {\n      constructor() {\n        super();\n        this.button = this.querySelector(\"button\");\n        this.onRemove = this.onRemove.bind(this);\n        this.button.addEventListener(\"click\", this.onRemove);\n      }\n      onRemove(event) {\n        event.preventDefault();\n        this.button.disabled = true;\n        this.button.classList.add(\"opacity-50\");\n        console.log(\"Removing discount...\");\n        fetch(window.Shopify.routes.root + \"cart/update.js\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            discount: \"\"\n            // Empty string removes the discount\n          })\n        }).then((response) => response.json()).then((data) => {\n          console.log(\"Discount removed:\", data);\n          refreshCart(true);\n          this.button.disabled = false;\n          this.button.classList.remove(\"opacity-50\");\n        }).catch((error) => {\n          console.error(\"Error removing discount:\", error);\n          this.button.disabled = false;\n          this.button.classList.remove(\"opacity-50\");\n          refreshCart(true);\n        });\n      }\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVEsSUFBSSxxQkFBcUIsSUFBSTtBQUdyQyxzQkFBWSxJQUFJO0FBR2hCLGVBQUssT0FBTyxXQUFXO0FBQ3ZCLGVBQUssT0FBTyxVQUFVLE9BQU8sWUFBWTtBQUFBLFFBQzNDLENBQUMsRUFDQSxNQUFNLENBQUMsVUFBVTtBQUNoQixrQkFBUSxNQUFNLDRCQUE0QixLQUFLO0FBRy9DLGVBQUssT0FBTyxXQUFXO0FBQ3ZCLGVBQUssT0FBTyxVQUFVLE9BQU8sWUFBWTtBQUd6QyxzQkFBWSxJQUFJO0FBQUEsUUFDbEIsQ0FBQztBQUFBLE1BQ0g7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hvcGlmeS1zdGFydGVyLy4vc3JjL2VudHJ5cG9pbnRzL2NhcnQuanM/MDM3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZWZyZXNoIENhcnRcbmNvbnN0IHVwZGF0ZUNhcnRDb3VudCA9ICgpID0+IHtcbiAgY29uc3QgY2FydENvdW50SXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjY2FydENvdW50JylcbiAgY29uc29sZS5sb2coY2FydENvdW50SXRlbXMpXG4gIGNhcnRDb3VudEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgY29uc3QgbmV3Q2FydENvdW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhcnRIZWFkZXInKS5kYXRhc2V0LmNhcnRDb3VudFxuICAgIGxldCBwcmVwZW5kQ29udGVudCA9ICcnXG4gICAgbGV0IGFwcGVuZENvbnRlbnQgPSAnJ1xuICAgIGlmIChuZXdDYXJ0Q291bnQgPiAwKSB7XG4gICAgICBpZiAoaXRlbS5kYXRhc2V0LmVtcHR5SGlkZSkge1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5kYXRhc2V0LnByZXBlbmQpIHtcbiAgICAgICAgcHJlcGVuZENvbnRlbnQgPSBpdGVtLmRhdGFzZXQucHJlcGVuZFxuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uZGF0YXNldC5hcHBlbmQpIHtcbiAgICAgICAgYXBwZW5kQ29udGVudCA9IGl0ZW0uZGF0YXNldC5hcHBlbmRcbiAgICAgIH1cbiAgICAgIGl0ZW0uaW5uZXJIVE1MID0gcHJlcGVuZENvbnRlbnQgKyBuZXdDYXJ0Q291bnQgKyBhcHBlbmRDb250ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpdGVtLmRhdGFzZXQuZW1wdHlIaWRlKSB7XG4gICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJylcbiAgICAgIH1cbiAgICAgIGl0ZW0uaW5uZXJIVE1MID0gbnVsbFxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCByZWZyZXNoQ2FydCA9IChmdWxsUmVmcmVzaCA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IHNlY3Rpb25UaXRsZSA9ICdwYWdlX2NhcnQtcGFuZWwnXG4gIGNvbnN0IGNhcnREcmF3ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2hvcGlmeS1zZWN0aW9uLScgKyBzZWN0aW9uVGl0bGUgKyAnICNjYXJ0Q29udGVudCcpXG4gIGlmICghY2FydERyYXdlcikge1xuICAgIC8vIERvbid0IHJ1biBpZiBubyBjYXJ0IGRyYXdlciBzZWN0aW9uIGlzIGZvdW5kXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmZXRjaCh3aW5kb3cuU2hvcGlmeS5yb3V0ZXMucm9vdCArIFwiP3NlY3Rpb25zPVwiICsgc2VjdGlvblRpdGxlKVxuICAgIC50aGVuKHJlcyA9PiByZXMuanNvbigpKVxuICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50Q2FydERyYXdlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzaG9waWZ5LXNlY3Rpb24tJyArIHNlY3Rpb25UaXRsZSArICcgI2NhcnRDb250ZW50JylcblxuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgIGVsLmlubmVySFRNTCA9IHJlc1tzZWN0aW9uVGl0bGVdXG4gICAgICBjb25zdCBvbGRDYXJ0Q291bnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2hvcGlmeS1zZWN0aW9uLScgKyBzZWN0aW9uVGl0bGUgKyAnICNjYXJ0SGVhZGVyJykuZGF0YXNldC5jYXJ0Q291bnRcbiAgICAgIGNvbnN0IG5ld0NhcnRDb3VudCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJyNjYXJ0SGVhZGVyJykuZGF0YXNldC5jYXJ0Q291bnRcblxuICAgICAgY29uc3Qgb2xkbGluZUNvdW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3Nob3BpZnktc2VjdGlvbi0nICsgc2VjdGlvblRpdGxlICsgJyAjY2FydExpbmVJdGVtJyk/Lmxlbmd0aFxuICAgICAgY29uc3QgbmV3bGluZUNvdW50ID0gZWwucXVlcnlTZWxlY3RvckFsbCgnI3Nob3BpZnktc2VjdGlvbi0nICsgc2VjdGlvblRpdGxlICsgJyAjY2FydExpbmVJdGVtJyk/Lmxlbmd0aFxuXG4gICAgICBpZiAobmV3Q2FydENvdW50ID09IDAgfHwgb2xkQ2FydENvdW50ID09IDAgfHwgKG9sZGxpbmVDb3VudCAhPT0gbmV3bGluZUNvdW50KSkge1xuICAgICAgICBmdWxsUmVmcmVzaCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgZnVsbFJlZnJlc2ggPSB0cnVlXG5cbiAgICAgIGlmIChmdWxsUmVmcmVzaCkge1xuICAgICAgICAvLyBGdWxsIENhcnQgUmVmcmVzaFxuICAgICAgICBjb25zdCBjYXJ0Q29udGVudCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJyNjYXJ0Q29udGVudCcpXG4gICAgICAgIGNvbnN0IHVwZGF0ZUl0ZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3Nob3BpZnktc2VjdGlvbi0nICsgc2VjdGlvblRpdGxlICsgJyAjY2FydFVwZGF0ZScpXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRJdGVtcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJyNzaG9waWZ5LXNlY3Rpb24tJyArIHNlY3Rpb25UaXRsZSArICcgI2NhcnRVcGRhdGUnKVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coY2FydENvbnRlbnQpXG4gICAgICAgIGNvbnNvbGUubG9nKHVwZGF0ZUl0ZW1zKVxuICAgICAgICBjb25zb2xlLmxvZyh1cGRhdGVkSXRlbXMpXG4gICAgICAgIFxuICAgICAgICBjdXJyZW50Q2FydERyYXdlci5vdXRlckhUTUwgPSBjYXJ0Q29udGVudC5vdXRlckhUTUxcbiAgICAgICAgdXBkYXRlSXRlbXM/LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRJdGVtc1tpbmRleF0/LmlubmVySFRNTCAmJiBpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmlubmVySFRNTCA9IHVwZGF0ZWRJdGVtc1tpbmRleF0uaW5uZXJIVE1MXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB1cGRhdGVDYXJ0Q291bnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlIENhcnQgUGllY2VzXG4gICAgICAgIGNvbnN0IHVwZGF0ZUl0ZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3Nob3BpZnktc2VjdGlvbi0nICsgc2VjdGlvblRpdGxlICsgJyAjY2FydFVwZGF0ZScpXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRJdGVtcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJyNzaG9waWZ5LXNlY3Rpb24tJyArIHNlY3Rpb25UaXRsZSArICcgI2NhcnRVcGRhdGUnKVxuICAgICAgICBcbiAgICAgICAgdXBkYXRlSXRlbXM/LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRJdGVtc1tpbmRleF0/LmlubmVySFRNTCAmJiBpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmlubmVySFRNTCA9IHVwZGF0ZWRJdGVtc1tpbmRleF0uaW5uZXJIVE1MXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB1cGRhdGVDYXJ0Q291bnQoKVxuICAgICAgfVxuICAgIH0pXG59XG5cbi8vIFJlbW92ZSBDYXJ0IEl0ZW1cbmlmICghY3VzdG9tRWxlbWVudHMuZ2V0KFwiY2FydC1yZW1vdmUtaXRlbVwiKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXG4gICAgXCJjYXJ0LXJlbW92ZS1pdGVtXCIsXG4gICAgY2xhc3MgQ2FydFJlbW92ZUl0ZW0gZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYXJ0UmVtb3ZlQnV0dG9uID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiLmNhcnQtcmVtb3ZlLWl0ZW1cIik7XG4gICAgICAgIHRoaXMuY2FydFJlbW92ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgbGV0IGZvcm1EYXRhID0ge1xuICAgICAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgICAgICBbZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0Lml0ZW1JZF06IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChldmVudC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaXRlbUlkLmluY2x1ZGVzKCcsICcpKSB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYW50SWRzID0gZXZlbnQ/LmN1cnJlbnRUYXJnZXQ/LmRhdGFzZXQ/Lml0ZW1JZC5zcGxpdCgnLCAnKT8uZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gJycpXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVzT2JqID0ge31cbiAgICAgICAgICAgIGlmICh2YXJpYW50SWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyaWFudElkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVzT2JqW2lkXSA9IDBcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybURhdGEgPSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXM6IHVwZGF0ZXNPYmpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgZmV0Y2god2luZG93LlNob3BpZnkucm91dGVzLnJvb3QgKyBcImNhcnQvdXBkYXRlLmpzXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhKSxcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgcmVmcmVzaENhcnQodHJ1ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbi8vIFVwZGF0ZSBDYXJ0IFF1YW50aXR5XG5pZiAoIWN1c3RvbUVsZW1lbnRzLmdldChcImNhcnQtcXVhbnRpdHktYWRqdXN0XCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcImNhcnQtcXVhbnRpdHktYWRqdXN0XCIsXG4gICAgY2xhc3MgUXVhbnRpdHlBZGp1c3QgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5xdWFudGl0eUNoYW5nZUJ1dHRvbnMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoXCIucXVhbnRpdHktY2hhbmdlXCIpO1xuICAgICAgICB0aGlzLm9uUXVhbnRpdHlDaGFuZ2VCdXR0b25DbGljayA9IHRoaXMub25RdWFudGl0eUNoYW5nZUJ1dHRvbkNsaWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5xdWFudGl0eUNoYW5nZUJ1dHRvbnMuZm9yRWFjaCgocXVhbnRpdHlDaGFuZ2VCdXR0b24pID0+IHtcbiAgICAgICAgICBxdWFudGl0eUNoYW5nZUJ1dHRvbi5vbmNsaWNrID0gdGhpcy5vblF1YW50aXR5Q2hhbmdlQnV0dG9uQ2xpY2s7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvblF1YW50aXR5Q2hhbmdlQnV0dG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcXVhbnRpdHlDaGFuZ2VCdXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLmdldFF1YW50aXR5RGl2RnJvbUNoYW5nZUJ1dHRvbihxdWFudGl0eUNoYW5nZUJ1dHRvbikuY2xhc3NMaXN0LmFkZChcbiAgICAgICAgICBcIm9wYWNpdHktMFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGl0ZW1JZCA9IHBhcnNlSW50KFxuICAgICAgICAgIHF1YW50aXR5Q2hhbmdlQnV0dG9uLmdldEF0dHJpYnV0ZShcImRhdGEtcHJvZHVjdC1pZFwiKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpdGVtUXVhbnRpdHkgPSBwYXJzZUludChcbiAgICAgICAgICBxdWFudGl0eUNoYW5nZUJ1dHRvbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5ldy1xdWFudGl0eVwiKVxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBmb3JtRGF0YSA9IHtcbiAgICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgICBbaXRlbUlkXTogaXRlbVF1YW50aXR5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdWNjZXNzSGFuZGxlciA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHF1YW50aXR5Q2hhbmdlQnV0dG9uLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5nZXRRdWFudGl0eURpdkZyb21DaGFuZ2VCdXR0b24ocXVhbnRpdHlDaGFuZ2VCdXR0b24pLmlubmVySFRNTCA9XG4gICAgICAgICAgICBpdGVtUXVhbnRpdHk7XG4gICAgICAgICAgdGhpcy5nZXRRdWFudGl0eURpdkZyb21DaGFuZ2VCdXR0b24oXG4gICAgICAgICAgICBxdWFudGl0eUNoYW5nZUJ1dHRvblxuICAgICAgICAgICkuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKTtcblxuICAgICAgICAgIGNvbnN0IGRlY3JlYXNlUXVhbnRpdHlCdXR0b24gPSBwYXJlbnQucXVlcnlTZWxlY3RvcihcIi5xdWFudGl0eS1kb3duXCIpO1xuICAgICAgICAgIGRlY3JlYXNlUXVhbnRpdHlCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgXCJkYXRhLW5ldy1xdWFudGl0eVwiLFxuICAgICAgICAgICAgaXRlbVF1YW50aXR5IC0gMVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCBpbmNyZWFzZVF1YW50aXR5QnV0dG9uID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoXCIucXVhbnRpdHktdXBcIik7XG4gICAgICAgICAgaW5jcmVhc2VRdWFudGl0eUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBcImRhdGEtbmV3LXF1YW50aXR5XCIsXG4gICAgICAgICAgICBpdGVtUXVhbnRpdHkgKyAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9O1xuICAgICAgICBzdWNjZXNzSGFuZGxlciA9IHN1Y2Nlc3NIYW5kbGVyLmJpbmQocXVhbnRpdHlDaGFuZ2VCdXR0b24pO1xuICAgICAgICBmZXRjaCh3aW5kb3cuU2hvcGlmeS5yb3V0ZXMucm9vdCArIFwiY2FydC91cGRhdGUuanNcIiwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmb3JtRGF0YSksXG4gICAgICAgIH0pXG4gICAgICAgICAgLy8gLnRoZW4oKGRhdGEpID0+IHtjb25zb2xlLmxvZyhkYXRhKX0pXG4gICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHN1Y2Nlc3NIYW5kbGVyKGRhdGEpKVxuICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZWZyZXNoQ2FydCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jYXJ0LWl0ZW0tY291bnRcIikuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGRhdGEuaXRlbV9jb3VudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdldFF1YW50aXR5RGl2RnJvbUNoYW5nZUJ1dHRvbihidXR0b25EaXYpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gYnV0dG9uRGl2LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3RvcihcIi5xdWFudGl0eS1jdXJyZW50XCIpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuLy8gRGlzY291bnQgRm9ybVxuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoXCJkaXNjb3VudC1mb3JtXCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcImRpc2NvdW50LWZvcm1cIixcbiAgICBjbGFzcyBEaXNjb3VudEZvcm0gZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cInRleHRcIl0nKTtcbiAgICAgICAgdGhpcy5idXR0b24gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbicpO1xuICAgICAgICB0aGlzLnN0YXR1c01lc3NhZ2UgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5kaXNjb3VudC1zdGF0dXMnKTtcblxuICAgICAgICAvLyBCaW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHRoaXMub25JbnB1dENoYW5nZSA9IHRoaXMub25JbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU3VibWl0ID0gdGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uS2V5RG93biA9IHRoaXMub25LZXlEb3duLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gU2V0IGluaXRpYWwgYnV0dG9uIHN0YXRlXG4gICAgICAgIHRoaXMudXBkYXRlQnV0dG9uU3RhdGUoKTtcblxuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uSW5wdXRDaGFuZ2UpO1xuICAgICAgICB0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bik7XG4gICAgICAgIHRoaXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vblN1Ym1pdCk7XG4gICAgICB9XG5cbiAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoIXRoaXMuYnV0dG9uLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uU3VibWl0KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25JbnB1dENoYW5nZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVCdXR0b25TdGF0ZSgpO1xuICAgICAgICAvLyBDbGVhciBzdGF0dXMgbWVzc2FnZSB3aGVuIHVzZXIgc3RhcnRzIHR5cGluZ1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNNZXNzYWdlKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXNNZXNzYWdlLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgdGhpcy5zdGF0dXNNZXNzYWdlLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUJ1dHRvblN0YXRlKCkge1xuICAgICAgICBjb25zdCBoYXNWYWx1ZSA9IHRoaXMuaW5wdXQudmFsdWUudHJpbSgpLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMuYnV0dG9uLmRpc2FibGVkID0gIWhhc1ZhbHVlO1xuXG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktNTAnLCAnY3Vyc29yLW5vdC1hbGxvd2VkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5idXR0b24uY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS01MCcsICdjdXJzb3Itbm90LWFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaG93U3RhdHVzKG1lc3NhZ2UsIGlzRXJyb3IgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzTWVzc2FnZSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuc3RhdHVzTWVzc2FnZS50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc3RhdHVzTWVzc2FnZS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcblxuICAgICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzTWVzc2FnZS5jbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyZWVuJyk7XG4gICAgICAgICAgdGhpcy5zdGF0dXNNZXNzYWdlLmNsYXNzTGlzdC5hZGQoJ3RleHQtZXJyb3InKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXR1c01lc3NhZ2UuY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1lcnJvcicpO1xuICAgICAgICAgIHRoaXMuc3RhdHVzTWVzc2FnZS5jbGFzc0xpc3QuYWRkKCd0ZXh0LWdyZWVuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25TdWJtaXQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBkaXNjb3VudENvZGUgPSB0aGlzLmlucHV0LnZhbHVlLnRyaW0oKTtcbiAgICAgICAgaWYgKCFkaXNjb3VudENvZGUpIHJldHVybjtcblxuICAgICAgICAvLyBEaXNhYmxlIGJ1dHRvbiBhbmQgc2hvdyBsb2FkaW5nIHN0YXRlXG4gICAgICAgIHRoaXMuYnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idXR0b24uY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS01MCcpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSB0aGlzLmJ1dHRvbi50ZXh0Q29udGVudDtcbiAgICAgICAgdGhpcy5idXR0b24udGV4dENvbnRlbnQgPSAnQXBwbHlpbmcuLi4nO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBjYXJ0IHN0YXRlIGJlZm9yZSBhcHBseWluZyBkaXNjb3VudFxuICAgICAgICBsZXQgY2FydEJlZm9yZURpc2NvdW50ID0gbnVsbDtcblxuICAgICAgICBmZXRjaCh3aW5kb3cuU2hvcGlmeS5yb3V0ZXMucm9vdCArICdjYXJ0LmpzJylcbiAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgICAudGhlbihjYXJ0ID0+IHtcbiAgICAgICAgICAgIGNhcnRCZWZvcmVEaXNjb3VudCA9IGNhcnQ7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGRpc2NvdW50IGNvZGVcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh3aW5kb3cuU2hvcGlmeS5yb3V0ZXMucm9vdCArICdkaXNjb3VudC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRpc2NvdW50Q29kZSkpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIFNob3BpZnkgaGFzIHByb2Nlc3NlZCB0aGUgZGlzY291bnRcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBSZWZyZXNoIHRoZSBjYXJ0IHRvIHNob3cgdXBkYXRlZCB0b3RhbHNcbiAgICAgICAgICAgIHJlZnJlc2hDYXJ0KHRydWUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBkaXNjb3VudCB3YXMgYXBwbGllZCBieSBmZXRjaGluZyBjYXJ0IGFnYWluXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2god2luZG93LlNob3BpZnkucm91dGVzLnJvb3QgKyAnY2FydC5qcycpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG4gICAgICAgICAgLnRoZW4oY2FydCA9PiB7XG4gICAgICAgICAgICAvLyBSZXNldCBidXR0b24gc3RhdGVcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLnRleHRDb250ZW50ID0gb3JpZ2luYWxUZXh0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCdXR0b25TdGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBkaXNjb3VudCB3YXMgYXBwbGllZFxuICAgICAgICAgICAgaWYgKGNhcnQuY2FydF9sZXZlbF9kaXNjb3VudF9hcHBsaWNhdGlvbnMgJiYgY2FydC5jYXJ0X2xldmVsX2Rpc2NvdW50X2FwcGxpY2F0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFwcGxpZWREaXNjb3VudCA9IGNhcnQuY2FydF9sZXZlbF9kaXNjb3VudF9hcHBsaWNhdGlvbnMuZmluZChcbiAgICAgICAgICAgICAgICBkID0+IGQudGl0bGUudG9Mb3dlckNhc2UoKSA9PT0gZGlzY291bnRDb2RlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGFwcGxpZWREaXNjb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1N0YXR1cyhgRGlzY291bnQgY29kZSBcIiR7ZGlzY291bnRDb2RlfVwiIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5IWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGlzY291bnQgd2Fzbid0IGFwcGxpZWQgLSBkZXRlcm1pbmUgd2h5XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gYERpc2NvdW50IGNvZGUgXCIke2Rpc2NvdW50Q29kZX1cIiBjb3VsZCBub3QgYmUgYXBwbGllZC5gO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjYXJ0IGlzIGVtcHR5XG4gICAgICAgICAgICBpZiAoIWNhcnQuaXRlbXMgfHwgY2FydC5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICcgWW91ciBjYXJ0IGlzIGVtcHR5Lic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjYXJ0IHRvdGFsIGlzIHRvbyBsb3cgKGNvbW1vbiBtaW5pbXVtIHB1cmNoYXNlIHJlcXVpcmVtZW50KVxuICAgICAgICAgICAgZWxzZSBpZiAoY2FydEJlZm9yZURpc2NvdW50ICYmIGNhcnQudG90YWxfcHJpY2UgPCAxMDApIHsgLy8gTGVzcyB0aGFuICQxXG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnIFRoaXMgZGlzY291bnQgbWF5IHJlcXVpcmUgYSBtaW5pbXVtIHB1cmNoYXNlIGFtb3VudC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBpdGVtcyB0aGF0IG1pZ2h0IGJlIGV4Y2x1ZGVkXG4gICAgICAgICAgICBlbHNlIGlmIChjYXJ0Lml0ZW1zICYmIGNhcnQuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJyBUaGlzIGNvZGUgbWF5IGJlIGludmFsaWQsIGV4cGlyZWQsIG9yIG5vdCBhcHBsaWNhYmxlIHRvIGl0ZW1zIGluIHlvdXIgY2FydC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnIFBsZWFzZSBjaGVjayB0aGUgY29kZSBhbmQgdHJ5IGFnYWluLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2hvd1N0YXR1cyhlcnJvck1lc3NhZ2UsIHRydWUpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYXBwbHlpbmcgZGlzY291bnQ6JywgZXJyb3IpO1xuXG4gICAgICAgICAgICAvLyBSZXNldCBidXR0b24gc3RhdGVcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLnRleHRDb250ZW50ID0gb3JpZ2luYWxUZXh0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCdXR0b25TdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5zaG93U3RhdHVzKCdFcnJvciBhcHBseWluZyBkaXNjb3VudCBjb2RlLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uIGFuZCB0cnkgYWdhaW4uJywgdHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG4vLyBSZW1vdmUgRGlzY291bnRcbmlmICghY3VzdG9tRWxlbWVudHMuZ2V0KFwiZGlzY291bnQtcmVtb3ZlXCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcImRpc2NvdW50LXJlbW92ZVwiLFxuICAgIGNsYXNzIERpc2NvdW50UmVtb3ZlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcblxuICAgICAgICAvLyBCaW5kIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgdGhpcy5vblJlbW92ZSA9IHRoaXMub25SZW1vdmUuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgdGhpcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uUmVtb3ZlKTtcbiAgICAgIH1cblxuICAgICAgb25SZW1vdmUoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBEaXNhYmxlIGJ1dHRvbiBhbmQgYWRkIGxvYWRpbmcgc3RhdGVcbiAgICAgICAgdGhpcy5idXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdvcGFjaXR5LTUwJyk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1JlbW92aW5nIGRpc2NvdW50Li4uJyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGRpc2NvdW50IGJ5IHNlbmRpbmcgZW1wdHkgc3RyaW5nIHRvIC9jYXJ0L3VwZGF0ZS5qc1xuICAgICAgICBmZXRjaCh3aW5kb3cuU2hvcGlmeS5yb3V0ZXMucm9vdCArICdjYXJ0L3VwZGF0ZS5qcycsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZGlzY291bnQ6ICcnIC8vIEVtcHR5IHN0cmluZyByZW1vdmVzIHRoZSBkaXNjb3VudFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0Rpc2NvdW50IHJlbW92ZWQ6JywgZGF0YSk7XG5cbiAgICAgICAgICAvLyBSZWZyZXNoIHRoZSBjYXJ0IHRvIHNob3cgdXBkYXRlZCB0b3RhbHNcbiAgICAgICAgICByZWZyZXNoQ2FydCh0cnVlKTtcblxuICAgICAgICAgIC8vIFJlLWVuYWJsZSBidXR0b25cbiAgICAgICAgICB0aGlzLmJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktNTAnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGRpc2NvdW50OicsIGVycm9yKTtcblxuICAgICAgICAgIC8vIFJlLWVuYWJsZSBidXR0b25cbiAgICAgICAgICB0aGlzLmJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktNTAnKTtcblxuICAgICAgICAgIC8vIFN0aWxsIHRyeSB0byByZWZyZXNoIGNhcnRcbiAgICAgICAgICByZWZyZXNoQ2FydCh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICApO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/entrypoints/cart.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/collapsible.js":
/*!****************************************!*\
  !*** ./src/entrypoints/collapsible.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toggleCollapsibleItem: () => (/* binding */ toggleCollapsibleItem)\n/* harmony export */ });\nconst toggleCollapsibleItem = (content, icon, expand) => {\n  if (expand === \"inherit\") {\n    expand = content.ariaHidden === \"true\";\n  }\n  if (expand) {\n    content.ariaHidden = \"false\";\n    if (icon) {\n      icon.dataset.icon = \"minus\";\n    }\n  } else {\n    content.ariaHidden = \"true\";\n    if (icon) {\n      icon.dataset.icon = \"plus\";\n    }\n  }\n};\nif (!customElements.get(\"collapsible-item\")) {\n  customElements.define(\n    \"collapsible-item\",\n    class collapsibleItem extends HTMLElement {\n      constructor() {\n        super();\n      }\n      connectedCallback() {\n        setTimeout(() => {\n          this.trigger = this.querySelectorAll('[data-collapsible=\"trigger\"]');\n          this.content = this.querySelector('[data-collapsible=\"content\"]');\n          this.icon = this.querySelector('[data-collapsible=\"icon\"] .animated-icon');\n          if (!this.content) {\n            console.error(\"collapsible-item: No content element found\", this);\n            return;\n          }\n          this.content.ariaHidden = \"true\";\n          this.trigger.forEach((item) => {\n            item.addEventListener(\"click\", (event) => {\n              toggleCollapsibleItem(this.content, this.icon, \"inherit\");\n            });\n          });\n        }, 0);\n      }\n    }\n  );\n}\nif (!customElements.get(\"accordion-list\")) {\n  customElements.define(\n    \"accordion-list\",\n    class accordionList extends HTMLElement {\n      constructor() {\n        super();\n      }\n      connectedCallback() {\n        setTimeout(() => {\n          this.trigger = this.querySelectorAll('[data-collapsible=\"trigger\"]');\n          this.content = this.querySelectorAll('[data-collapsible=\"content\"]');\n          this.collapsibleItems = this.querySelectorAll(\"collapsible-item\");\n          if (this.dataset.initialOpen) {\n            const item = this.collapsibleItems[this.dataset.initialOpen];\n            const content = item.querySelector('[data-collapsible=\"content\"]');\n            const icon = item.querySelector('[data-collapsible=\"icon\"] .animated-icon');\n            toggleCollapsibleItem(content, icon, true);\n          }\n          this.trigger.forEach((item) => {\n            item.addEventListener(\"click\", (event) => {\n              const parent = item.closest(\"collapsible-item\");\n              this.collapsibleItems.forEach((item2) => {\n                const content = item2.querySelector('[data-collapsible=\"content\"]');\n                const icon = item2.querySelector('[data-collapsible=\"icon\"] .animated-icon');\n                if (item2.id !== parent.id) {\n                  toggleCollapsibleItem(content, icon, false);\n                }\n              });\n            });\n          });\n        }, 0);\n      }\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZW50cnlwb2ludHMvY29sbGFwc2libGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU0sd0JBQXdCLENBQUMsU0FBUyxNQUFNLFdBQVc7QUFFOUQsTUFBSSxXQUFXLFdBQVc7QUFDeEIsYUFBUyxRQUFRLGVBQWU7QUFBQSxFQUNsQztBQUVBLE1BQUksUUFBUTtBQUNWLFlBQVEsYUFBYTtBQUNyQixRQUFJLE1BQU07QUFDUixXQUFLLFFBQVEsT0FBTztBQUFBLElBQ3RCO0FBQUEsRUFDRixPQUFPO0FBQ0wsWUFBUSxhQUFhO0FBQ3JCLFFBQUksTUFBTTtBQUNSLFdBQUssUUFBUSxPQUFPO0FBQUEsSUFDdEI7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxJQUFJLENBQUMsZUFBZSxJQUFJLGtCQUFrQixHQUFHO0FBQzNDLGlCQUFlO0FBQUEsSUFDYjtBQUFBLElBQ0EsTUFBTSx3QkFBd0IsWUFBWTtBQUFBLE1BQ3hDLGNBQWM7QUFDWixjQUFNO0FBQUEsTUFDUjtBQUFBLE1BRUEsb0JBQW9CO0FBRWxCLG1CQUFXLE1BQU07QUFDZixlQUFLLFVBQVUsS0FBSyxpQkFBaUIsOEJBQThCO0FBQ25FLGVBQUssVUFBVSxLQUFLLGNBQWMsOEJBQThCO0FBQ2hFLGVBQUssT0FBTyxLQUFLLGNBQWMsMENBQTBDO0FBRXpFLGNBQUksQ0FBQyxLQUFLLFNBQVM7QUFDakIsb0JBQVEsTUFBTSw4Q0FBOEMsSUFBSTtBQUNoRTtBQUFBLFVBQ0Y7QUFFQSxlQUFLLFFBQVEsYUFBYTtBQUUxQixlQUFLLFFBQVEsUUFBUSxVQUFRO0FBQzNCLGlCQUFLLGlCQUFpQixTQUFTLFdBQVM7QUFDdEMsb0NBQXNCLEtBQUssU0FBUyxLQUFLLE1BQU0sU0FBUztBQUFBLFlBQzFELENBQUM7QUFBQSxVQUNILENBQUM7QUFBQSxRQUNILEdBQUcsQ0FBQztBQUFBLE1BQ047QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGO0FBRUEsSUFBSSxDQUFDLGVBQWUsSUFBSSxnQkFBZ0IsR0FBRztBQUN6QyxpQkFBZTtBQUFBLElBQ2I7QUFBQSxJQUNBLE1BQU0sc0JBQXNCLFlBQVk7QUFBQSxNQUN0QyxjQUFjO0FBQ1osY0FBTTtBQUFBLE1BQ1I7QUFBQSxNQUVBLG9CQUFvQjtBQUVsQixtQkFBVyxNQUFNO0FBQ2YsZUFBSyxVQUFVLEtBQUssaUJBQWlCLDhCQUE4QjtBQUNuRSxlQUFLLFVBQVUsS0FBSyxpQkFBaUIsOEJBQThCO0FBQ25FLGVBQUssbUJBQW1CLEtBQUssaUJBQWlCLGtCQUFrQjtBQUVoRSxjQUFJLEtBQUssUUFBUSxhQUFhO0FBQzVCLGtCQUFNLE9BQU8sS0FBSyxpQkFBaUIsS0FBSyxRQUFRLFdBQVc7QUFDM0Qsa0JBQU0sVUFBVSxLQUFLLGNBQWMsOEJBQThCO0FBQ2pFLGtCQUFNLE9BQU8sS0FBSyxjQUFjLDBDQUEwQztBQUMxRSxrQ0FBc0IsU0FBUyxNQUFNLElBQUk7QUFBQSxVQUMzQztBQUVBLGVBQUssUUFBUSxRQUFRLFVBQVE7QUFDM0IsaUJBQUssaUJBQWlCLFNBQVMsV0FBUztBQUN0QyxvQkFBTSxTQUFTLEtBQUssUUFBUSxrQkFBa0I7QUFDOUMsbUJBQUssaUJBQWlCLFFBQVEsQ0FBQUEsVUFBUTtBQUNwQyxzQkFBTSxVQUFVQSxNQUFLLGNBQWMsOEJBQThCO0FBQ2pFLHNCQUFNLE9BQU9BLE1BQUssY0FBYywwQ0FBMEM7QUFDMUUsb0JBQUlBLE1BQUssT0FBTyxPQUFPLElBQUk7QUFFekIsd0NBQXNCLFNBQVMsTUFBTSxLQUFLO0FBQUEsZ0JBQzVDO0FBQUEsY0FDRixDQUFDO0FBQUEsWUFDSCxDQUFDO0FBQUEsVUFDSCxDQUFDO0FBQUEsUUFDSCxHQUFHLENBQUM7QUFBQSxNQUNOO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpZnktc3RhcnRlci8uL3NyYy9lbnRyeXBvaW50cy9jb2xsYXBzaWJsZS5qcz9iZGU3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB0b2dnbGVDb2xsYXBzaWJsZUl0ZW0gPSAoY29udGVudCwgaWNvbiwgZXhwYW5kKSA9PiB7XG4gIC8vIFVzZSBhcmVhSGlkZGVuIHRvIHRvZ2dsZSB2aXNpYmlsaXR5XG4gIGlmIChleHBhbmQgPT09ICdpbmhlcml0Jykge1xuICAgIGV4cGFuZCA9IGNvbnRlbnQuYXJpYUhpZGRlbiA9PT0gJ3RydWUnXG4gIH1cbiAgLy9cbiAgaWYgKGV4cGFuZCkge1xuICAgIGNvbnRlbnQuYXJpYUhpZGRlbiA9ICdmYWxzZSdcbiAgICBpZiAoaWNvbikge1xuICAgICAgaWNvbi5kYXRhc2V0Lmljb24gPSAnbWludXMnXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRlbnQuYXJpYUhpZGRlbiA9ICd0cnVlJ1xuICAgIGlmIChpY29uKSB7XG4gICAgICBpY29uLmRhdGFzZXQuaWNvbiA9ICdwbHVzJ1xuICAgIH1cbiAgfVxufVxuXG5pZiAoIWN1c3RvbUVsZW1lbnRzLmdldChcImNvbGxhcHNpYmxlLWl0ZW1cIikpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFxuICAgIFwiY29sbGFwc2libGUtaXRlbVwiLFxuICAgIGNsYXNzIGNvbGxhcHNpYmxlSXRlbSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gVXNlIHNldFRpbWVvdXQgdG8gZW5zdXJlIGNoaWxkIGVsZW1lbnRzIGFyZSBmdWxseSBwYXJzZWRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jb2xsYXBzaWJsZT1cInRyaWdnZXJcIl0nKVxuICAgICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMucXVlcnlTZWxlY3RvcignW2RhdGEtY29sbGFwc2libGU9XCJjb250ZW50XCJdJylcbiAgICAgICAgICB0aGlzLmljb24gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNvbGxhcHNpYmxlPVwiaWNvblwiXSAuYW5pbWF0ZWQtaWNvbicpXG5cbiAgICAgICAgICBpZiAoIXRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignY29sbGFwc2libGUtaXRlbTogTm8gY29udGVudCBlbGVtZW50IGZvdW5kJywgdGhpcylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29udGVudC5hcmlhSGlkZGVuID0gJ3RydWUnXG5cbiAgICAgICAgICB0aGlzLnRyaWdnZXIuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgIHRvZ2dsZUNvbGxhcHNpYmxlSXRlbSh0aGlzLmNvbnRlbnQsIHRoaXMuaWNvbiwgJ2luaGVyaXQnKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LCAwKVxuICAgICAgfVxuICAgIH1cbiAgKVxufVxuXG5pZiAoIWN1c3RvbUVsZW1lbnRzLmdldChcImFjY29yZGlvbi1saXN0XCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcImFjY29yZGlvbi1saXN0XCIsXG4gICAgY2xhc3MgYWNjb3JkaW9uTGlzdCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gVXNlIHNldFRpbWVvdXQgdG8gZW5zdXJlIGNoaWxkIGVsZW1lbnRzIGFyZSBmdWxseSBwYXJzZWRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jb2xsYXBzaWJsZT1cInRyaWdnZXJcIl0nKVxuICAgICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY29sbGFwc2libGU9XCJjb250ZW50XCJdJylcbiAgICAgICAgICB0aGlzLmNvbGxhcHNpYmxlSXRlbXMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvbGxhcHNpYmxlLWl0ZW0nKVxuXG4gICAgICAgICAgaWYgKHRoaXMuZGF0YXNldC5pbml0aWFsT3Blbikge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuY29sbGFwc2libGVJdGVtc1t0aGlzLmRhdGFzZXQuaW5pdGlhbE9wZW5dXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gaXRlbS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb2xsYXBzaWJsZT1cImNvbnRlbnRcIl0nKVxuICAgICAgICAgICAgY29uc3QgaWNvbiA9IGl0ZW0ucXVlcnlTZWxlY3RvcignW2RhdGEtY29sbGFwc2libGU9XCJpY29uXCJdIC5hbmltYXRlZC1pY29uJylcbiAgICAgICAgICAgIHRvZ2dsZUNvbGxhcHNpYmxlSXRlbShjb250ZW50LCBpY29uLCB0cnVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudHJpZ2dlci5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaXRlbS5jbG9zZXN0KCdjb2xsYXBzaWJsZS1pdGVtJylcbiAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzaWJsZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGl0ZW0ucXVlcnlTZWxlY3RvcignW2RhdGEtY29sbGFwc2libGU9XCJjb250ZW50XCJdJylcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uID0gaXRlbS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb2xsYXBzaWJsZT1cImljb25cIl0gLmFuaW1hdGVkLWljb24nKVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkICE9PSBwYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIENsb3NlIG90aGVyIGl0ZW1zXG4gICAgICAgICAgICAgICAgICB0b2dnbGVDb2xsYXBzaWJsZUl0ZW0oY29udGVudCwgaWNvbiwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LCAwKVxuICAgICAgfVxuICAgIH1cbiAgKVxufSJdLCJuYW1lcyI6WyJpdGVtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/entrypoints/collapsible.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/eventbus.js":
/*!*************************************!*\
  !*** ./src/entrypoints/eventbus.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EventBus)\n/* harmony export */ });\nclass EventBus {\n  // Initialize a new event bus instance.\n  constructor() {\n    this.bus = document.createElement(\"event-bus\");\n  }\n  // Add an event listener.\n  addEventListener(event, callback) {\n    this.bus.addEventListener(event, callback);\n  }\n  /**\n   * Remove an event listener.\n   */\n  removeEventListener(event, callback) {\n    this.bus.removeEventListener(event, callback);\n  }\n  // Dispatch an event.\n  dispatchEvent(event, detail = {}) {\n    this.bus.dispatchEvent(new CustomEvent(event, { detail }));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZW50cnlwb2ludHMvZXZlbnRidXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlLE1BQU0sU0FBUztBQUFBO0FBQUEsRUFFNUIsY0FBYztBQUNaLFNBQUssTUFBTSxTQUFTLGNBQWMsV0FBVztBQUFBLEVBQy9DO0FBQUE7QUFBQSxFQUdBLGlCQUFpQixPQUFPLFVBQVU7QUFDaEMsU0FBSyxJQUFJLGlCQUFpQixPQUFPLFFBQVE7QUFBQSxFQUMzQztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0Esb0JBQW9CLE9BQU8sVUFBVTtBQUNuQyxTQUFLLElBQUksb0JBQW9CLE9BQU8sUUFBUTtBQUFBLEVBQzlDO0FBQUE7QUFBQSxFQUdBLGNBQWMsT0FBTyxTQUFTLENBQUMsR0FBRztBQUNoQyxTQUFLLElBQUksY0FBYyxJQUFJLFlBQVksT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQUEsRUFDM0Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpZnktc3RhcnRlci8uL3NyYy9lbnRyeXBvaW50cy9ldmVudGJ1cy5qcz8xMDYxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50QnVzIHtcbiAgLy8gSW5pdGlhbGl6ZSBhIG5ldyBldmVudCBidXMgaW5zdGFuY2UuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYnVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZXZlbnQtYnVzJyk7XG4gIH1cblxuICAvLyBBZGQgYW4gZXZlbnQgbGlzdGVuZXIuXG4gIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5idXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5idXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gRGlzcGF0Y2ggYW4gZXZlbnQuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIGRldGFpbCA9IHt9KSB7XG4gICAgdGhpcy5idXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHsgZGV0YWlsIH0pKTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/entrypoints/eventbus.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/global.js":
/*!***********************************!*\
  !*** ./src/entrypoints/global.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   docReady: () => (/* binding */ docReady),\n/* harmony export */   getSelectedOptions: () => (/* binding */ getSelectedOptions),\n/* harmony export */   getVariant: () => (/* binding */ getVariant)\n/* harmony export */ });\n/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/main.scss */ \"./src/styles/main.scss\");\n/* harmony import */ var _modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modal */ \"./src/entrypoints/modal.js\");\n/* harmony import */ var _cart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cart */ \"./src/entrypoints/cart.js\");\n/* harmony import */ var _collapsible__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./collapsible */ \"./src/entrypoints/collapsible.js\");\n/* harmony import */ var _inView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inView */ \"./src/entrypoints/inView.js\");\n/* harmony import */ var _inView__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_inView__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _slideshow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./slideshow */ \"./src/entrypoints/slideshow.js\");\n/* harmony import */ var _sort_filter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort-filter */ \"./src/entrypoints/sort-filter.js\");\n/* harmony import */ var _sort_filter__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_sort_filter__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"\\n\\u2554    \\u2557  Site by STUDIO HYPERLINK\\n\\u2551 \\u2560\\u2563 \\u2551  www.studiohyper.link\\n\\u255A    \\u255D  Hot Bagels, Hotter Websites\\n \");\n});\nfunction isMobileOrTablet() {\n  const ua = navigator.userAgent;\n  if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) {\n    return true;\n  } else if (/Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(\n    ua\n  )) {\n    return true;\n  }\n  return false;\n}\nconst docReady = (fn) => {\n  if (document.readyState === \"complete\" || document.readyState === \"interactive\") {\n    setTimeout(fn, 1);\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", fn);\n  }\n};\ndocReady(() => {\n  const windowHeight = window.innerHeight;\n  if (isMobileOrTablet()) {\n    document.body.style.setProperty(\"--vh\", `${windowHeight * 0.01}px`);\n  }\n});\nconst arraysEqual = (a, b) => {\n  if (a === b)\n    return true;\n  if (a == null || b == null)\n    return false;\n  if (a.length !== b.length)\n    return false;\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i])\n      return false;\n  }\n  return true;\n};\nconst getVariant = (selected, variantData) => {\n  const currentVariant = variantData.find((variant) => {\n    return arraysEqual(variant.options, selected);\n  });\n  return currentVariant;\n};\nconst getSelectedOptions = (productOptions) => {\n  const selectedOptions = [];\n  productOptions.forEach((option) => {\n    if (option.querySelector(\"select\")) {\n      const selectElement = option.querySelector(\"select\");\n      selectedOptions.push(selectElement.value);\n    } else if (option.checked) {\n      selectedOptions.push(option.value);\n    }\n  });\n  return selectedOptions;\n};\nif (!customElements.get(\"add-to-cart-form\")) {\n  customElements.define(\n    \"add-to-cart-form\",\n    class AddToCartForm extends HTMLElement {\n      constructor() {\n        super();\n        this.init();\n        const productContainer = this.closest(\"[data-product-update]\");\n        if (productContainer) {\n          productContainer.addEventListener(\"section:updated\", () => {\n            this.init();\n          });\n        }\n      }\n      init() {\n        this.addButton = this.querySelector(\".add-to-cart-btn\");\n        this.qtyInput = this.querySelector(\"input[data-input='qty']\");\n        if (!this.addButton) {\n          return void 0;\n        }\n        if (this.handleClick) {\n          this.addButton.removeEventListener(\"click\", this.handleClick);\n        }\n        this.handleClick = (event) => {\n          event.preventDefault();\n          const productOptions = this.querySelectorAll(\"variant-radios input, variant-selects\");\n          const selectedOptions = getSelectedOptions(productOptions);\n          const subscription = this.querySelector(\".rc-widget .rc-selling-plans select.rc-selling-plans-dropdown__select\");\n          const propertiesInputs = this.querySelectorAll('[name^=\"property_\"]');\n          console.log(\"propertiesInputs: \", propertiesInputs);\n          let properties = {};\n          if (propertiesInputs?.length > 0) {\n            propertiesInputs.forEach((prop) => {\n              let title = \"\";\n              let value = false;\n              if (prop?.dataset?.title) {\n                title = prop.dataset.title;\n              }\n              if (prop.type === \"fieldset\") {\n                const checkedItems = prop.querySelectorAll(\"input\");\n                const checkedValues = [];\n                checkedItems.forEach((item) => {\n                  if (item.checked) {\n                    checkedValues.push(item.value);\n                  }\n                });\n                value = checkedValues.join(\", \");\n              } else {\n                value = prop.dataset.value || prop.value;\n              }\n              if (value) {\n                properties[title] = value;\n              }\n            });\n          }\n          console.log(\"properties: \", properties);\n          let variantId = \"\";\n          let variantData = \"\";\n          if (this?.dataset?.variantId) {\n            variantId = this.dataset.variantId;\n          } else {\n            variantData = JSON.parse(this.querySelector('[type=\"application/json\"]#productJson').textContent);\n            variantId = getVariant(selectedOptions, variantData).id;\n          }\n          let formData = {\n            items: [\n              {\n                id: variantId,\n                selling_plan: subscription?.value || null,\n                quantity: this.qtyInput?.value || 1,\n                properties\n              }\n            ]\n          };\n          fetch(window.Shopify.routes.root + \"cart/add.js\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(formData)\n          }).then((data) => {\n            console.log(data);\n            (0,_cart__WEBPACK_IMPORTED_MODULE_2__.refreshCart)();\n          }).then(() => {\n            (0,_modal__WEBPACK_IMPORTED_MODULE_1__.openModal)(\"cartDrawer\");\n          }).catch((error) => {\n            console.error(\"Error:\", error);\n          });\n        };\n        this.addButton.addEventListener(\"click\", this.handleClick);\n      }\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBLGdCQUNKLGNBQWMsY0FBYyxTQUFTO0FBQUEsZ0JBQ3JDLFVBQVUsS0FBSyxVQUFVLFNBQVM7QUFBQSxnQkFDbEM7QUFBQSxjQUNGO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFFQSxnQkFBTSxPQUFPLFFBQVEsT0FBTyxPQUFPLGVBQWU7QUFBQSxZQUNoRCxRQUFRO0FBQUEsWUFDUixTQUFTO0FBQUEsY0FDUCxnQkFBZ0I7QUFBQSxZQUNsQjtBQUFBLFlBQ0EsTUFBTSxLQUFLLFVBQVUsUUFBUTtBQUFBLFVBQy9CLENBQUMsRUFDQSxLQUFLLFVBQVE7QUFDWixvQkFBUSxJQUFJLElBQUk7QUFDaEIsOERBQVcsQ0FBQztBQUFBLFVBQ2QsQ0FBQyxFQUNBLEtBQUssTUFBTTtBQUFFLDZEQUFTLENBQUMsWUFBWTtBQUFBLFVBQUUsQ0FBQyxFQUN0QyxNQUFNLENBQUMsVUFBVTtBQUNoQixvQkFBUSxNQUFNLFVBQVUsS0FBSztBQUFBLFVBQy9CLENBQUM7QUFBQSxRQUNIO0FBRUEsYUFBSyxVQUFVLGlCQUFpQixTQUFTLEtBQUssV0FBVztBQUFBLE1BQzNEO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpZnktc3RhcnRlci8uL3NyYy9lbnRyeXBvaW50cy9nbG9iYWwuanM/ZjExYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuLi9zdHlsZXMvbWFpbi5zY3NzXCI7XG5pbXBvcnQgeyBvcGVuTW9kYWwgfSBmcm9tIFwiLi9tb2RhbFwiO1xuaW1wb3J0IHsgcmVmcmVzaENhcnQgfSBmcm9tIFwiLi9jYXJ0XCI7XG5cbi8vIENvbXBvbmVudHNcbmltcG9ydCAnLi9tb2RhbCc7XG5pbXBvcnQgJy4vY29sbGFwc2libGUnO1xuaW1wb3J0ICcuL2luVmlldyc7XG5pbXBvcnQgJy4vc2xpZGVzaG93JztcbmltcG9ydCAnLi9zb3J0LWZpbHRlcic7XG5cbi8vIENvbnNvbGUgU2lnbmF0dXJlXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICBjb25zb2xlLmxvZygnXFxu4pWUICAgIOKVlyAgU2l0ZSBieSBTVFVESU8gSFlQRVJMSU5LXFxu4pWRIOKVoOKVoyDilZEgIHd3dy5zdHVkaW9oeXBlci5saW5rXFxu4pWaICAgIOKVnSAgSG90IEJhZ2VscywgSG90dGVyIFdlYnNpdGVzXFxuICcpO1xufSlcblxuLy8gVXRpbHM/XG5mdW5jdGlvbiBpc01vYmlsZU9yVGFibGV0KCkge1xuICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGlmICgvKHRhYmxldHxpcGFkfHBsYXlib29rfHNpbGspfChhbmRyb2lkKD8hLiptb2JpKSkvaS50ZXN0KHVhKSkge1xuICAgIHJldHVybiB0cnVlOyAvLyB0YWJsZXRcbiAgfSBlbHNlIGlmIChcbiAgICAvTW9iaWxlfEFuZHJvaWR8aVAoaG9uZXxvZCl8SUVNb2JpbGV8QmxhY2tCZXJyeXxLaW5kbGV8U2lsay1BY2NlbGVyYXRlZHwoaHB3fHdlYilPU3xPcGVyYSBNKG9iaXxpbmkpLy50ZXN0KFxuICAgICAgdWFcbiAgICApXG4gICkge1xuICAgIHJldHVybiB0cnVlOyAvLyBtb2JpbGVcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBjb25zdCBkb2NSZWFkeSA9IGZuID0+IHtcbiAgLy8gc2VlIGlmIERPTSBpcyBhbHJlYWR5IGF2YWlsYWJsZVxuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIikge1xuICAgICAgLy8gY2FsbCBvbiBuZXh0IGF2YWlsYWJsZSB0aWNrXG4gICAgICBzZXRUaW1lb3V0KGZuLCAxKVxuICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZm4pXG4gIH1cbn1cblxuZG9jUmVhZHkoKCkgPT4ge1xuICBjb25zdCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgaWYgKGlzTW9iaWxlT3JUYWJsZXQoKSkge1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoJy0tdmgnLCBgJHt3aW5kb3dIZWlnaHQgKiAwLjAxfXB4YClcbiAgfVxufSlcblxuY29uc3QgYXJyYXlzRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIC8vIGNvbnNvbGUubG9nKCdhcnJ5IGVxJywgYSwgYilcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIC8vIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IHRoZSBvcmRlciBvZiB0aGUgZWxlbWVudHMgaW5zaWRlXG4gIC8vIC8vIHRoZSBhcnJheSwgeW91IHNob3VsZCBzb3J0IGJvdGggYXJyYXlzIGhlcmUuXG4gIC8vIC8vIFBsZWFzZSBub3RlIHRoYXQgY2FsbGluZyBzb3J0IG9uIGFuIGFycmF5IHdpbGwgbW9kaWZ5IHRoYXQgYXJyYXkuXG4gIC8vIC8vIHlvdSBtaWdodCB3YW50IHRvIGNsb25lIHlvdXIgYXJyYXkgZmlyc3QuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gR2V0IHZhcmlhbnQgSUQgZnJvbSBzZWxlY3Rpb25cbmV4cG9ydCBjb25zdCBnZXRWYXJpYW50ID0gKHNlbGVjdGVkLCB2YXJpYW50RGF0YSkgPT4ge1xuICBjb25zdCBjdXJyZW50VmFyaWFudCA9IHZhcmlhbnREYXRhLmZpbmQoKHZhcmlhbnQpID0+IHtcbiAgICByZXR1cm4gYXJyYXlzRXF1YWwodmFyaWFudC5vcHRpb25zLCBzZWxlY3RlZClcbiAgfSk7XG4gIHJldHVybiBjdXJyZW50VmFyaWFudFxufVxuXG4vLyBHZXQgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRTZWxlY3RlZE9wdGlvbnMgPSBwcm9kdWN0T3B0aW9ucyA9PiB7XG4gIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IFtdXG4gIHByb2R1Y3RPcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICBpZiAob3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpKSB7XG4gICAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpXG4gICAgICBzZWxlY3RlZE9wdGlvbnMucHVzaChzZWxlY3RFbGVtZW50LnZhbHVlKVxuICAgIH0gZWxzZSBpZiAob3B0aW9uLmNoZWNrZWQpIHtcbiAgICAgIHNlbGVjdGVkT3B0aW9ucy5wdXNoKG9wdGlvbi52YWx1ZSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBzZWxlY3RlZE9wdGlvbnNcbn1cblxuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoXCJhZGQtdG8tY2FydC1mb3JtXCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcImFkZC10by1jYXJ0LWZvcm1cIixcbiAgICBjbGFzcyBBZGRUb0NhcnRGb3JtIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuXG4gICAgICAgIC8vIFJlaW5pdGlhbGl6ZSB3aGVuIHNlY3Rpb24gaXMgdXBkYXRlZCAoYWZ0ZXIgdmFyaWFudCBjaGFuZ2UpXG4gICAgICAgIC8vIExpc3RlbiBvbiB0aGUgcHJvZHVjdC11cGRhdGUgY29udGFpbmVyIHNpbmNlIHRoYXQncyB3aGVyZSB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZFxuICAgICAgICBjb25zdCBwcm9kdWN0Q29udGFpbmVyID0gdGhpcy5jbG9zZXN0KCdbZGF0YS1wcm9kdWN0LXVwZGF0ZV0nKTtcbiAgICAgICAgaWYgKHByb2R1Y3RDb250YWluZXIpIHtcbiAgICAgICAgICBwcm9kdWN0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3NlY3Rpb246dXBkYXRlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuYWRkQnV0dG9uID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiLmFkZC10by1jYXJ0LWJ0blwiKTtcbiAgICAgICAgdGhpcy5xdHlJbnB1dCA9IHRoaXMucXVlcnlTZWxlY3RvcihcImlucHV0W2RhdGEtaW5wdXQ9J3F0eSddXCIpO1xuICAgICAgICBpZiAoIXRoaXMuYWRkQnV0dG9uKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIG9sZCBsaXN0ZW5lciBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLmFkZEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0aGUgYm91bmQgaGFuZGxlciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IHByb2R1Y3RPcHRpb25zID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd2YXJpYW50LXJhZGlvcyBpbnB1dCwgdmFyaWFudC1zZWxlY3RzJylcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSBnZXRTZWxlY3RlZE9wdGlvbnMocHJvZHVjdE9wdGlvbnMpXG5cbiAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5yYy13aWRnZXQgLnJjLXNlbGxpbmctcGxhbnMgc2VsZWN0LnJjLXNlbGxpbmctcGxhbnMtZHJvcGRvd25fX3NlbGVjdCcpXG4gICAgICAgICAgY29uc3QgcHJvcGVydGllc0lucHV0cyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW25hbWVePVwicHJvcGVydHlfXCJdJylcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9wZXJ0aWVzSW5wdXRzOiAnLHByb3BlcnRpZXNJbnB1dHMpXG4gICAgICAgICAgXG4gICAgICAgICAgbGV0IHByb3BlcnRpZXMgPSB7fVxuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzSW5wdXRzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzSW5wdXRzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICAgIGxldCB0aXRsZSA9ICcnXG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICAgIGlmIChwcm9wPy5kYXRhc2V0Py50aXRsZSkge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gcHJvcC5kYXRhc2V0LnRpdGxlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSAnZmllbGRzZXQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZEl0ZW1zID0gcHJvcC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpXG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZFZhbHVlcyA9IFtdXG4gICAgICAgICAgICAgICAgY2hlY2tlZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWRWYWx1ZXMucHVzaChpdGVtLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGVja2VkVmFsdWVzLmpvaW4oJywgJylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3AuZGF0YXNldC52YWx1ZSB8fCBwcm9wLnZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbdGl0bGVdID0gdmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zb2xlLmxvZygncHJvcGVydGllczogJyxwcm9wZXJ0aWVzKVxuXG4gICAgICAgICAgbGV0IHZhcmlhbnRJZCA9ICcnXG4gICAgICAgICAgbGV0IHZhcmlhbnREYXRhID0gJydcbiAgICAgICAgICBpZiAodGhpcz8uZGF0YXNldD8udmFyaWFudElkKSB7XG4gICAgICAgICAgICB2YXJpYW50SWQgPSB0aGlzLmRhdGFzZXQudmFyaWFudElkXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhcmlhbnREYXRhID0gSlNPTi5wYXJzZSh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ1t0eXBlPVwiYXBwbGljYXRpb24vanNvblwiXSNwcm9kdWN0SnNvbicpLnRleHRDb250ZW50KVxuICAgICAgICAgICAgdmFyaWFudElkID0gZ2V0VmFyaWFudChzZWxlY3RlZE9wdGlvbnMsIHZhcmlhbnREYXRhKS5pZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBmb3JtRGF0YSA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFyaWFudElkLFxuICAgICAgICAgICAgICAgIHNlbGxpbmdfcGxhbjogc3Vic2NyaXB0aW9uPy52YWx1ZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiB0aGlzLnF0eUlucHV0Py52YWx1ZSB8fCAxLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZldGNoKHdpbmRvdy5TaG9waWZ5LnJvdXRlcy5yb290ICsgXCJjYXJ0L2FkZC5qc1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmb3JtRGF0YSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgICAgIHJlZnJlc2hDYXJ0KCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7IG9wZW5Nb2RhbChcImNhcnREcmF3ZXJcIikgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFkZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICB9XG4gICAgfVxuICApO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/entrypoints/global.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/inView.js":
/*!***********************************!*\
  !*** ./src/entrypoints/inView.js ***!
  \***********************************/
/***/ (() => {

eval("{if (!customElements.get(\"in-view\")) {\n  customElements.define(\n    \"in-view\",\n    class inView extends HTMLElement {\n      constructor() {\n        super();\n        const observer = new IntersectionObserver((item) => {\n          const inViewItem = item[0];\n          if (inViewItem.isIntersecting) {\n            this.classList.add(\"in-view\");\n          }\n        }, {\n          threshold: 0.1\n        });\n        observer.observe(this);\n      }\n    }\n  );\n}\nif (!customElements.get(\"parallax-view\")) {\n  customElements.define(\n    \"parallax-view\",\n    class parallaxView extends HTMLElement {\n      constructor() {\n        super();\n        this.ticking = false;\n        this.scrollEndTimer = null;\n        this.observer = new IntersectionObserver((item) => {\n          const inViewItem = item[0];\n          if (inViewItem.isIntersecting) {\n            this.classList.add(\"in-view\");\n          }\n        }, {\n          threshold: 0.5\n        });\n      }\n      connectedCallback() {\n        this.onScrollHandler = this.onScroll.bind(this);\n        window.addEventListener(\"scroll\", this.onScrollHandler, { passive: true });\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            this.updateParallax();\n          });\n        });\n        if (document.readyState === \"loading\") {\n          window.addEventListener(\"load\", () => {\n            this.updateParallax();\n          }, { once: true });\n        }\n      }\n      disconnectedCallback() {\n        window.removeEventListener(\"scroll\", this.onScrollHandler);\n        if (this.scrollEndTimer) {\n          clearTimeout(this.scrollEndTimer);\n        }\n      }\n      onScroll() {\n        if (!this.ticking) {\n          requestAnimationFrame(() => {\n            this.updateParallax();\n            this.ticking = false;\n          });\n          this.ticking = true;\n        }\n        clearTimeout(this.scrollEndTimer);\n        this.scrollEndTimer = setTimeout(() => {\n          this.updateParallax();\n        }, 100);\n      }\n      parseMarginValue(value) {\n        if (!value)\n          return 0;\n        const trimmed = value.trim();\n        const numValue = parseFloat(trimmed);\n        if (trimmed.endsWith(\"%\")) {\n          return numValue / 100 * this.offsetHeight;\n        } else if (trimmed.endsWith(\"vw\")) {\n          return numValue / 100 * window.innerWidth;\n        } else if (trimmed.endsWith(\"vh\")) {\n          return numValue / 100 * window.innerHeight;\n        } else {\n          return numValue;\n        }\n      }\n      updateParallax() {\n        const viewportHeight = window.innerHeight;\n        const scrollTop = window.scrollY;\n        const elementOffsetTop = this.offsetTop;\n        const marginTop = this.parseMarginValue(this.dataset.marginTop || this.dataset.margin);\n        const marginBottom = this.parseMarginValue(this.dataset.marginBottom || this.dataset.margin);\n        let percentage = (scrollTop + viewportHeight - elementOffsetTop - marginTop) / (viewportHeight + this.offsetHeight + marginTop + marginBottom);\n        if (percentage < 0.02) {\n          percentage = 0;\n        } else if (percentage > 0.98) {\n          percentage = 1;\n        }\n        if (percentage >= 0 && percentage <= 1) {\n          this.style.setProperty(\"--percentage\", percentage);\n        }\n      }\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waWZ5LXN0YXJ0ZXIvLi9zcmMvZW50cnlwb2ludHMvaW5WaWV3LmpzPzNkNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoXCJpbi12aWV3XCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcImluLXZpZXdcIixcbiAgICBjbGFzcyBpblZpZXcgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy9cbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5WaWV3SXRlbSA9IGl0ZW1bMF1cbiAgICAgICAgICBpZiAoaW5WaWV3SXRlbS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdpbi12aWV3Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgdGhyZXNob2xkOiAuMVxuICAgICAgICB9KTtcblxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMpXG4gICAgICAgIFxuICAgICAgfVxuXG4gICAgICBcbiAgICB9XG4gICk7XG59XG5cbmlmICghY3VzdG9tRWxlbWVudHMuZ2V0KFwicGFyYWxsYXgtdmlld1wiKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXG4gICAgXCJwYXJhbGxheC12aWV3XCIsXG4gICAgY2xhc3MgcGFyYWxsYXhWaWV3IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjcm9sbEVuZFRpbWVyID0gbnVsbDtcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBpblZpZXdJdGVtID0gaXRlbVswXVxuICAgICAgICAgIGlmIChpblZpZXdJdGVtLmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2luLXZpZXcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0aHJlc2hvbGQ6IC41XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5vblNjcm9sbEhhbmRsZXIgPSB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsSGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIFNldCBpbml0aWFsIHBlcmNlbnRhZ2UgdmFsdWUgYWZ0ZXIgbGF5b3V0IGlzIGNvbXBsZXRlXG4gICAgICAgIC8vIFVzZSBkb3VibGUgUkFGIHRvIGVuc3VyZSBhbGwgbGF5b3V0L3BhaW50IGhhcyBoYXBwZW5lZFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhcmFsbGF4KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFsc28gcmVjYWxjdWxhdGUgYWZ0ZXIgd2luZG93IGxvYWQgKGluIGNhc2UgaW1hZ2VzIGFmZmVjdCBsYXlvdXQpXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFyYWxsYXgoKTtcbiAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEVuZFRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsRW5kVGltZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uU2Nyb2xsKCkge1xuICAgICAgICBpZiAoIXRoaXMudGlja2luZykge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhcmFsbGF4KCk7XG4gICAgICAgICAgICB0aGlzLnRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnRpY2tpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIGZpbmFsIHVwZGF0ZSB3aGVuIHNjcm9sbGluZyBzdG9wc1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY3JvbGxFbmRUaW1lcik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRW5kVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVBhcmFsbGF4KCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlTWFyZ2luVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIDA7XG5cbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgY29uc3QgbnVtVmFsdWUgPSBwYXJzZUZsb2F0KHRyaW1tZWQpO1xuXG4gICAgICAgIGlmICh0cmltbWVkLmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgICAvLyBQZXJjZW50YWdlIG9mIGVsZW1lbnQgaGVpZ2h0XG4gICAgICAgICAgcmV0dXJuIChudW1WYWx1ZSAvIDEwMCkgKiB0aGlzLm9mZnNldEhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh0cmltbWVkLmVuZHNXaXRoKCd2dycpKSB7XG4gICAgICAgICAgLy8gVmlld3BvcnQgd2lkdGhcbiAgICAgICAgICByZXR1cm4gKG51bVZhbHVlIC8gMTAwKSAqIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHRyaW1tZWQuZW5kc1dpdGgoJ3ZoJykpIHtcbiAgICAgICAgICAvLyBWaWV3cG9ydCBoZWlnaHRcbiAgICAgICAgICByZXR1cm4gKG51bVZhbHVlIC8gMTAwKSAqIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IHRvIHBpeGVsc1xuICAgICAgICAgIHJldHVybiBudW1WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGVQYXJhbGxheCgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB2aWV3cG9ydCBoZWlnaHRcbiAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzY3JvbGwgdG9wXG4gICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHdpbmRvdy5zY3JvbGxZO1xuXG4gICAgICAgIC8vIEdldCB0aGUgZWxlbWVudCBvZmZzZXQgdG9wXG4gICAgICAgIGNvbnN0IGVsZW1lbnRPZmZzZXRUb3AgPSB0aGlzLm9mZnNldFRvcDtcblxuICAgICAgICAvLyBQYXJzZSBtYXJnaW4gdmFsdWVzIChzdXBwb3J0cyBweCwgJSwgdncsIHZoKVxuICAgICAgICBjb25zdCBtYXJnaW5Ub3AgPSB0aGlzLnBhcnNlTWFyZ2luVmFsdWUodGhpcy5kYXRhc2V0Lm1hcmdpblRvcCB8fCB0aGlzLmRhdGFzZXQubWFyZ2luKTtcbiAgICAgICAgY29uc3QgbWFyZ2luQm90dG9tID0gdGhpcy5wYXJzZU1hcmdpblZhbHVlKHRoaXMuZGF0YXNldC5tYXJnaW5Cb3R0b20gfHwgdGhpcy5kYXRhc2V0Lm1hcmdpbik7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBlbGVtZW50IHRoYXQncyBpbiB2aWV3XG4gICAgICAgIGxldCBwZXJjZW50YWdlID0gKHNjcm9sbFRvcCArIHZpZXdwb3J0SGVpZ2h0IC0gZWxlbWVudE9mZnNldFRvcCAtIG1hcmdpblRvcCkgLyAodmlld3BvcnRIZWlnaHQgKyB0aGlzLm9mZnNldEhlaWdodCArIG1hcmdpblRvcCArIG1hcmdpbkJvdHRvbSk7XG5cbiAgICAgICAgLy8gQ2xhbXAgYmV0d2VlbiAwIGFuZCAxLCB3aXRoIHNtYWxsIHRvbGVyYW5jZSB0byBlbnN1cmUgd2UgaGl0IGJvdW5kYXJpZXNcbiAgICAgICAgaWYgKHBlcmNlbnRhZ2UgPCAwLjAyKSB7XG4gICAgICAgICAgcGVyY2VudGFnZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyY2VudGFnZSA+IDAuOTgpIHtcbiAgICAgICAgICBwZXJjZW50YWdlID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZXJjZW50YWdlID49IDAgJiYgcGVyY2VudGFnZSA8PSAxKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1wZXJjZW50YWdlJywgcGVyY2VudGFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJLENBQUMsZUFBZSxJQUFJLFNBQVMsR0FBRztBQUNsQyxpQkFBZTtBQUFBLElBQ2I7QUFBQSxJQUNBLE1BQU0sZUFBZSxZQUFZO0FBQUEsTUFDL0IsY0FBYztBQUNaLGNBQU07QUFFTixjQUFNLFdBQVcsSUFBSSxxQkFBcUIsVUFBUTtBQUNoRCxnQkFBTSxhQUFhLEtBQUssQ0FBQztBQUN6QixjQUFJLFdBQVcsZ0JBQWdCO0FBQzdCLGlCQUFLLFVBQVUsSUFBSSxTQUFTO0FBQUEsVUFDOUI7QUFBQSxRQUNGLEdBQUc7QUFBQSxVQUNELFdBQVc7QUFBQSxRQUNiLENBQUM7QUFFRCxpQkFBUyxRQUFRLElBQUk7QUFBQSxNQUV2QjtBQUFBLElBR0Y7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxJQUFJLENBQUMsZUFBZSxJQUFJLGVBQWUsR0FBRztBQUN4QyxpQkFBZTtBQUFBLElBQ2I7QUFBQSxJQUNBLE1BQU0scUJBQXFCLFlBQVk7QUFBQSxNQUNyQyxjQUFjO0FBQ1osY0FBTTtBQUNOLGFBQUssVUFBVTtBQUNmLGFBQUssaUJBQWlCO0FBRXRCLGFBQUssV0FBVyxJQUFJLHFCQUFxQixVQUFRO0FBQy9DLGdCQUFNLGFBQWEsS0FBSyxDQUFDO0FBQ3pCLGNBQUksV0FBVyxnQkFBZ0I7QUFDN0IsaUJBQUssVUFBVSxJQUFJLFNBQVM7QUFBQSxVQUM5QjtBQUFBLFFBQ0YsR0FBRztBQUFBLFVBQ0QsV0FBVztBQUFBLFFBQ2IsQ0FBQztBQUFBLE1BQ0g7QUFBQSxNQUVBLG9CQUFvQjtBQUNsQixhQUFLLGtCQUFrQixLQUFLLFNBQVMsS0FBSyxJQUFJO0FBQzlDLGVBQU8saUJBQWlCLFVBQVUsS0FBSyxpQkFBaUIsRUFBRSxTQUFTLEtBQUssQ0FBQztBQUl6RSw4QkFBc0IsTUFBTTtBQUMxQixnQ0FBc0IsTUFBTTtBQUMxQixpQkFBSyxlQUFlO0FBQUEsVUFDdEIsQ0FBQztBQUFBLFFBQ0gsQ0FBQztBQUdELFlBQUksU0FBUyxlQUFlLFdBQVc7QUFDckMsaUJBQU8saUJBQWlCLFFBQVEsTUFBTTtBQUNwQyxpQkFBSyxlQUFlO0FBQUEsVUFDdEIsR0FBRyxFQUFFLE1BQU0sS0FBSyxDQUFDO0FBQUEsUUFDbkI7QUFBQSxNQUNGO0FBQUEsTUFFQSx1QkFBdUI7QUFDckIsZUFBTyxvQkFBb0IsVUFBVSxLQUFLLGVBQWU7QUFDekQsWUFBSSxLQUFLLGdCQUFnQjtBQUN2Qix1QkFBYSxLQUFLLGNBQWM7QUFBQSxRQUNsQztBQUFBLE1BQ0Y7QUFBQSxNQUVBLFdBQVc7QUFDVCxZQUFJLENBQUMsS0FBSyxTQUFTO0FBQ2pCLGdDQUFzQixNQUFNO0FBQzFCLGlCQUFLLGVBQWU7QUFDcEIsaUJBQUssVUFBVTtBQUFBLFVBQ2pCLENBQUM7QUFDRCxlQUFLLFVBQVU7QUFBQSxRQUNqQjtBQUdBLHFCQUFhLEtBQUssY0FBYztBQUNoQyxhQUFLLGlCQUFpQixXQUFXLE1BQU07QUFDckMsZUFBSyxlQUFlO0FBQUEsUUFDdEIsR0FBRyxHQUFHO0FBQUEsTUFDUjtBQUFBLE1BRUEsaUJBQWlCLE9BQU87QUFDdEIsWUFBSSxDQUFDO0FBQU8saUJBQU87QUFFbkIsY0FBTSxVQUFVLE1BQU0sS0FBSztBQUMzQixjQUFNLFdBQVcsV0FBVyxPQUFPO0FBRW5DLFlBQUksUUFBUSxTQUFTLEdBQUcsR0FBRztBQUV6QixpQkFBUSxXQUFXLE1BQU8sS0FBSztBQUFBLFFBQ2pDLFdBQVcsUUFBUSxTQUFTLElBQUksR0FBRztBQUVqQyxpQkFBUSxXQUFXLE1BQU8sT0FBTztBQUFBLFFBQ25DLFdBQVcsUUFBUSxTQUFTLElBQUksR0FBRztBQUVqQyxpQkFBUSxXQUFXLE1BQU8sT0FBTztBQUFBLFFBQ25DLE9BQU87QUFFTCxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBQUEsTUFFQSxpQkFBaUI7QUFFZixjQUFNLGlCQUFpQixPQUFPO0FBRzlCLGNBQU0sWUFBWSxPQUFPO0FBR3pCLGNBQU0sbUJBQW1CLEtBQUs7QUFHOUIsY0FBTSxZQUFZLEtBQUssaUJBQWlCLEtBQUssUUFBUSxhQUFhLEtBQUssUUFBUSxNQUFNO0FBQ3JGLGNBQU0sZUFBZSxLQUFLLGlCQUFpQixLQUFLLFFBQVEsZ0JBQWdCLEtBQUssUUFBUSxNQUFNO0FBRzNGLFlBQUksY0FBYyxZQUFZLGlCQUFpQixtQkFBbUIsY0FBYyxpQkFBaUIsS0FBSyxlQUFlLFlBQVk7QUFHakksWUFBSSxhQUFhLE1BQU07QUFDckIsdUJBQWE7QUFBQSxRQUNmLFdBQVcsYUFBYSxNQUFNO0FBQzVCLHVCQUFhO0FBQUEsUUFDZjtBQUVBLFlBQUksY0FBYyxLQUFLLGNBQWMsR0FBRztBQUN0QyxlQUFLLE1BQU0sWUFBWSxnQkFBZ0IsVUFBVTtBQUFBLFFBQ25EO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0Y7IiwibmFtZXMiOltdLCJmaWxlIjoiLi9zcmMvZW50cnlwb2ludHMvaW5WaWV3LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/entrypoints/inView.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/modal.js":
/*!**********************************!*\
  !*** ./src/entrypoints/modal.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeModal: () => (/* binding */ closeModal),\n/* harmony export */   openModal: () => (/* binding */ openModal)\n/* harmony export */ });\n/* harmony import */ var _eventbus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventbus */ \"./src/entrypoints/eventbus.js\");\n\nwindow.EventBus = new _eventbus__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nconst setModalState = (event) => {\n  const activeModal = document.querySelector(\"modal-component#\" + event.detail);\n  if (activeModal) {\n    if (activeModal.classList.contains(\"open\")) {\n      return;\n    } else {\n      activeModal.classList.add(\"open\", \"animating\");\n      activeModal.classList.add(\"animating\");\n    }\n  } else {\n    const modals = document.querySelectorAll(\"modal-component\");\n    modals.forEach((modal) => {\n      modal.classList.remove(\"open\");\n      modal.classList.add(\"animating\");\n      setTimeout(() => {\n        modal.classList.remove(\"animating\");\n      }, 500);\n    });\n  }\n};\nwindow.EventBus.addEventListener(\"setModal\", setModalState);\nconst closeModal = (id) => {\n  let body = document.querySelector(\"body\");\n  window.EventBus.dispatchEvent(\"setModal\", \"false\");\n};\nconst openModal = (id) => {\n  if (id) {\n    window.EventBus.dispatchEvent(\"setModal\", id);\n  }\n};\nclass Modal extends HTMLElement {\n  constructor() {\n    super();\n    this.isOpen = false;\n    this.onKeyDown = this.onKeyDown.bind(this);\n  }\n  connectedCallback() {\n    this.setAttribute(\"role\", \"dialog\");\n    this.setAttribute(\"aria-modal\", \"true\");\n    this.addEventListener(\"click\", (e) => {\n      if (e.target === this) {\n        this.close();\n      }\n    });\n    this.focusableElements = this.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n  }\n  open() {\n    this.isOpen = true;\n    this.classList.add(\"open\", \"animating\");\n    document.body.style.overflow = \"hidden\";\n    document.addEventListener(\"keydown\", this.onKeyDown);\n    const firstFocusable = this.focusableElements[0];\n    if (firstFocusable) {\n      firstFocusable.focus();\n    }\n  }\n  close() {\n    this.isOpen = false;\n    this.classList.remove(\"open\");\n    this.classList.add(\"animating\");\n    document.body.style.overflow = \"\";\n    document.removeEventListener(\"keydown\", this.onKeyDown);\n    setTimeout(() => {\n      this.classList.remove(\"animating\");\n    }, 500);\n  }\n  onKeyDown(e) {\n    if (e.key === \"Escape\") {\n      this.close();\n    }\n    if (e.key === \"Tab\") {\n      const firstFocusable = this.focusableElements[0];\n      const lastFocusable = this.focusableElements[this.focusableElements.length - 1];\n      if (e.shiftKey && document.activeElement === firstFocusable) {\n        e.preventDefault();\n        lastFocusable.focus();\n      } else if (!e.shiftKey && document.activeElement === lastFocusable) {\n        e.preventDefault();\n        firstFocusable.focus();\n      }\n    }\n  }\n}\nif (!customElements.get(\"modal-component\")) {\n  customElements.define(\"modal-component\", Modal);\n}\nclass ModalTrigger extends HTMLElement {\n  constructor() {\n    super();\n    this.addEventListener(\"click\", () => {\n      const modalId = this.dataset.modalId;\n      if (modalId) {\n        openModal(modalId);\n      } else {\n        closeModal();\n      }\n    });\n  }\n}\nif (!customElements.get(\"modal-trigger\")) {\n  customElements.define(\"modal-trigger\", ModalTrigger);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ2pCLHVCQUFlLE1BQU07QUFBQSxNQUN2QjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxJQUFJLENBQUMsZUFBZSxJQUFJLGlCQUFpQixHQUFHO0FBQzFDLGlCQUFlLE9BQU8sbUJBQW1CLEtBQUs7QUFDaEQ7QUFFQSxNQUFNLHFCQUFxQixZQUFZO0FBQUEsRUFDckMsY0FBYztBQUNaLFVBQU07QUFFTixTQUFLLGlCQUFpQixTQUFTLE1BQU07QUFDbkMsWUFBTSxVQUFVLEtBQUssUUFBUTtBQUM3QixVQUFJLFNBQVM7QUFDWCxrQkFBVSxPQUFPO0FBQUEsTUFDbkIsT0FBTztBQUNMLG1CQUFXO0FBQUEsTUFDYjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFDRjtBQUVBLElBQUksQ0FBQyxlQUFlLElBQUksZUFBZSxHQUFHO0FBQ3hDLGlCQUFlLE9BQU8saUJBQWlCLFlBQVk7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waWZ5LXN0YXJ0ZXIvLi9zcmMvZW50cnlwb2ludHMvbW9kYWwuanM/NzVlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRCdXMgZnJvbSAnLi9ldmVudGJ1cyc7XG53aW5kb3cuRXZlbnRCdXMgPSBuZXcgRXZlbnRCdXM7XG5cbmNvbnN0IHNldE1vZGFsU3RhdGUgPSAoZXZlbnQpID0+IHtcbiAgY29uc3QgYWN0aXZlTW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtb2RhbC1jb21wb25lbnQjJyArIGV2ZW50LmRldGFpbClcbiAgaWYgKGFjdGl2ZU1vZGFsKSB7XG4gICAgaWYgKGFjdGl2ZU1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGlmIG1vZGFsIGlzIGFscmVhZHkgb3BlblxuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2ZU1vZGFsLmNsYXNzTGlzdC5hZGQoJ29wZW4nLCAnYW5pbWF0aW5nJylcbiAgICAgIGFjdGl2ZU1vZGFsLmNsYXNzTGlzdC5hZGQoJ2FuaW1hdGluZycpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1vZGFscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ21vZGFsLWNvbXBvbmVudCcpO1xuICAgIG1vZGFscy5mb3JFYWNoKG1vZGFsID0+IHtcbiAgICAgIG1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKVxuICAgICAgbW9kYWwuY2xhc3NMaXN0LmFkZCgnYW5pbWF0aW5nJylcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdhbmltYXRpbmcnKVxuICAgICAgfSwgNTAwKVxuICAgIH0pXG4gIH1cbn1cblxud2luZG93LkV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3NldE1vZGFsJywgc2V0TW9kYWxTdGF0ZSlcblxuZXhwb3J0IGNvbnN0IGNsb3NlTW9kYWwgPSBpZCA9PiB7XG4gIGxldCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJvZHlcIik7XG4gIHdpbmRvdy5FdmVudEJ1cy5kaXNwYXRjaEV2ZW50KFwic2V0TW9kYWxcIiwgXCJmYWxzZVwiKVxufVxuXG5leHBvcnQgY29uc3Qgb3Blbk1vZGFsID0gaWQgPT4ge1xuICBpZiAoaWQpIHtcbiAgICB3aW5kb3cuRXZlbnRCdXMuZGlzcGF0Y2hFdmVudChcInNldE1vZGFsXCIsIGlkKVxuICB9XG59XG5cbmNsYXNzIE1vZGFsIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgdGhpcy5vbktleURvd24gPSB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuXG4gICAgLy8gQ2xvc2Ugb24gb3V0c2lkZSBjbGlja1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRyYXAgZm9jdXMgd2hlbiBtb2RhbCBpcyBvcGVuXG4gICAgdGhpcy5mb2N1c2FibGVFbGVtZW50cyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICdidXR0b24sIFtocmVmXSwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKSdcbiAgICApO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdvcGVuJywgJ2FuaW1hdGluZycpO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24pO1xuXG4gICAgLy8gRm9jdXMgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnRcbiAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlRWxlbWVudHNbMF07XG4gICAgaWYgKGZpcnN0Rm9jdXNhYmxlKSB7XG4gICAgICBmaXJzdEZvY3VzYWJsZS5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdvcGVuJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdhbmltYXRpbmcnKTtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlEb3duKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdhbmltYXRpbmcnKTtcbiAgICB9LCA1MDApO1xuICB9XG5cbiAgb25LZXlEb3duKGUpIHtcbiAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gVHJhcCBmb2N1c1xuICAgIGlmIChlLmtleSA9PT0gJ1RhYicpIHtcbiAgICAgIGNvbnN0IGZpcnN0Rm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICAgIGNvbnN0IGxhc3RGb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZUVsZW1lbnRzW3RoaXMuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChlLnNoaWZ0S2V5ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZpcnN0Rm9jdXNhYmxlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGFzdEZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgfSBlbHNlIGlmICghZS5zaGlmdEtleSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBsYXN0Rm9jdXNhYmxlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZmlyc3RGb2N1c2FibGUuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoJ21vZGFsLWNvbXBvbmVudCcpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbW9kYWwtY29tcG9uZW50JywgTW9kYWwpO1xufVxuXG5jbGFzcyBNb2RhbFRyaWdnZXIgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kYWxJZCA9IHRoaXMuZGF0YXNldC5tb2RhbElkXG4gICAgICBpZiAobW9kYWxJZCkge1xuICAgICAgICBvcGVuTW9kYWwobW9kYWxJZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlTW9kYWwoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoJ21vZGFsLXRyaWdnZXInKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ21vZGFsLXRyaWdnZXInLCBNb2RhbFRyaWdnZXIpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/entrypoints/modal.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/slideshow.js":
/*!**************************************!*\
  !*** ./src/entrypoints/slideshow.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var embla_carousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! embla-carousel */ \"./node_modules/embla-carousel/esm/embla-carousel.esm.js\");\n/* harmony import */ var embla_carousel_class_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! embla-carousel-class-names */ \"./node_modules/embla-carousel-class-names/esm/embla-carousel-class-names.esm.js\");\n/* harmony import */ var embla_carousel_autoplay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! embla-carousel-autoplay */ \"./node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js\");\n/* harmony import */ var embla_carousel_fade__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! embla-carousel-fade */ \"./node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js\");\n\n\n\n\nif (!customElements.get(\"slide-show\")) {\n  customElements.define(\n    \"slide-show\",\n    class Slideshow extends HTMLElement {\n      constructor() {\n        super();\n        this.slidesToShow = this?.dataset?.slidesToShow ? this?.dataset?.slidesToShow.split(\",\") : \"1\";\n        this.loop = this.dataset.loop === \"true\" ? true : false;\n        this.axis = this.dataset.axis || \"x\";\n        this.align = this.dataset.align || \"center\";\n        this.autoplay = this.dataset.autoplay === \"true\" ? true : false;\n        this.autoplaySpeed = this?.dataset?.autoplaySpeed ? parseInt(this.dataset.autoplaySpeed) : 3e3;\n        this.drag = this.dataset.drag === \"false\" ? false : true;\n        this.fade = this.dataset.fade === \"true\" ? true : false;\n        this.dots = this.querySelector(\".slider-dots\");\n        this.dotItems = false;\n        this.arrowNext = this.querySelector(\".slider-next\");\n        this.arrowPrev = this.querySelector(\".slider-prev\");\n        this.slides = this.querySelectorAll(\".slider-slide\") || [];\n        this.navs = this.querySelectorAll(\".slider-nav\");\n        this.currentSlide = 0;\n        this.breakpoints = this?.dataset?.breakpoints ? JSON.parse(this?.dataset?.breakpoints) : {};\n        this.initializeSlideshow();\n      }\n      editorActions(embla) {\n        if (document.body.dataset.shopifyEditor === \"true\" && this.slides?.length > 1) {\n          const blockEditor = (ev) => {\n            const { target } = ev;\n            const selectedIndex = Array.from(this.slides).findIndex(\n              (slide) => slide?.dataset?.shopifyEditorBlock === target?.dataset?.shopifyEditorBlock\n            );\n            embla.scrollTo(selectedIndex);\n          };\n          document.addEventListener(\"shopify:block:select\", blockEditor);\n        }\n      }\n      initializeSlideshow() {\n        const slidesToShow = this.slidesToShow;\n        const loop = this.loop;\n        if (slidesToShow) {\n          this.style.setProperty(\"--slides-xs\", slidesToShow[0]);\n          this.style.setProperty(\"--slides-sm\", slidesToShow[1] || slidesToShow[0]);\n          this.style.setProperty(\n            \"--slides-md\",\n            slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n          this.style.setProperty(\n            \"--slides-lg\",\n            slidesToShow[3] || slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n          this.style.setProperty(\n            \"--slides-xl\",\n            slidesToShow[4] || slidesToShow[3] || slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n          this.style.setProperty(\n            \"--slides-2xl\",\n            slidesToShow[5] || slidesToShow[4] || slidesToShow[3] || slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n          this.style.setProperty(\n            \"--slides-3xl\",\n            slidesToShow[6] || slidesToShow[5] || slidesToShow[4] || slidesToShow[3] || slidesToShow[2] || slidesToShow[1] || slidesToShow[0]\n          );\n        }\n        const options = {\n          loop,\n          axis: this.axis,\n          align: this.align,\n          watchDrag: this.drag,\n          containScroll: \"trimSnaps\",\n          breakpoints: this.breakpoints\n        };\n        let plugins = [(0,embla_carousel_class_names__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()];\n        if (this.autoplay) {\n          plugins = [...plugins, (0,embla_carousel_autoplay__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            delay: this.autoplaySpeed,\n            stopOnLastSnap: !this.loop\n          })];\n        }\n        if (this.fade) {\n          plugins = [...plugins, (0,embla_carousel_fade__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()];\n        }\n        const embla = (0,embla_carousel__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, options, plugins);\n        this.embla = embla;\n        this.resizeHandler = null;\n        const toggleActiveWhenScrollable = () => {\n          setTimeout(() => {\n            const hasSlides = this.slides && this.slides.length > 0;\n            let isScrollable = embla.internalEngine().scrollSnaps.length > 1;\n            if (!isScrollable) {\n              this?.arrowNext?.classList.add(\"!hidden\");\n              this?.arrowPrev?.classList.add(\"!hidden\");\n              this?.dots?.classList.add(\"!hidden\");\n            } else {\n              this?.arrowNext?.classList.remove(\"!hidden\");\n              this?.arrowPrev?.classList.remove(\"!hidden\");\n              this?.dots?.classList.remove(\"!hidden\");\n            }\n            embla.reInit({ active: hasSlides });\n          }, 100);\n        };\n        if (this.arrowNext) {\n          this.arrowNext.addEventListener(\"click\", () => {\n            embla.scrollNext();\n            updateSlide();\n          });\n        }\n        if (this.arrowPrev) {\n          this.arrowPrev.addEventListener(\"click\", () => {\n            embla.scrollPrev();\n            updateSlide();\n          });\n        }\n        const setTheme = () => {\n          if (this.classList.contains(\"change-color\")) {\n            const slideClasses = Array.from(this.classList);\n            const slideColor = this?.slides[this.currentSlide]?.dataset?.colorScheme || \"\";\n            const classToRemove = slideClasses.find((cls) => cls.includes(\"theme-\"));\n            if (!this.classList.contains(slideColor)) {\n              this.classList.remove(classToRemove);\n              this.classList.add(slideColor);\n            }\n          }\n        };\n        const updateSlide = () => {\n          if (this.arrowPrev) {\n            this.arrowPrev.disabled = !embla.canScrollPrev();\n          }\n          if (this.arrowNext) {\n            this.arrowNext.disabled = !embla.canScrollNext();\n          }\n          this.currentSlide = embla.slideNodes().findIndex((node) => node?.classList.contains(\"is-snapped\"));\n          this.querySelectorAll(\"#currentSlide\").forEach((item) => {\n            item.innerHTML = this.currentSlide + 1;\n          });\n          if (this.dotItems) {\n            this.dotItems?.forEach((item, index) => {\n              if (index === this.currentSlide) {\n                item.classList.add(\"active\");\n              } else {\n                item.classList.remove(\"active\");\n              }\n            });\n          }\n          if (this.navs?.length > 0) {\n            Array.from(this.navs).forEach((nav) => {\n              const buttons = nav.querySelectorAll(\"button\");\n              if (buttons?.length > 0) {\n                buttons.forEach((button, index) => {\n                  if (index === this.currentSlide) {\n                    button.classList.add(\"active\");\n                  } else {\n                    button.classList.remove(\"active\");\n                  }\n                });\n              }\n            });\n          }\n          setTheme();\n        };\n        const setInactive = () => {\n          if (embla?.internalEngine()?.options?.active) {\n            this.classList.remove(\"inactive\");\n          } else {\n            this.classList.add(\"inactive\");\n          }\n        };\n        const renderDots = () => {\n          if (this.dots) {\n            let dotItems = \"\";\n            embla.slideNodes()?.forEach((slide, index) => {\n              dotItems += '<button class=\"slider-dot\" title=\"Go to slide ' + (index + 1) + '\"><span>' + (index + 1) + \"</span></button>\";\n            });\n            this.dots.innerHTML = dotItems;\n            this.dotItems = this?.dots?.querySelectorAll(\".slider-dot\");\n            if (this.dotItems) {\n              this.dotItems?.forEach((item, index) => {\n                if (index === 0) {\n                  item.classList.add(\"active\");\n                }\n                item?.addEventListener(\"click\", () => {\n                  embla.scrollTo(index);\n                });\n              });\n            }\n          }\n        };\n        const renderNav = () => {\n          if (this.navs?.length > 0) {\n            Array.from(this.navs).forEach((nav) => {\n              const buttons = nav.querySelectorAll(\"button\");\n              if (buttons?.length > 0) {\n                buttons.forEach((button, index) => {\n                  button.addEventListener(\"click\", () => {\n                    embla.scrollTo(index);\n                    this.currentSlide = index;\n                  });\n                });\n              }\n            });\n          }\n        };\n        this.resizeHandler = () => {\n          toggleActiveWhenScrollable();\n          setInactive();\n        };\n        embla.on(\"scroll\", updateSlide);\n        window.addEventListener(\"resize\", this.resizeHandler);\n        toggleActiveWhenScrollable();\n        updateSlide();\n        renderDots();\n        setInactive();\n        renderNav();\n        this.editorActions(embla);\n      }\n      destroySlideshow() {\n        if (this.embla) {\n          this.embla.destroy();\n          this.embla = null;\n        }\n        if (this.resizeHandler) {\n          window.removeEventListener(\"resize\", this.resizeHandler);\n          this.resizeHandler = null;\n        }\n      }\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGVBQUssUUFBUTtBQUFBLFFBQ2Y7QUFFQSxZQUFJLEtBQUssZUFBZTtBQUN0QixpQkFBTyxvQkFBb0IsVUFBVSxLQUFLLGFBQWE7QUFDdkQsZUFBSyxnQkFBZ0I7QUFBQSxRQUN2QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hvcGlmeS1zdGFydGVyLy4vc3JjL2VudHJ5cG9pbnRzL3NsaWRlc2hvdy5qcz9hMDlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFbWJsYUNhcm91c2VsIGZyb20gJ2VtYmxhLWNhcm91c2VsJ1xuaW1wb3J0IENsYXNzTmFtZXMgZnJvbSAnZW1ibGEtY2Fyb3VzZWwtY2xhc3MtbmFtZXMnXG5pbXBvcnQgQXV0b3BsYXkgZnJvbSAnZW1ibGEtY2Fyb3VzZWwtYXV0b3BsYXknXG5pbXBvcnQgRmFkZSBmcm9tICdlbWJsYS1jYXJvdXNlbC1mYWRlJ1xuXG5pZiAoIWN1c3RvbUVsZW1lbnRzLmdldCgnc2xpZGUtc2hvdycpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICAnc2xpZGUtc2hvdycsXG4gICAgY2xhc3MgU2xpZGVzaG93IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcblxuICAgICAgICB0aGlzLnNsaWRlc1RvU2hvdyA9IHRoaXM/LmRhdGFzZXQ/LnNsaWRlc1RvU2hvd1xuICAgICAgICAgID8gdGhpcz8uZGF0YXNldD8uc2xpZGVzVG9TaG93LnNwbGl0KCcsJylcbiAgICAgICAgICA6ICcxJ1xuICAgICAgICB0aGlzLmxvb3AgPSB0aGlzLmRhdGFzZXQubG9vcCA9PT0gJ3RydWUnID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIHRoaXMuYXhpcyA9IHRoaXMuZGF0YXNldC5heGlzIHx8ICd4J1xuICAgICAgICB0aGlzLmFsaWduID0gdGhpcy5kYXRhc2V0LmFsaWduIHx8ICdjZW50ZXInXG4gICAgICAgIHRoaXMuYXV0b3BsYXkgPSB0aGlzLmRhdGFzZXQuYXV0b3BsYXkgPT09ICd0cnVlJyA/IHRydWUgOiBmYWxzZVxuICAgICAgICB0aGlzLmF1dG9wbGF5U3BlZWQgPSB0aGlzPy5kYXRhc2V0Py5hdXRvcGxheVNwZWVkXG4gICAgICAgICAgPyBwYXJzZUludCh0aGlzLmRhdGFzZXQuYXV0b3BsYXlTcGVlZClcbiAgICAgICAgICA6IDMwMDBcbiAgICAgICAgdGhpcy5kcmFnID0gdGhpcy5kYXRhc2V0LmRyYWcgPT09ICdmYWxzZScgPyBmYWxzZSA6IHRydWVcbiAgICAgICAgdGhpcy5mYWRlID0gdGhpcy5kYXRhc2V0LmZhZGUgPT09ICd0cnVlJyA/IHRydWUgOiBmYWxzZVxuICAgICAgICB0aGlzLmRvdHMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXItZG90cycpXG4gICAgICAgIHRoaXMuZG90SXRlbXMgPSBmYWxzZVxuICAgICAgICB0aGlzLmFycm93TmV4dCA9IHRoaXMucXVlcnlTZWxlY3RvcignLnNsaWRlci1uZXh0JylcbiAgICAgICAgdGhpcy5hcnJvd1ByZXYgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXItcHJldicpXG4gICAgICAgIHRoaXMuc2xpZGVzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCcuc2xpZGVyLXNsaWRlJykgfHwgW11cbiAgICAgICAgdGhpcy5uYXZzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCcuc2xpZGVyLW5hdicpXG4gICAgICAgIHRoaXMuY3VycmVudFNsaWRlID0gMFxuICAgICAgICB0aGlzLmJyZWFrcG9pbnRzID0gdGhpcz8uZGF0YXNldD8uYnJlYWtwb2ludHMgPyBKU09OLnBhcnNlKHRoaXM/LmRhdGFzZXQ/LmJyZWFrcG9pbnRzKSA6IHt9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVNsaWRlc2hvdygpXG4gICAgICB9XG5cbiAgICAgIGVkaXRvckFjdGlvbnMoZW1ibGEpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkuZGF0YXNldC5zaG9waWZ5RWRpdG9yID09PSAndHJ1ZScgJiYgdGhpcy5zbGlkZXM/Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCBibG9ja0VkaXRvciA9IChldikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IGV2XG4gICAgICAgICAgICAvLyBGaW5kIGluZGV4IG9uIHNlbGVjdGVkIHNsaWRlXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gQXJyYXkuZnJvbSh0aGlzLnNsaWRlcykuZmluZEluZGV4KFxuICAgICAgICAgICAgICAoc2xpZGUpID0+IHNsaWRlPy5kYXRhc2V0Py5zaG9waWZ5RWRpdG9yQmxvY2sgPT09IHRhcmdldD8uZGF0YXNldD8uc2hvcGlmeUVkaXRvckJsb2NrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAvLyBHbyB0byBzZWxlY3RlZCBzbGlkZSBvbiBzZWxlY3QgaW4gZWRpdG9yXG5cbiAgICAgICAgICAgIGVtYmxhLnNjcm9sbFRvKHNlbGVjdGVkSW5kZXgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2hvcGlmeTpibG9jazpzZWxlY3QnLCBibG9ja0VkaXRvcilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbml0aWFsaXplU2xpZGVzaG93KCkge1xuICAgICAgICBjb25zdCBzbGlkZXNUb1Nob3cgPSB0aGlzLnNsaWRlc1RvU2hvd1xuICAgICAgICBjb25zdCBsb29wID0gdGhpcy5sb29wXG5cbiAgICAgICAgaWYgKHNsaWRlc1RvU2hvdykge1xuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoJy0tc2xpZGVzLXhzJywgc2xpZGVzVG9TaG93WzBdKVxuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoJy0tc2xpZGVzLXNtJywgc2xpZGVzVG9TaG93WzFdIHx8IHNsaWRlc1RvU2hvd1swXSlcbiAgICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgJy0tc2xpZGVzLW1kJyxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1syXSB8fCBzbGlkZXNUb1Nob3dbMV0gfHwgc2xpZGVzVG9TaG93WzBdXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAnLS1zbGlkZXMtbGcnLFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzNdIHx8IHNsaWRlc1RvU2hvd1syXSB8fCBzbGlkZXNUb1Nob3dbMV0gfHwgc2xpZGVzVG9TaG93WzBdXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAnLS1zbGlkZXMteGwnLFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzRdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbM10gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1syXSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzFdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbMF1cbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICctLXNsaWRlcy0yeGwnLFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzVdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbNF0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1szXSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzJdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbMV0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1swXVxuICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgJy0tc2xpZGVzLTN4bCcsXG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbNl0gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1s1XSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzRdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbM10gfHxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvd1syXSB8fFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93WzFdIHx8XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3dbMF1cbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGxvb3A6IGxvb3AsXG4gICAgICAgICAgYXhpczogdGhpcy5heGlzLFxuICAgICAgICAgIGFsaWduOiB0aGlzLmFsaWduLFxuICAgICAgICAgIHdhdGNoRHJhZzogdGhpcy5kcmFnLFxuICAgICAgICAgIGNvbnRhaW5TY3JvbGw6ICd0cmltU25hcHMnLFxuICAgICAgICAgIGJyZWFrcG9pbnRzOiB0aGlzLmJyZWFrcG9pbnRzXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXplIHNsaWRlclxuICAgICAgICBsZXQgcGx1Z2lucyA9IFtDbGFzc05hbWVzKCldXG4gICAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XG4gICAgICAgICAgcGx1Z2lucyA9IFsuLi5wbHVnaW5zLCBBdXRvcGxheSh7XG4gICAgICAgICAgICBkZWxheTogdGhpcy5hdXRvcGxheVNwZWVkLFxuICAgICAgICAgICAgc3RvcE9uTGFzdFNuYXA6ICF0aGlzLmxvb3BcbiAgICAgICAgICB9KV1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mYWRlKSB7XG4gICAgICAgICAgcGx1Z2lucyA9IFsuLi5wbHVnaW5zLCBGYWRlKCldXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbWJsYSA9IEVtYmxhQ2Fyb3VzZWwodGhpcywgb3B0aW9ucywgcGx1Z2lucylcblxuICAgICAgICAvLyBTdG9yZSBlbWJsYSBpbnN0YW5jZSBhbmQgcmVzaXplIGhhbmRsZXIgZm9yIGNsZWFudXBcbiAgICAgICAgdGhpcy5lbWJsYSA9IGVtYmxhXG4gICAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9IG51bGxcblxuICAgICAgICBjb25zdCB0b2dnbGVBY3RpdmVXaGVuU2Nyb2xsYWJsZSA9ICgpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NsaWRlcyA9IHRoaXMuc2xpZGVzICYmIHRoaXMuc2xpZGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgIGxldCBpc1Njcm9sbGFibGUgPSBlbWJsYS5pbnRlcm5hbEVuZ2luZSgpLnNjcm9sbFNuYXBzLmxlbmd0aCA+IDFcblxuICAgICAgICAgICAgLy8gSGlkZSBjb250cm9scyBpZiBub3Qgc2Nyb2xsYWJsZSwgYnV0IGRvbid0IG1hcmsgYXMgaW5hY3RpdmUgaWYgd2UgaGF2ZSBzbGlkZXNcbiAgICAgICAgICAgIGlmICghaXNTY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICAgIHRoaXM/LmFycm93TmV4dD8uY2xhc3NMaXN0LmFkZCgnIWhpZGRlbicpXG4gICAgICAgICAgICAgIHRoaXM/LmFycm93UHJldj8uY2xhc3NMaXN0LmFkZCgnIWhpZGRlbicpXG4gICAgICAgICAgICAgIHRoaXM/LmRvdHM/LmNsYXNzTGlzdC5hZGQoJyFoaWRkZW4nKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcz8uYXJyb3dOZXh0Py5jbGFzc0xpc3QucmVtb3ZlKCchaGlkZGVuJylcbiAgICAgICAgICAgICAgdGhpcz8uYXJyb3dQcmV2Py5jbGFzc0xpc3QucmVtb3ZlKCchaGlkZGVuJylcbiAgICAgICAgICAgICAgdGhpcz8uZG90cz8uY2xhc3NMaXN0LnJlbW92ZSgnIWhpZGRlbicpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgcmVJbml0IHdpdGggYWN0aXZlOiBmYWxzZSBpZiB3ZSBoYXZlIG5vIHNsaWRlcyBhdCBhbGxcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgc2xpZGVzIHRoYXQgZXhhY3RseSBtYXRjaCBzbGlkZXMtdG8tc2hvdywga2VlcCBhY3RpdmU6IHRydWVcbiAgICAgICAgICAgIGVtYmxhLnJlSW5pdCh7IGFjdGl2ZTogaGFzU2xpZGVzIH0pXG4gICAgICAgICAgfSwgMTAwKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2xpZGVyIENvbnRyb2xzXG4gICAgICAgIGlmICh0aGlzLmFycm93TmV4dCkge1xuICAgICAgICAgIHRoaXMuYXJyb3dOZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgZW1ibGEuc2Nyb2xsTmV4dCgpXG4gICAgICAgICAgICB1cGRhdGVTbGlkZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFycm93UHJldikge1xuICAgICAgICAgIHRoaXMuYXJyb3dQcmV2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgZW1ibGEuc2Nyb2xsUHJldigpXG4gICAgICAgICAgICB1cGRhdGVTbGlkZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldFRoZW1lID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmNsYXNzTGlzdC5jb250YWlucygnY2hhbmdlLWNvbG9yJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlQ2xhc3NlcyA9IEFycmF5LmZyb20odGhpcy5jbGFzc0xpc3QpXG4gICAgICAgICAgICBjb25zdCBzbGlkZUNvbG9yID0gdGhpcz8uc2xpZGVzW3RoaXMuY3VycmVudFNsaWRlXT8uZGF0YXNldD8uY29sb3JTY2hlbWUgfHwgJydcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzVG9SZW1vdmUgPSBzbGlkZUNsYXNzZXMuZmluZChjbHMgPT4gY2xzLmluY2x1ZGVzKCd0aGVtZS0nKSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoc2xpZGVDb2xvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzVG9SZW1vdmUpXG4gICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChzbGlkZUNvbG9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwZGF0ZVNsaWRlID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmFycm93UHJldikge1xuICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXYuZGlzYWJsZWQgPSAhZW1ibGEuY2FuU2Nyb2xsUHJldigpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmFycm93TmV4dCkge1xuICAgICAgICAgICAgdGhpcy5hcnJvd05leHQuZGlzYWJsZWQgPSAhZW1ibGEuY2FuU2Nyb2xsTmV4dCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VycmVudFNsaWRlID0gZW1ibGFcbiAgICAgICAgICAgIC5zbGlkZU5vZGVzKClcbiAgICAgICAgICAgIC5maW5kSW5kZXgoKG5vZGUpID0+IG5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnaXMtc25hcHBlZCcpKVxuICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3RvckFsbCgnI2N1cnJlbnRTbGlkZScpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uaW5uZXJIVE1MID0gdGhpcy5jdXJyZW50U2xpZGUgKyAxXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmICh0aGlzLmRvdEl0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLmRvdEl0ZW1zPy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuY3VycmVudFNsaWRlKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5uYXZzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMubmF2cykuZm9yRWFjaCgobmF2KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbnMgPSBuYXYucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJylcbiAgICAgICAgICAgICAgaWYgKGJ1dHRvbnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBidXR0b25zLmZvckVhY2goKGJ1dHRvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5jdXJyZW50U2xpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFRoZW1lKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldEluYWN0aXZlID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChlbWJsYT8uaW50ZXJuYWxFbmdpbmUoKT8ub3B0aW9ucz8uYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2luYWN0aXZlJylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdpbmFjdGl2ZScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVuZGVyRG90cyA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kb3RzKSB7XG4gICAgICAgICAgICBsZXQgZG90SXRlbXMgPSAnJ1xuXG4gICAgICAgICAgICBlbWJsYS5zbGlkZU5vZGVzKCk/LmZvckVhY2goKHNsaWRlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBkb3RJdGVtcyArPVxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGNsYXNzPVwic2xpZGVyLWRvdFwiIHRpdGxlPVwiR28gdG8gc2xpZGUgJyArXG4gICAgICAgICAgICAgICAgKGluZGV4ICsgMSkgK1xuICAgICAgICAgICAgICAgICdcIj48c3Bhbj4nICtcbiAgICAgICAgICAgICAgICAoaW5kZXggKyAxKSArXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj48L2J1dHRvbj4nXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLmRvdHMuaW5uZXJIVE1MID0gZG90SXRlbXNcbiAgICAgICAgICAgIHRoaXMuZG90SXRlbXMgPSB0aGlzPy5kb3RzPy5xdWVyeVNlbGVjdG9yQWxsKCcuc2xpZGVyLWRvdCcpXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRvdEl0ZW1zKSB7XG4gICAgICAgICAgICAgIHRoaXMuZG90SXRlbXM/LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgZW1ibGEuc2Nyb2xsVG8oaW5kZXgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZW5kZXJOYXYgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMubmF2cz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLm5hdnMpLmZvckVhY2goKG5hdikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBidXR0b25zID0gbmF2LnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpXG4gICAgICAgICAgICAgIGlmIChidXR0b25zPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9ucy5mb3JFYWNoKChidXR0b24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVtYmxhLnNjcm9sbFRvKGluZGV4KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IGluZGV4XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgcmVzaXplIGhhbmRsZXIgc28gd2UgY2FuIHJlbW92ZSBpdCBsYXRlclxuICAgICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlQWN0aXZlV2hlblNjcm9sbGFibGUoKVxuICAgICAgICAgIHNldEluYWN0aXZlKClcbiAgICAgICAgfVxuXG4gICAgICAgIGVtYmxhLm9uKCdzY3JvbGwnLCB1cGRhdGVTbGlkZSlcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplSGFuZGxlcilcbiAgICAgICAgdG9nZ2xlQWN0aXZlV2hlblNjcm9sbGFibGUoKVxuICAgICAgICB1cGRhdGVTbGlkZSgpXG4gICAgICAgIHJlbmRlckRvdHMoKVxuICAgICAgICBzZXRJbmFjdGl2ZSgpXG4gICAgICAgIHJlbmRlck5hdigpXG4gICAgICAgIHRoaXMuZWRpdG9yQWN0aW9ucyhlbWJsYSlcbiAgICAgIH1cblxuICAgICAgZGVzdHJveVNsaWRlc2hvdygpIHtcbiAgICAgICAgLy8gRGVzdHJveSBFbWJsYSBpbnN0YW5jZVxuICAgICAgICBpZiAodGhpcy5lbWJsYSkge1xuICAgICAgICAgIHRoaXMuZW1ibGEuZGVzdHJveSgpXG4gICAgICAgICAgdGhpcy5lbWJsYSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgcmVzaXplIGxpc3RlbmVyXG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZUhhbmRsZXIpIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVIYW5kbGVyKVxuICAgICAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/entrypoints/slideshow.js\n\n}");

/***/ }),

/***/ "./src/entrypoints/sort-filter.js":
/*!****************************************!*\
  !*** ./src/entrypoints/sort-filter.js ***!
  \****************************************/
/***/ (function() {

eval("{var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst debounce = (func, timeout = 300) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      func.apply(this, args);\n    }, timeout);\n  };\n};\nconst qs = (parameters, prependValue = false) => {\n  let queryString = \"\";\n  parameters.forEach((param, index) => {\n    let prepend = \"?\";\n    if (index > 0) {\n      prepend = \"&\";\n    }\n    if (prependValue) {\n      prepend = prependValue;\n    }\n    const paramString = Object.keys(param) + \"=\" + Object.values(param);\n    queryString += prepend + paramString;\n  });\n  return queryString;\n};\nif (!customElements.get(\"collection-grid\")) {\n  customElements.define(\n    \"collection-grid\",\n    class CollectionGrid extends HTMLElement {\n      constructor() {\n        super();\n        __publicField(this, \"toggleFilterPanel\", () => {\n          const banner = document.querySelector(\"#shopify-section-notification-banner\");\n          const closePanel = () => {\n            document.body.classList.remove(\"overflow-hidden\", \"sm:overflow-auto\");\n            banner.classList.remove(\"mobile-close\");\n            this.filterPanelOverlay.classList.add(\"invisible\", \"!opacity-0\", \"pointer-events-none\");\n            this.filterPanel.classList.remove(\"active\");\n            this.filterPanel.classList.add(\"sm:-translate-x-full\");\n            this.filterPanel.classList.add(\"translate-y-full\");\n          };\n          const openPanel = () => {\n            document.body.classList.add(\"overflow-hidden\", \"sm:overflow-auto\");\n            banner.classList.add(\"mobile-close\");\n            this.filterPanelOverlay.classList.remove(\"invisible\", \"!opacity-0\", \"pointer-events-none\");\n            this.filterPanel.classList.add(\"active\");\n            this.filterPanel.classList.remove(\"sm:-translate-x-full\");\n            this.filterPanel.classList.remove(\"translate-y-full\");\n          };\n          this.filterPanelToggle?.addEventListener(\"click\", () => {\n            if (this.filterPanel.classList.contains(\"active\")) {\n              closePanel();\n            } else {\n              openPanel();\n            }\n          });\n          this.filterPanelOverlay?.addEventListener(\"click\", closePanel);\n          this.filterPanelClose?.addEventListener(\"click\", closePanel);\n        });\n        __publicField(this, \"sortDropdown\", () => {\n          const trigger = this?.sortItems?.querySelector(\"#sortTrigger\");\n          const triggerIcon = trigger?.querySelector(\".icon\");\n          const list = this?.sortItems?.querySelector(\"#sortList\");\n          trigger?.addEventListener(\"click\", () => {\n            if (list.classList.contains(\"hidden\")) {\n              list.classList.remove(\"hidden\");\n              triggerIcon.classList.add(\"rotate-180\");\n            } else {\n              list.classList.add(\"hidden\");\n              triggerIcon.classList.remove(\"rotate-180\");\n            }\n          });\n        });\n        __publicField(this, \"sortAndFilter\", (reset = false, fetchUrl = false) => {\n          let sfValues = false;\n          const allCheckboxes = Array.from(this.sortAndFilterItems).filter(\n            (item) => item.value === \"all\" && item.checked\n          );\n          const excludeNames = allCheckboxes.map((item) => item.name);\n          sfValues = Array.from(this.sortAndFilterItems).map((item) => {\n            if (item.value && item.name) {\n              if (excludeNames.includes(item.name)) {\n                return null;\n              }\n              if ((item.type === \"checkbox\" || item.type === \"radio\") && item.checked) {\n                if (item.type === \"radio\" && sfValues[item.name]) {\n                  sfValues[item.name] = item.value;\n                } else {\n                  return { [item.name]: item.value };\n                }\n              } else if (item.type === \"number\" || item.type === \"text\") {\n                return { [item.name]: item.value };\n              }\n            }\n          }).filter((item) => item !== void 0 && item !== null);\n          let pageUrl = this.collectionUrl;\n          let sectionId = this.sectionId;\n          let sectionUrl = pageUrl + \"?sections=\" + sectionId + qs(sfValues, \"&\");\n          let newPageUrl = pageUrl + qs(sfValues);\n          if (reset) {\n            sectionUrl = pageUrl + \"?sections=\" + sectionId;\n            newPageUrl = pageUrl;\n          }\n          if (fetchUrl) {\n            const newFq = fetchUrl.split(\"?\")[1];\n            if (newFq) {\n              sectionUrl = pageUrl + \"?sections=\" + sectionId + \"&\" + newFq;\n              newPageUrl = pageUrl + \"?\" + newFq;\n            } else {\n              sectionUrl = pageUrl + \"?sections=\" + sectionId;\n              newPageUrl = pageUrl;\n            }\n          }\n          this.section.classList.add(\"opacity-50\");\n          fetch(sectionUrl).then((res) => res.json()).then((res) => {\n            console.log(res);\n            this.section.parentElement.outerHTML = res[this.sectionId];\n            this.section.classList.remove(\"opacity-50\");\n            window.history.replaceState({}, \"\", newPageUrl);\n          }).then(() => {\n            document.body.classList.remove(\"overflow-hidden\", \"sm:overflow-auto\");\n          }).catch((error) => {\n            console.error(\"Error:\", error);\n          });\n          return;\n        });\n        this.section = this;\n        this.collectionUrl = this.section.dataset.url;\n        this.sectionId = this.section.dataset.sectionId;\n        this.filters = this.querySelector(\"#collectionFilters\");\n        this.pageContent = document.querySelector(\"#pageContent\");\n        this.filterForm = this.filters.querySelector(\"form\");\n        this.clearAllFilters = this.querySelector(\"#clearAllFilters\");\n        this.removeFilterItems = this.querySelectorAll(\"a.remove-filter\");\n        this.sortItems = this.querySelector(\"#sortItems\");\n        this.sortAndFilterItems = this.querySelectorAll(\n          \"#sortItems input, #collectionFilters input\"\n        );\n        this.filterPanelToggle = this.querySelector(\"#filterPanelToggle\");\n        this.filterPanel = this.querySelector(\"#filterPanel\");\n        this.filterPanelOverlay = this.querySelector(\"#filterPanelOverlay\");\n        this.filterPanelClose = this.querySelector(\"#filterPanelClose\");\n        this.sortAndFilterItems.forEach((sfItem) => {\n          sfItem?.addEventListener(\"change\", (event) => {\n            if (event.target.type === \"checkbox\" && event.target.checked && event.target.value !== \"all\") {\n              const allCheckbox = this.querySelector(`input[name=\"${event.target.name}\"][value=\"all\"]`);\n              if (allCheckbox) {\n                allCheckbox.checked = false;\n              }\n            }\n            this.sortAndFilter();\n          });\n        });\n        if (this?.removeFilterItems && this?.removeFilterItems?.length > 0) {\n          this.removeFilterItems.forEach((rItem) => {\n            rItem?.addEventListener(\"click\", (event) => {\n              event.preventDefault();\n              this.sortAndFilter(false, event.target.href);\n            });\n          });\n        }\n        this.clearAllFilters?.addEventListener(\"click\", () => {\n          this.sortAndFilter(true);\n        });\n        this.sortDropdown();\n        this.toggleFilterPanel();\n      }\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waWZ5LXN0YXJ0ZXIvLi9zcmMvZW50cnlwb2ludHMvc29ydC1maWx0ZXIuanM/MzkwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWJvdW5jZSA9IChmdW5jLCB0aW1lb3V0ID0gMzAwKSA9PiB7XG4gIGxldCB0aW1lclxuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncylcbiAgICB9LCB0aW1lb3V0KVxuICB9XG59XG5cbmNvbnN0IHFzID0gKHBhcmFtZXRlcnMsIHByZXBlbmRWYWx1ZSA9IGZhbHNlKSA9PiB7XG4gIGxldCBxdWVyeVN0cmluZyA9ICcnXG5cbiAgcGFyYW1ldGVycy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICBsZXQgcHJlcGVuZCA9ICc/J1xuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIHByZXBlbmQgPSAnJidcbiAgICB9XG5cbiAgICBpZiAocHJlcGVuZFZhbHVlKSB7XG4gICAgICBwcmVwZW5kID0gcHJlcGVuZFZhbHVlXG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1TdHJpbmcgPSBPYmplY3Qua2V5cyhwYXJhbSkgKyAnPScgKyBPYmplY3QudmFsdWVzKHBhcmFtKVxuXG4gICAgcXVlcnlTdHJpbmcgKz0gcHJlcGVuZCArIHBhcmFtU3RyaW5nXG4gIH0pXG5cbiAgcmV0dXJuIHF1ZXJ5U3RyaW5nXG59XG5cbmlmICghY3VzdG9tRWxlbWVudHMuZ2V0KCdjb2xsZWN0aW9uLWdyaWQnKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXG4gICAgJ2NvbGxlY3Rpb24tZ3JpZCcsXG4gICAgY2xhc3MgQ29sbGVjdGlvbkdyaWQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgIHRoaXMuc2VjdGlvbiA9IHRoaXNcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uVXJsID0gdGhpcy5zZWN0aW9uLmRhdGFzZXQudXJsXG4gICAgICAgIHRoaXMuc2VjdGlvbklkID0gdGhpcy5zZWN0aW9uLmRhdGFzZXQuc2VjdGlvbklkXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHRoaXMucXVlcnlTZWxlY3RvcignI2NvbGxlY3Rpb25GaWx0ZXJzJylcbiAgICAgICAgdGhpcy5wYWdlQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwYWdlQ29udGVudCcpXG4gICAgICAgIHRoaXMuZmlsdGVyRm9ybSA9IHRoaXMuZmlsdGVycy5xdWVyeVNlbGVjdG9yKCdmb3JtJylcbiAgICAgICAgdGhpcy5jbGVhckFsbEZpbHRlcnMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNjbGVhckFsbEZpbHRlcnMnKVxuICAgICAgICB0aGlzLnJlbW92ZUZpbHRlckl0ZW1zID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdhLnJlbW92ZS1maWx0ZXInKVxuICAgICAgICB0aGlzLnNvcnRJdGVtcyA9IHRoaXMucXVlcnlTZWxlY3RvcignI3NvcnRJdGVtcycpXG4gICAgICAgIHRoaXMuc29ydEFuZEZpbHRlckl0ZW1zID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICcjc29ydEl0ZW1zIGlucHV0LCAjY29sbGVjdGlvbkZpbHRlcnMgaW5wdXQnXG4gICAgICAgIClcblxuICAgICAgICAvLyBIaWRlIGZpbHRlcnMgYXQgc21hbGxlciBzY3JlZW4gc2l6ZXNcbiAgICAgICAgdGhpcy5maWx0ZXJQYW5lbFRvZ2dsZSA9IHRoaXMucXVlcnlTZWxlY3RvcignI2ZpbHRlclBhbmVsVG9nZ2xlJylcbiAgICAgICAgdGhpcy5maWx0ZXJQYW5lbCA9IHRoaXMucXVlcnlTZWxlY3RvcignI2ZpbHRlclBhbmVsJylcbiAgICAgICAgdGhpcy5maWx0ZXJQYW5lbE92ZXJsYXkgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNmaWx0ZXJQYW5lbE92ZXJsYXknKVxuICAgICAgICB0aGlzLmZpbHRlclBhbmVsQ2xvc2UgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNmaWx0ZXJQYW5lbENsb3NlJylcblxuICAgICAgICB0aGlzLnNvcnRBbmRGaWx0ZXJJdGVtcy5mb3JFYWNoKChzZkl0ZW0pID0+IHtcbiAgICAgICAgICBzZkl0ZW0/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgYSByZWd1bGFyIGZpbHRlciBpcyBjaGVja2VkLCB1bmNoZWNrIHRoZSBcIkFsbFwiIGNoZWNrYm94IGZvciB0aGF0IGZpbHRlciB0eXBlXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcgJiYgZXZlbnQudGFyZ2V0LmNoZWNrZWQgJiYgZXZlbnQudGFyZ2V0LnZhbHVlICE9PSAnYWxsJykge1xuICAgICAgICAgICAgICBjb25zdCBhbGxDaGVja2JveCA9IHRoaXMucXVlcnlTZWxlY3RvcihgaW5wdXRbbmFtZT1cIiR7ZXZlbnQudGFyZ2V0Lm5hbWV9XCJdW3ZhbHVlPVwiYWxsXCJdYClcbiAgICAgICAgICAgICAgaWYgKGFsbENoZWNrYm94KSB7XG4gICAgICAgICAgICAgICAgYWxsQ2hlY2tib3guY2hlY2tlZCA9IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ydEFuZEZpbHRlcigpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAodGhpcz8ucmVtb3ZlRmlsdGVySXRlbXMgJiYgdGhpcz8ucmVtb3ZlRmlsdGVySXRlbXM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUZpbHRlckl0ZW1zLmZvckVhY2goKHJJdGVtKSA9PiB7XG4gICAgICAgICAgICBySXRlbT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgdGhpcy5zb3J0QW5kRmlsdGVyKGZhbHNlLCBldmVudC50YXJnZXQuaHJlZilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXJBbGxGaWx0ZXJzPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnNvcnRBbmRGaWx0ZXIodHJ1ZSlcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnNvcnREcm9wZG93bigpXG4gICAgICAgIHRoaXMudG9nZ2xlRmlsdGVyUGFuZWwoKVxuICAgICAgfVxuXG4gICAgICB0b2dnbGVGaWx0ZXJQYW5lbCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYmFubmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Nob3BpZnktc2VjdGlvbi1ub3RpZmljYXRpb24tYmFubmVyJylcbiAgICAgICAgY29uc3QgY2xvc2VQYW5lbCA9ICgpID0+IHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ292ZXJmbG93LWhpZGRlbicsICdzbTpvdmVyZmxvdy1hdXRvJylcbiAgICAgICAgICBiYW5uZXIuY2xhc3NMaXN0LnJlbW92ZSgnbW9iaWxlLWNsb3NlJylcbiAgICAgICAgICB0aGlzLmZpbHRlclBhbmVsT3ZlcmxheS5jbGFzc0xpc3QuYWRkKCdpbnZpc2libGUnLCAnIW9wYWNpdHktMCcsICdwb2ludGVyLWV2ZW50cy1ub25lJylcbiAgICAgICAgICB0aGlzLmZpbHRlclBhbmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpXG4gICAgICAgICAgdGhpcy5maWx0ZXJQYW5lbC5jbGFzc0xpc3QuYWRkKCdzbTotdHJhbnNsYXRlLXgtZnVsbCcpXG4gICAgICAgICAgdGhpcy5maWx0ZXJQYW5lbC5jbGFzc0xpc3QuYWRkKCd0cmFuc2xhdGUteS1mdWxsJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wZW5QYW5lbCA9ICgpID0+IHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ292ZXJmbG93LWhpZGRlbicsICdzbTpvdmVyZmxvdy1hdXRvJylcbiAgICAgICAgICBiYW5uZXIuY2xhc3NMaXN0LmFkZCgnbW9iaWxlLWNsb3NlJylcbiAgICAgICAgICB0aGlzLmZpbHRlclBhbmVsT3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdpbnZpc2libGUnLCAnIW9wYWNpdHktMCcsICdwb2ludGVyLWV2ZW50cy1ub25lJylcbiAgICAgICAgICB0aGlzLmZpbHRlclBhbmVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgICAgICAgdGhpcy5maWx0ZXJQYW5lbC5jbGFzc0xpc3QucmVtb3ZlKCdzbTotdHJhbnNsYXRlLXgtZnVsbCcpXG4gICAgICAgICAgdGhpcy5maWx0ZXJQYW5lbC5jbGFzc0xpc3QucmVtb3ZlKCd0cmFuc2xhdGUteS1mdWxsJylcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsdGVyUGFuZWxUb2dnbGU/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmZpbHRlclBhbmVsLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgIGNsb3NlUGFuZWwoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcGVuUGFuZWwoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmZpbHRlclBhbmVsT3ZlcmxheT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbG9zZVBhbmVsKVxuICAgICAgICB0aGlzLmZpbHRlclBhbmVsQ2xvc2U/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2VQYW5lbClcbiAgICAgIH1cblxuICAgICAgc29ydERyb3Bkb3duID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0cmlnZ2VyID0gdGhpcz8uc29ydEl0ZW1zPy5xdWVyeVNlbGVjdG9yKCcjc29ydFRyaWdnZXInKVxuICAgICAgICBjb25zdCB0cmlnZ2VySWNvbiA9IHRyaWdnZXI/LnF1ZXJ5U2VsZWN0b3IoJy5pY29uJylcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXM/LnNvcnRJdGVtcz8ucXVlcnlTZWxlY3RvcignI3NvcnRMaXN0JylcblxuICAgICAgICB0cmlnZ2VyPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBpZiAobGlzdC5jbGFzc0xpc3QuY29udGFpbnMoJ2hpZGRlbicpKSB7XG4gICAgICAgICAgICBsaXN0LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXG4gICAgICAgICAgICB0cmlnZ2VySWNvbi5jbGFzc0xpc3QuYWRkKCdyb3RhdGUtMTgwJylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgICAgICAgICAgdHJpZ2dlckljb24uY2xhc3NMaXN0LnJlbW92ZSgncm90YXRlLTE4MCcpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBzb3J0QW5kRmlsdGVyID0gKHJlc2V0ID0gZmFsc2UsIGZldGNoVXJsID0gZmFsc2UpID0+IHtcbiAgICAgICAgbGV0IHNmVmFsdWVzID0gZmFsc2VcblxuICAgICAgICAvLyBGaW5kIGFsbCBcImFsbFwiIGNoZWNrYm94ZXMgdGhhdCBhcmUgY2hlY2tlZFxuICAgICAgICBjb25zdCBhbGxDaGVja2JveGVzID0gQXJyYXkuZnJvbSh0aGlzLnNvcnRBbmRGaWx0ZXJJdGVtcykuZmlsdGVyKFxuICAgICAgICAgIGl0ZW0gPT4gaXRlbS52YWx1ZSA9PT0gJ2FsbCcgJiYgaXRlbS5jaGVja2VkXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgZXhjbHVkZU5hbWVzID0gYWxsQ2hlY2tib3hlcy5tYXAoaXRlbSA9PiBpdGVtLm5hbWUpXG5cbiAgICAgICAgc2ZWYWx1ZXMgPSBBcnJheS5mcm9tKHRoaXMuc29ydEFuZEZpbHRlckl0ZW1zKVxuICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnZhbHVlICYmIGl0ZW0ubmFtZSkge1xuICAgICAgICAgICAgICAvLyBTa2lwIGlmIHRoaXMgZmlsdGVyJ3MgbmFtZSBpcyBpbiB0aGUgZXhjbHVkZSBsaXN0XG4gICAgICAgICAgICAgIGlmIChleGNsdWRlTmFtZXMuaW5jbHVkZXMoaXRlbS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKChpdGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgaXRlbS50eXBlID09PSAncmFkaW8nKSAmJiBpdGVtLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAncmFkaW8nICYmIHNmVmFsdWVzW2l0ZW0ubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIHNmVmFsdWVzW2l0ZW0ubmFtZV0gPSBpdGVtLnZhbHVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IFtpdGVtLm5hbWVdOiBpdGVtLnZhbHVlIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnbnVtYmVyJyB8fCBpdGVtLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IFtpdGVtLm5hbWVdOiBpdGVtLnZhbHVlIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gdW5kZWZpbmVkICYmIGl0ZW0gIT09IG51bGwpXG5cbiAgICAgICAgbGV0IHBhZ2VVcmwgPSB0aGlzLmNvbGxlY3Rpb25VcmxcbiAgICAgICAgbGV0IHNlY3Rpb25JZCA9IHRoaXMuc2VjdGlvbklkXG5cbiAgICAgICAgbGV0IHNlY3Rpb25VcmwgPSBwYWdlVXJsICsgJz9zZWN0aW9ucz0nICsgc2VjdGlvbklkICsgcXMoc2ZWYWx1ZXMsICcmJylcbiAgICAgICAgbGV0IG5ld1BhZ2VVcmwgPSBwYWdlVXJsICsgcXMoc2ZWYWx1ZXMpXG5cbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgc2VjdGlvblVybCA9IHBhZ2VVcmwgKyAnP3NlY3Rpb25zPScgKyBzZWN0aW9uSWRcbiAgICAgICAgICBuZXdQYWdlVXJsID0gcGFnZVVybFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZldGNoVXJsKSB7XG4gICAgICAgICAgY29uc3QgbmV3RnEgPSBmZXRjaFVybC5zcGxpdCgnPycpWzFdXG4gICAgICAgICAgaWYgKG5ld0ZxKSB7XG4gICAgICAgICAgICBzZWN0aW9uVXJsID0gcGFnZVVybCArICc/c2VjdGlvbnM9JyArIHNlY3Rpb25JZCArICcmJyArIG5ld0ZxXG4gICAgICAgICAgICBuZXdQYWdlVXJsID0gcGFnZVVybCArICc/JyArIG5ld0ZxXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc2V0XG4gICAgICAgICAgICBzZWN0aW9uVXJsID0gcGFnZVVybCArICc/c2VjdGlvbnM9JyArIHNlY3Rpb25JZFxuICAgICAgICAgICAgbmV3UGFnZVVybCA9IHBhZ2VVcmxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlY3Rpb24uY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS01MCcpXG5cbiAgICAgICAgZmV0Y2goc2VjdGlvblVybClcbiAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcylcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvbi5wYXJlbnRFbGVtZW50Lm91dGVySFRNTCA9IHJlc1t0aGlzLnNlY3Rpb25JZF1cbiAgICAgICAgICAgIC8vIFRPRE86IFNjcm9sbCB0byB0b3Agb2YgZ3JpZCBvbiByZWZyZXNoXG4gICAgICAgICAgICAvLyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vICAgY29uc3QgY29sbGVjdGlvbkdyaWRPZmZzZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29sbGVjdGlvbkl0ZW1zJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKGNvbGxlY3Rpb25HcmlkT2Zmc2V0KVxuICAgICAgICAgICAgLy8gICB3aW5kb3cuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgLy8gICAgIHRvcDogY29sbGVjdGlvbkdyaWRPZmZzZXQsXG4gICAgICAgICAgICAvLyAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgICAgICAvLyAgIH0pXG4gICAgICAgICAgICAvLyB9LCAyMDApXG4gICAgICAgICAgICB0aGlzLnNlY3Rpb24uY2xhc3NMaXN0LnJlbW92ZSgnb3BhY2l0eS01MCcpXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBuZXdQYWdlVXJsKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdvdmVyZmxvdy1oaWRkZW4nLCAnc206b3ZlcmZsb3ctYXV0bycpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjonLCBlcnJvcilcbiAgICAgICAgICB9KVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgKVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFNLFdBQVcsQ0FBQyxNQUFNLFVBQVUsUUFBUTtBQUN4QyxNQUFJO0FBQ0osU0FBTyxJQUFJLFNBQVM7QUFDbEIsaUJBQWEsS0FBSztBQUNsQixZQUFRLFdBQVcsTUFBTTtBQUN2QixXQUFLLE1BQU0sTUFBTSxJQUFJO0FBQUEsSUFDdkIsR0FBRyxPQUFPO0FBQUEsRUFDWjtBQUNGO0FBRUEsTUFBTSxLQUFLLENBQUMsWUFBWSxlQUFlLFVBQVU7QUFDL0MsTUFBSSxjQUFjO0FBRWxCLGFBQVcsUUFBUSxDQUFDLE9BQU8sVUFBVTtBQUNuQyxRQUFJLFVBQVU7QUFDZCxRQUFJLFFBQVEsR0FBRztBQUNiLGdCQUFVO0FBQUEsSUFDWjtBQUVBLFFBQUksY0FBYztBQUNoQixnQkFBVTtBQUFBLElBQ1o7QUFFQSxVQUFNLGNBQWMsT0FBTyxLQUFLLEtBQUssSUFBSSxNQUFNLE9BQU8sT0FBTyxLQUFLO0FBRWxFLG1CQUFlLFVBQVU7QUFBQSxFQUMzQixDQUFDO0FBRUQsU0FBTztBQUNUO0FBRUEsSUFBSSxDQUFDLGVBQWUsSUFBSSxpQkFBaUIsR0FBRztBQUMxQyxpQkFBZTtBQUFBLElBQ2I7QUFBQSxJQUNBLE1BQU0sdUJBQXVCLFlBQVk7QUFBQSxNQUN2QyxjQUFjO0FBQ1osY0FBTTtBQW1EUixpREFBb0IsTUFBTTtBQUN4QixnQkFBTSxTQUFTLFNBQVMsY0FBYyxzQ0FBc0M7QUFDNUUsZ0JBQU0sYUFBYSxNQUFNO0FBQ3ZCLHFCQUFTLEtBQUssVUFBVSxPQUFPLG1CQUFtQixrQkFBa0I7QUFDcEUsbUJBQU8sVUFBVSxPQUFPLGNBQWM7QUFDdEMsaUJBQUssbUJBQW1CLFVBQVUsSUFBSSxhQUFhLGNBQWMscUJBQXFCO0FBQ3RGLGlCQUFLLFlBQVksVUFBVSxPQUFPLFFBQVE7QUFDMUMsaUJBQUssWUFBWSxVQUFVLElBQUksc0JBQXNCO0FBQ3JELGlCQUFLLFlBQVksVUFBVSxJQUFJLGtCQUFrQjtBQUFBLFVBQ25EO0FBRUEsZ0JBQU0sWUFBWSxNQUFNO0FBQ3RCLHFCQUFTLEtBQUssVUFBVSxJQUFJLG1CQUFtQixrQkFBa0I7QUFDakUsbUJBQU8sVUFBVSxJQUFJLGNBQWM7QUFDbkMsaUJBQUssbUJBQW1CLFVBQVUsT0FBTyxhQUFhLGNBQWMscUJBQXFCO0FBQ3pGLGlCQUFLLFlBQVksVUFBVSxJQUFJLFFBQVE7QUFDdkMsaUJBQUssWUFBWSxVQUFVLE9BQU8sc0JBQXNCO0FBQ3hELGlCQUFLLFlBQVksVUFBVSxPQUFPLGtCQUFrQjtBQUFBLFVBQ3REO0FBRUEsZUFBSyxtQkFBbUIsaUJBQWlCLFNBQVMsTUFBTTtBQUN0RCxnQkFBSSxLQUFLLFlBQVksVUFBVSxTQUFTLFFBQVEsR0FBRztBQUNqRCx5QkFBVztBQUFBLFlBQ2IsT0FBTztBQUNMLHdCQUFVO0FBQUEsWUFDWjtBQUFBLFVBQ0YsQ0FBQztBQUVELGVBQUssb0JBQW9CLGlCQUFpQixTQUFTLFVBQVU7QUFDN0QsZUFBSyxrQkFBa0IsaUJBQWlCLFNBQVMsVUFBVTtBQUFBLFFBQzdEO0FBRUEsNENBQWUsTUFBTTtBQUNuQixnQkFBTSxVQUFVLE1BQU0sV0FBVyxjQUFjLGNBQWM7QUFDN0QsZ0JBQU0sY0FBYyxTQUFTLGNBQWMsT0FBTztBQUNsRCxnQkFBTSxPQUFPLE1BQU0sV0FBVyxjQUFjLFdBQVc7QUFFdkQsbUJBQVMsaUJBQWlCLFNBQVMsTUFBTTtBQUN2QyxnQkFBSSxLQUFLLFVBQVUsU0FBUyxRQUFRLEdBQUc7QUFDckMsbUJBQUssVUFBVSxPQUFPLFFBQVE7QUFDOUIsMEJBQVksVUFBVSxJQUFJLFlBQVk7QUFBQSxZQUN4QyxPQUFPO0FBQ0wsbUJBQUssVUFBVSxJQUFJLFFBQVE7QUFDM0IsMEJBQVksVUFBVSxPQUFPLFlBQVk7QUFBQSxZQUMzQztBQUFBLFVBQ0YsQ0FBQztBQUFBLFFBQ0g7QUFFQSw2Q0FBZ0IsQ0FBQyxRQUFRLE9BQU8sV0FBVyxVQUFVO0FBQ25ELGNBQUksV0FBVztBQUdmLGdCQUFNLGdCQUFnQixNQUFNLEtBQUssS0FBSyxrQkFBa0IsRUFBRTtBQUFBLFlBQ3hELFVBQVEsS0FBSyxVQUFVLFNBQVMsS0FBSztBQUFBLFVBQ3ZDO0FBQ0EsZ0JBQU0sZUFBZSxjQUFjLElBQUksVUFBUSxLQUFLLElBQUk7QUFFeEQscUJBQVcsTUFBTSxLQUFLLEtBQUssa0JBQWtCLEVBQzFDLElBQUksQ0FBQyxTQUFTO0FBQ2IsZ0JBQUksS0FBSyxTQUFTLEtBQUssTUFBTTtBQUUzQixrQkFBSSxhQUFhLFNBQVMsS0FBSyxJQUFJLEdBQUc7QUFDcEMsdUJBQU87QUFBQSxjQUNUO0FBQ0EsbUJBQUssS0FBSyxTQUFTLGNBQWMsS0FBSyxTQUFTLFlBQVksS0FBSyxTQUFTO0FBQ3ZFLG9CQUFJLEtBQUssU0FBUyxXQUFXLFNBQVMsS0FBSyxJQUFJLEdBQUc7QUFDaEQsMkJBQVMsS0FBSyxJQUFJLElBQUksS0FBSztBQUFBLGdCQUM3QixPQUFPO0FBQ0wseUJBQU8sRUFBRSxDQUFDLEtBQUssSUFBSSxHQUFHLEtBQUssTUFBTTtBQUFBLGdCQUNuQztBQUFBLGNBQ0YsV0FBVyxLQUFLLFNBQVMsWUFBWSxLQUFLLFNBQVMsUUFBUTtBQUN6RCx1QkFBTyxFQUFFLENBQUMsS0FBSyxJQUFJLEdBQUcsS0FBSyxNQUFNO0FBQUEsY0FDbkM7QUFBQSxZQUNGO0FBQUEsVUFDRixDQUFDLEVBQ0EsT0FBTyxDQUFDLFNBQVMsU0FBUyxVQUFhLFNBQVMsSUFBSTtBQUV2RCxjQUFJLFVBQVUsS0FBSztBQUNuQixjQUFJLFlBQVksS0FBSztBQUVyQixjQUFJLGFBQWEsVUFBVSxlQUFlLFlBQVksR0FBRyxVQUFVLEdBQUc7QUFDdEUsY0FBSSxhQUFhLFVBQVUsR0FBRyxRQUFRO0FBRXRDLGNBQUksT0FBTztBQUNULHlCQUFhLFVBQVUsZUFBZTtBQUN0Qyx5QkFBYTtBQUFBLFVBQ2Y7QUFFQSxjQUFJLFVBQVU7QUFDWixrQkFBTSxRQUFRLFNBQVMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxnQkFBSSxPQUFPO0FBQ1QsMkJBQWEsVUFBVSxlQUFlLFlBQVksTUFBTTtBQUN4RCwyQkFBYSxVQUFVLE1BQU07QUFBQSxZQUMvQixPQUFPO0FBRUwsMkJBQWEsVUFBVSxlQUFlO0FBQ3RDLDJCQUFhO0FBQUEsWUFDZjtBQUFBLFVBQ0Y7QUFFQSxlQUFLLFFBQVEsVUFBVSxJQUFJLFlBQVk7QUFFdkMsZ0JBQU0sVUFBVSxFQUNiLEtBQUssQ0FBQyxRQUFRLElBQUksS0FBSyxDQUFDLEVBQ3hCLEtBQUssQ0FBQyxRQUFRO0FBQ2Isb0JBQVEsSUFBSSxHQUFHO0FBQ2YsaUJBQUssUUFBUSxjQUFjLFlBQVksSUFBSSxLQUFLLFNBQVM7QUFVekQsaUJBQUssUUFBUSxVQUFVLE9BQU8sWUFBWTtBQUMxQyxtQkFBTyxRQUFRLGFBQWEsQ0FBQyxHQUFHLElBQUksVUFBVTtBQUFBLFVBQ2hELENBQUMsRUFDQSxLQUFLLE1BQU07QUFDVixxQkFBUyxLQUFLLFVBQVUsT0FBTyxtQkFBbUIsa0JBQWtCO0FBQUEsVUFDdEUsQ0FBQyxFQUNBLE1BQU0sQ0FBQyxVQUFVO0FBQ2hCLG9CQUFRLE1BQU0sVUFBVSxLQUFLO0FBQUEsVUFDL0IsQ0FBQztBQUVIO0FBQUEsUUFDRjtBQWhMRSxhQUFLLFVBQVU7QUFDZixhQUFLLGdCQUFnQixLQUFLLFFBQVEsUUFBUTtBQUMxQyxhQUFLLFlBQVksS0FBSyxRQUFRLFFBQVE7QUFDdEMsYUFBSyxVQUFVLEtBQUssY0FBYyxvQkFBb0I7QUFDdEQsYUFBSyxjQUFjLFNBQVMsY0FBYyxjQUFjO0FBQ3hELGFBQUssYUFBYSxLQUFLLFFBQVEsY0FBYyxNQUFNO0FBQ25ELGFBQUssa0JBQWtCLEtBQUssY0FBYyxrQkFBa0I7QUFDNUQsYUFBSyxvQkFBb0IsS0FBSyxpQkFBaUIsaUJBQWlCO0FBQ2hFLGFBQUssWUFBWSxLQUFLLGNBQWMsWUFBWTtBQUNoRCxhQUFLLHFCQUFxQixLQUFLO0FBQUEsVUFDN0I7QUFBQSxRQUNGO0FBR0EsYUFBSyxvQkFBb0IsS0FBSyxjQUFjLG9CQUFvQjtBQUNoRSxhQUFLLGNBQWMsS0FBSyxjQUFjLGNBQWM7QUFDcEQsYUFBSyxxQkFBcUIsS0FBSyxjQUFjLHFCQUFxQjtBQUNsRSxhQUFLLG1CQUFtQixLQUFLLGNBQWMsbUJBQW1CO0FBRTlELGFBQUssbUJBQW1CLFFBQVEsQ0FBQyxXQUFXO0FBQzFDLGtCQUFRLGlCQUFpQixVQUFVLENBQUMsVUFBVTtBQUU1QyxnQkFBSSxNQUFNLE9BQU8sU0FBUyxjQUFjLE1BQU0sT0FBTyxXQUFXLE1BQU0sT0FBTyxVQUFVLE9BQU87QUFDNUYsb0JBQU0sY0FBYyxLQUFLLGNBQWMsZUFBZSxNQUFNLE9BQU8scUJBQXFCO0FBQ3hGLGtCQUFJLGFBQWE7QUFDZiw0QkFBWSxVQUFVO0FBQUEsY0FDeEI7QUFBQSxZQUNGO0FBQ0EsaUJBQUssY0FBYztBQUFBLFVBQ3JCLENBQUM7QUFBQSxRQUNILENBQUM7QUFFRCxZQUFJLE1BQU0scUJBQXFCLE1BQU0sbUJBQW1CLFNBQVMsR0FBRztBQUNsRSxlQUFLLGtCQUFrQixRQUFRLENBQUMsVUFBVTtBQUN4QyxtQkFBTyxpQkFBaUIsU0FBUyxXQUFTO0FBQ3hDLG9CQUFNLGVBQWU7QUFDckIsbUJBQUssY0FBYyxPQUFPLE1BQU0sT0FBTyxJQUFJO0FBQUEsWUFDN0MsQ0FBQztBQUFBLFVBQ0gsQ0FBQztBQUFBLFFBQ0g7QUFFQSxhQUFLLGlCQUFpQixpQkFBaUIsU0FBUyxNQUFNO0FBQ3BELGVBQUssY0FBYyxJQUFJO0FBQUEsUUFDekIsQ0FBQztBQUVELGFBQUssYUFBYTtBQUNsQixhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCO0FBQUEsSUFrSUY7QUFBQSxFQUNGO0FBQ0Y7IiwibmFtZXMiOltdLCJmaWxlIjoiLi9zcmMvZW50cnlwb2ludHMvc29ydC1maWx0ZXIuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/entrypoints/sort-filter.js\n\n}");

/***/ }),

/***/ "./src/styles/main.scss":
/*!******************************!*\
  !*** ./src/styles/main.scss ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL21haW4uc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waWZ5LXN0YXJ0ZXIvLi9zcmMvc3R5bGVzL21haW4uc2Nzcz81MTA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/styles/main.scss\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entrypoints/global.js");
/******/ 	
/******/ })()
;