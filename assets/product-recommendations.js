/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/entrypoints/product-recommendations.js":
/*!****************************************************!*\
  !*** ./src/entrypoints/product-recommendations.js ***!
  \****************************************************/
/***/ (() => {

eval("{if (!customElements.get(\"product-recommendations\")) {\n  customElements.define(\n    \"product-recommendations\",\n    class ProductRecommendations extends HTMLElement {\n      constructor() {\n        super();\n        this.productHandle = this.dataset.productHandle;\n        this.productId = this.dataset.productId;\n        this.collectionHandle = this.dataset.collectionHandle;\n        this.productTags = this.dataset.productTags ? this.dataset.productTags.split(\",\").map((t) => t.trim()) : [];\n        this.minProducts = parseInt(this.dataset.minProducts) || 4;\n        this.maxProducts = parseInt(this.dataset.maxProducts) || 8;\n        this.hideSoldOut = this.dataset.hideSoldOut === \"true\";\n        this.sectionId = this.dataset.sectionId;\n        this.container = this.querySelector(\"[data-product-container]\");\n        this.loading = this.querySelector(\"[data-loading]\");\n      }\n      async connectedCallback() {\n        console.log(\"product-recommendations: Initializing\", {\n          productId: this.productId,\n          productHandle: this.productHandle,\n          collectionHandle: this.collectionHandle,\n          tags: this.productTags,\n          min: this.minProducts,\n          max: this.maxProducts,\n          hideSoldOut: this.hideSoldOut,\n          hasContainer: !!this.container\n        });\n        if (!this.productId || !this.container) {\n          console.error(\"product-recommendations: Missing required elements or data attributes\", {\n            productId: this.productId,\n            container: this.container\n          });\n          return;\n        }\n        try {\n          const products = await this.fetchProducts();\n          console.log(\"product-recommendations: Fetched products\", products);\n          await this.renderProducts(products);\n        } catch (error) {\n          console.error(\"product-recommendations: Error fetching products\", error);\n          this.hideLoading();\n        }\n      }\n      async fetchProducts() {\n        let products = [];\n        try {\n          const recommendations = await this.fetchRecommendations();\n          products = [...recommendations];\n          console.log(\"product-recommendations: Step 1 (Recommendations API):\", products.length, \"products\");\n        } catch (error) {\n          console.warn(\"product-recommendations: Recommendations API failed\", error);\n        }\n        products = this.filterProductsWithImages(products);\n        if (this.hideSoldOut) {\n          const beforeFilter = products.length;\n          products = this.filterAvailableProducts(products);\n          console.log(`product-recommendations: Filtered sold out: ${beforeFilter} -> ${products.length}`);\n        }\n        if (products.length < this.minProducts && this.collectionHandle) {\n          try {\n            const collectionProducts = await this.fetchCollectionProducts();\n            let filtered = this.filterProductsWithImages(collectionProducts);\n            if (this.hideSoldOut) {\n              filtered = this.filterAvailableProducts(filtered);\n            }\n            console.log(\"product-recommendations: Step 2 (Collection):\", filtered.length, \"products\");\n            products = this.mergeProducts(products, filtered);\n            console.log(\"product-recommendations: After merge:\", products.length, \"products\");\n          } catch (error) {\n            console.warn(\"product-recommendations: Collection fetch failed\", error);\n          }\n        }\n        if (products.length < this.minProducts && this.productTags.length > 0) {\n          try {\n            const taggedProducts = await this.fetchTaggedProducts();\n            let filtered = this.filterProductsWithImages(taggedProducts);\n            if (this.hideSoldOut) {\n              filtered = this.filterAvailableProducts(filtered);\n            }\n            console.log(\"product-recommendations: Step 3 (Tagged):\", filtered.length, \"products\");\n            products = this.mergeProducts(products, filtered);\n            console.log(\"product-recommendations: After merge:\", products.length, \"products\");\n          } catch (error) {\n            console.warn(\"product-recommendations: Tagged products fetch failed\", error);\n          }\n        }\n        if (products.length < this.minProducts) {\n          console.log(`product-recommendations: Step 4 (Random) - need ${this.minProducts - products.length} more products`);\n          try {\n            const randomProducts = await this.fetchRandomProducts();\n            let filtered = this.filterProductsWithImages(randomProducts);\n            if (this.hideSoldOut) {\n              filtered = this.filterAvailableProducts(filtered);\n            }\n            console.log(\"product-recommendations: Step 4 (Random):\", filtered.length, \"products\");\n            products = this.mergeProducts(products, filtered);\n            console.log(\"product-recommendations: After merge:\", products.length, \"products\");\n          } catch (error) {\n            console.warn(\"product-recommendations: Random products fetch failed\", error);\n          }\n        }\n        console.log(\"product-recommendations: Final product count:\", products.length);\n        const shuffled = this.shuffleArray(products);\n        return shuffled.slice(0, this.maxProducts);\n      }\n      async fetchRecommendations() {\n        const fetchLimit = this.hideSoldOut ? Math.max(this.maxProducts * 3, 20) : this.maxProducts;\n        const response = await fetch(\n          `/recommendations/products.json?product_id=${this.productId}&limit=${fetchLimit}`\n        );\n        if (!response.ok) {\n          throw new Error(\"Recommendations API request failed\");\n        }\n        const data = await response.json();\n        return this.filterCurrentProduct(data.products || []);\n      }\n      async fetchCollectionProducts() {\n        const response = await fetch(\n          `/collections/${this.collectionHandle}/products.json?limit=250`\n        );\n        if (!response.ok) {\n          throw new Error(\"Collection products request failed\");\n        }\n        const data = await response.json();\n        return this.filterCurrentProduct(data.products || []);\n      }\n      async fetchTaggedProducts() {\n        const response = await fetch(\n          `/collections/all/products.json?limit=250`\n        );\n        if (!response.ok) {\n          throw new Error(\"Tagged products request failed\");\n        }\n        const data = await response.json();\n        const taggedProducts = (data.products || []).filter((product) => {\n          return this.productTags.some((tag) => product.tags.includes(tag));\n        });\n        return this.filterCurrentProduct(taggedProducts);\n      }\n      async fetchRandomProducts() {\n        const response = await fetch(\n          `/collections/all/products.json?limit=250`\n        );\n        if (!response.ok) {\n          throw new Error(\"Random products request failed\");\n        }\n        const data = await response.json();\n        console.log(\"product-recommendations: Random fetch raw:\", data.products?.length || 0, \"products\");\n        const shuffled = this.shuffleArray(data.products || []);\n        const afterFilter = this.filterCurrentProduct(shuffled);\n        console.log(\"product-recommendations: Random after filtering current product:\", afterFilter.length, \"products\");\n        return afterFilter;\n      }\n      filterCurrentProduct(products) {\n        return products.filter(\n          (product) => product.id.toString() !== this.productId && product.handle !== this.productHandle\n        );\n      }\n      filterAvailableProducts(products) {\n        const available = products.filter((product) => {\n          if (typeof product.available === \"boolean\") {\n            return product.available;\n          }\n          if (product.variants && product.variants.length > 0) {\n            return product.variants.some((variant) => variant.available === true);\n          }\n          return true;\n        });\n        console.log(`product-recommendations: filterAvailableProducts: ${products.length} -> ${available.length}`);\n        return available;\n      }\n      filterProductsWithImages(products) {\n        const withImages = products.filter((product) => {\n          if (product.featured_image && typeof product.featured_image === \"string\" && product.featured_image.length > 0) {\n            return true;\n          }\n          if (product.images && Array.isArray(product.images) && product.images.length > 0) {\n            const firstImage = product.images[0];\n            if (typeof firstImage === \"string\" && firstImage.length > 0) {\n              return true;\n            }\n            if (firstImage && typeof firstImage === \"object\" && firstImage.src && firstImage.src.length > 0) {\n              return true;\n            }\n          }\n          return false;\n        });\n        const filtered = products.length - withImages.length;\n        if (filtered > 0) {\n          console.log(`product-recommendations: filterProductsWithImages: ${products.length} -> ${withImages.length} (filtered ${filtered} products without images)`);\n        }\n        return withImages;\n      }\n      mergeProducts(existing, newProducts) {\n        const existingIds = new Set(existing.map((p) => p.id));\n        const uniqueNew = newProducts.filter((p) => !existingIds.has(p.id));\n        return [...existing, ...uniqueNew];\n      }\n      shuffleArray(array) {\n        const shuffled = [...array];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n      }\n      async renderProducts(products) {\n        console.log(\"product-recommendations: Rendering\", products.length, \"products\");\n        if (products.length === 0) {\n          console.log(\"product-recommendations: No products to render\");\n          this.hideLoading();\n          this.style.display = \"none\";\n          return;\n        }\n        this.container.innerHTML = \"\";\n        try {\n          const cardPromises = products.map(\n            (product) => fetch(`/products/${product.handle}?view=card`).then((response) => {\n              if (!response.ok) {\n                console.warn(`Failed to fetch card for ${product.handle}`);\n                return \"\";\n              }\n              return response.text();\n            }).catch((err) => {\n              console.warn(`Error fetching card for ${product.handle}:`, err);\n              return \"\";\n            })\n          );\n          const cards = await Promise.all(cardPromises);\n          this.container.innerHTML = cards.filter((card) => card).join(\"\");\n          console.log(\"product-recommendations: Rendered\", this.container.children.length, \"product cards\");\n        } catch (error) {\n          console.error(\"product-recommendations: Failed to render cards\", error);\n        }\n        this.hideLoading();\n      }\n      hideLoading() {\n        if (this.loading) {\n          this.loading.style.display = \"none\";\n        }\n      }\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waWZ5LXN0YXJ0ZXIvLi9zcmMvZW50cnlwb2ludHMvcHJvZHVjdC1yZWNvbW1lbmRhdGlvbnMuanM/MzNkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb2R1Y3QgUmVjb21tZW5kYXRpb25zIENvbXBvbmVudFxuICpcbiAqIEZldGNoZXMgcHJvZHVjdCByZWNvbW1lbmRhdGlvbnMgd2l0aCBpbnRlbGxpZ2VudCBmYWxsYmFja3M6XG4gKiAxLiBTaG9waWZ5IFByb2R1Y3QgUmVjb21tZW5kYXRpb25zIEFQSVxuICogMi4gUHJvZHVjdHMgZnJvbSBzYW1lIGNvbGxlY3Rpb25cbiAqIDMuIFByb2R1Y3RzIHdpdGggc2FtZSB0YWdzXG4gKiA0LiBSYW5kb20gcHJvZHVjdHNcbiAqXG4gKiBBbHdheXMgZXhjbHVkZXMgdGhlIGN1cnJlbnQgcHJvZHVjdCBmcm9tIHJlc3VsdHMuXG4gKi9cblxuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zJykpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFxuICAgICdwcm9kdWN0LXJlY29tbWVuZGF0aW9ucycsXG4gICAgY2xhc3MgUHJvZHVjdFJlY29tbWVuZGF0aW9ucyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMucHJvZHVjdEhhbmRsZSA9IHRoaXMuZGF0YXNldC5wcm9kdWN0SGFuZGxlXG4gICAgICAgIHRoaXMucHJvZHVjdElkID0gdGhpcy5kYXRhc2V0LnByb2R1Y3RJZFxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25IYW5kbGUgPSB0aGlzLmRhdGFzZXQuY29sbGVjdGlvbkhhbmRsZVxuICAgICAgICB0aGlzLnByb2R1Y3RUYWdzID0gdGhpcy5kYXRhc2V0LnByb2R1Y3RUYWdzID8gdGhpcy5kYXRhc2V0LnByb2R1Y3RUYWdzLnNwbGl0KCcsJykubWFwKHQgPT4gdC50cmltKCkpIDogW11cbiAgICAgICAgdGhpcy5taW5Qcm9kdWN0cyA9IHBhcnNlSW50KHRoaXMuZGF0YXNldC5taW5Qcm9kdWN0cykgfHwgNFxuICAgICAgICB0aGlzLm1heFByb2R1Y3RzID0gcGFyc2VJbnQodGhpcy5kYXRhc2V0Lm1heFByb2R1Y3RzKSB8fCA4XG4gICAgICAgIHRoaXMuaGlkZVNvbGRPdXQgPSB0aGlzLmRhdGFzZXQuaGlkZVNvbGRPdXQgPT09ICd0cnVlJ1xuICAgICAgICB0aGlzLnNlY3Rpb25JZCA9IHRoaXMuZGF0YXNldC5zZWN0aW9uSWRcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXByb2R1Y3QtY29udGFpbmVyXScpXG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRoaXMucXVlcnlTZWxlY3RvcignW2RhdGEtbG9hZGluZ10nKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBJbml0aWFsaXppbmcnLCB7XG4gICAgICAgICAgcHJvZHVjdElkOiB0aGlzLnByb2R1Y3RJZCxcbiAgICAgICAgICBwcm9kdWN0SGFuZGxlOiB0aGlzLnByb2R1Y3RIYW5kbGUsXG4gICAgICAgICAgY29sbGVjdGlvbkhhbmRsZTogdGhpcy5jb2xsZWN0aW9uSGFuZGxlLFxuICAgICAgICAgIHRhZ3M6IHRoaXMucHJvZHVjdFRhZ3MsXG4gICAgICAgICAgbWluOiB0aGlzLm1pblByb2R1Y3RzLFxuICAgICAgICAgIG1heDogdGhpcy5tYXhQcm9kdWN0cyxcbiAgICAgICAgICBoaWRlU29sZE91dDogdGhpcy5oaWRlU29sZE91dCxcbiAgICAgICAgICBoYXNDb250YWluZXI6ICEhdGhpcy5jb250YWluZXJcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXRoaXMucHJvZHVjdElkIHx8ICF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBNaXNzaW5nIHJlcXVpcmVkIGVsZW1lbnRzIG9yIGRhdGEgYXR0cmlidXRlcycsIHtcbiAgICAgICAgICAgIHByb2R1Y3RJZDogdGhpcy5wcm9kdWN0SWQsXG4gICAgICAgICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcHJvZHVjdHMgPSBhd2FpdCB0aGlzLmZldGNoUHJvZHVjdHMoKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogRmV0Y2hlZCBwcm9kdWN0cycsIHByb2R1Y3RzKVxuICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyUHJvZHVjdHMocHJvZHVjdHMpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigncHJvZHVjdC1yZWNvbW1lbmRhdGlvbnM6IEVycm9yIGZldGNoaW5nIHByb2R1Y3RzJywgZXJyb3IpXG4gICAgICAgICAgdGhpcy5oaWRlTG9hZGluZygpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXN5bmMgZmV0Y2hQcm9kdWN0cygpIHtcbiAgICAgICAgbGV0IHByb2R1Y3RzID0gW11cblxuICAgICAgICAvLyBTdGVwIDE6IFRyeSBTaG9waWZ5IFByb2R1Y3QgUmVjb21tZW5kYXRpb25zIEFQSVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IGF3YWl0IHRoaXMuZmV0Y2hSZWNvbW1lbmRhdGlvbnMoKVxuICAgICAgICAgIHByb2R1Y3RzID0gWy4uLnJlY29tbWVuZGF0aW9uc11cbiAgICAgICAgICBjb25zb2xlLmxvZygncHJvZHVjdC1yZWNvbW1lbmRhdGlvbnM6IFN0ZXAgMSAoUmVjb21tZW5kYXRpb25zIEFQSSk6JywgcHJvZHVjdHMubGVuZ3RoLCAncHJvZHVjdHMnKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybigncHJvZHVjdC1yZWNvbW1lbmRhdGlvbnM6IFJlY29tbWVuZGF0aW9ucyBBUEkgZmFpbGVkJywgZXJyb3IpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWx0ZXIgb3V0IHByb2R1Y3RzIHdpdGhvdXQgaW1hZ2VzIChhbHdheXMpXG4gICAgICAgIHByb2R1Y3RzID0gdGhpcy5maWx0ZXJQcm9kdWN0c1dpdGhJbWFnZXMocHJvZHVjdHMpXG5cbiAgICAgICAgLy8gRmlsdGVyIG91dCBzb2xkIG91dCBwcm9kdWN0cyBpZiBvcHRpb24gaXMgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5oaWRlU29sZE91dCkge1xuICAgICAgICAgIGNvbnN0IGJlZm9yZUZpbHRlciA9IHByb2R1Y3RzLmxlbmd0aFxuICAgICAgICAgIHByb2R1Y3RzID0gdGhpcy5maWx0ZXJBdmFpbGFibGVQcm9kdWN0cyhwcm9kdWN0cylcbiAgICAgICAgICBjb25zb2xlLmxvZyhgcHJvZHVjdC1yZWNvbW1lbmRhdGlvbnM6IEZpbHRlcmVkIHNvbGQgb3V0OiAke2JlZm9yZUZpbHRlcn0gLT4gJHtwcm9kdWN0cy5sZW5ndGh9YClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0ZXAgMjogSWYgd2UgbmVlZCBtb3JlIHByb2R1Y3RzLCBmZXRjaCBmcm9tIHNhbWUgY29sbGVjdGlvblxuICAgICAgICBpZiAocHJvZHVjdHMubGVuZ3RoIDwgdGhpcy5taW5Qcm9kdWN0cyAmJiB0aGlzLmNvbGxlY3Rpb25IYW5kbGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblByb2R1Y3RzID0gYXdhaXQgdGhpcy5mZXRjaENvbGxlY3Rpb25Qcm9kdWN0cygpXG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSB0aGlzLmZpbHRlclByb2R1Y3RzV2l0aEltYWdlcyhjb2xsZWN0aW9uUHJvZHVjdHMpXG4gICAgICAgICAgICBpZiAodGhpcy5oaWRlU29sZE91dCkge1xuICAgICAgICAgICAgICBmaWx0ZXJlZCA9IHRoaXMuZmlsdGVyQXZhaWxhYmxlUHJvZHVjdHMoZmlsdGVyZWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncHJvZHVjdC1yZWNvbW1lbmRhdGlvbnM6IFN0ZXAgMiAoQ29sbGVjdGlvbik6JywgZmlsdGVyZWQubGVuZ3RoLCAncHJvZHVjdHMnKVxuICAgICAgICAgICAgcHJvZHVjdHMgPSB0aGlzLm1lcmdlUHJvZHVjdHMocHJvZHVjdHMsIGZpbHRlcmVkKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBBZnRlciBtZXJnZTonLCBwcm9kdWN0cy5sZW5ndGgsICdwcm9kdWN0cycpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJvZHVjdC1yZWNvbW1lbmRhdGlvbnM6IENvbGxlY3Rpb24gZmV0Y2ggZmFpbGVkJywgZXJyb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RlcCAzOiBJZiB3ZSBzdGlsbCBuZWVkIG1vcmUsIGZldGNoIHByb2R1Y3RzIHdpdGggc2FtZSB0YWdzXG4gICAgICAgIGlmIChwcm9kdWN0cy5sZW5ndGggPCB0aGlzLm1pblByb2R1Y3RzICYmIHRoaXMucHJvZHVjdFRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0YWdnZWRQcm9kdWN0cyA9IGF3YWl0IHRoaXMuZmV0Y2hUYWdnZWRQcm9kdWN0cygpXG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSB0aGlzLmZpbHRlclByb2R1Y3RzV2l0aEltYWdlcyh0YWdnZWRQcm9kdWN0cylcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVTb2xkT3V0KSB7XG4gICAgICAgICAgICAgIGZpbHRlcmVkID0gdGhpcy5maWx0ZXJBdmFpbGFibGVQcm9kdWN0cyhmaWx0ZXJlZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogU3RlcCAzIChUYWdnZWQpOicsIGZpbHRlcmVkLmxlbmd0aCwgJ3Byb2R1Y3RzJylcbiAgICAgICAgICAgIHByb2R1Y3RzID0gdGhpcy5tZXJnZVByb2R1Y3RzKHByb2R1Y3RzLCBmaWx0ZXJlZClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogQWZ0ZXIgbWVyZ2U6JywgcHJvZHVjdHMubGVuZ3RoLCAncHJvZHVjdHMnKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBUYWdnZWQgcHJvZHVjdHMgZmV0Y2ggZmFpbGVkJywgZXJyb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RlcCA0OiBJZiB3ZSBzdGlsbCBuZWVkIG1vcmUsIGZldGNoIHJhbmRvbSBwcm9kdWN0c1xuICAgICAgICBpZiAocHJvZHVjdHMubGVuZ3RoIDwgdGhpcy5taW5Qcm9kdWN0cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogU3RlcCA0IChSYW5kb20pIC0gbmVlZCAke3RoaXMubWluUHJvZHVjdHMgLSBwcm9kdWN0cy5sZW5ndGh9IG1vcmUgcHJvZHVjdHNgKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYW5kb21Qcm9kdWN0cyA9IGF3YWl0IHRoaXMuZmV0Y2hSYW5kb21Qcm9kdWN0cygpXG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSB0aGlzLmZpbHRlclByb2R1Y3RzV2l0aEltYWdlcyhyYW5kb21Qcm9kdWN0cylcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVTb2xkT3V0KSB7XG4gICAgICAgICAgICAgIGZpbHRlcmVkID0gdGhpcy5maWx0ZXJBdmFpbGFibGVQcm9kdWN0cyhmaWx0ZXJlZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogU3RlcCA0IChSYW5kb20pOicsIGZpbHRlcmVkLmxlbmd0aCwgJ3Byb2R1Y3RzJylcbiAgICAgICAgICAgIHByb2R1Y3RzID0gdGhpcy5tZXJnZVByb2R1Y3RzKHByb2R1Y3RzLCBmaWx0ZXJlZClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogQWZ0ZXIgbWVyZ2U6JywgcHJvZHVjdHMubGVuZ3RoLCAncHJvZHVjdHMnKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBSYW5kb20gcHJvZHVjdHMgZmV0Y2ggZmFpbGVkJywgZXJyb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBGaW5hbCBwcm9kdWN0IGNvdW50OicsIHByb2R1Y3RzLmxlbmd0aClcblxuICAgICAgICAvLyBTaHVmZmxlIHRoZSBmaW5hbCBsaXN0IHRvIGVuc3VyZSByYW5kb21uZXNzIGFjcm9zcyBhbGwgc291cmNlc1xuICAgICAgICBjb25zdCBzaHVmZmxlZCA9IHRoaXMuc2h1ZmZsZUFycmF5KHByb2R1Y3RzKVxuXG4gICAgICAgIC8vIExpbWl0IHRvIG1heCBhbmQgcmV0dXJuXG4gICAgICAgIHJldHVybiBzaHVmZmxlZC5zbGljZSgwLCB0aGlzLm1heFByb2R1Y3RzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBmZXRjaFJlY29tbWVuZGF0aW9ucygpIHtcbiAgICAgICAgLy8gRmV0Y2ggbW9yZSBwcm9kdWN0cyB3aGVuIGhpZGluZyBzb2xkIG91dCB0byBhY2NvdW50IGZvciBmaWx0ZXJpbmdcbiAgICAgICAgY29uc3QgZmV0Y2hMaW1pdCA9IHRoaXMuaGlkZVNvbGRPdXQgPyBNYXRoLm1heCh0aGlzLm1heFByb2R1Y3RzICogMywgMjApIDogdGhpcy5tYXhQcm9kdWN0c1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgICAgYC9yZWNvbW1lbmRhdGlvbnMvcHJvZHVjdHMuanNvbj9wcm9kdWN0X2lkPSR7dGhpcy5wcm9kdWN0SWR9JmxpbWl0PSR7ZmV0Y2hMaW1pdH1gXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWNvbW1lbmRhdGlvbnMgQVBJIHJlcXVlc3QgZmFpbGVkJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ3VycmVudFByb2R1Y3QoZGF0YS5wcm9kdWN0cyB8fCBbXSlcbiAgICAgIH1cblxuICAgICAgYXN5bmMgZmV0Y2hDb2xsZWN0aW9uUHJvZHVjdHMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgICAgYC9jb2xsZWN0aW9ucy8ke3RoaXMuY29sbGVjdGlvbkhhbmRsZX0vcHJvZHVjdHMuanNvbj9saW1pdD0yNTBgXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uIHByb2R1Y3RzIHJlcXVlc3QgZmFpbGVkJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ3VycmVudFByb2R1Y3QoZGF0YS5wcm9kdWN0cyB8fCBbXSlcbiAgICAgIH1cblxuICAgICAgYXN5bmMgZmV0Y2hUYWdnZWRQcm9kdWN0cygpIHtcbiAgICAgICAgLy8gRmV0Y2ggcHJvZHVjdHMgbWF0Y2hpbmcgYW55IG9mIHRoZSB0YWdzXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgICAgYC9jb2xsZWN0aW9ucy9hbGwvcHJvZHVjdHMuanNvbj9saW1pdD0yNTBgXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWdnZWQgcHJvZHVjdHMgcmVxdWVzdCBmYWlsZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICBjb25zdCB0YWdnZWRQcm9kdWN0cyA9IChkYXRhLnByb2R1Y3RzIHx8IFtdKS5maWx0ZXIocHJvZHVjdCA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvZHVjdFRhZ3Muc29tZSh0YWcgPT4gcHJvZHVjdC50YWdzLmluY2x1ZGVzKHRhZykpXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ3VycmVudFByb2R1Y3QodGFnZ2VkUHJvZHVjdHMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGZldGNoUmFuZG9tUHJvZHVjdHMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgICAgYC9jb2xsZWN0aW9ucy9hbGwvcHJvZHVjdHMuanNvbj9saW1pdD0yNTBgXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYW5kb20gcHJvZHVjdHMgcmVxdWVzdCBmYWlsZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICBjb25zb2xlLmxvZygncHJvZHVjdC1yZWNvbW1lbmRhdGlvbnM6IFJhbmRvbSBmZXRjaCByYXc6JywgZGF0YS5wcm9kdWN0cz8ubGVuZ3RoIHx8IDAsICdwcm9kdWN0cycpXG5cbiAgICAgICAgY29uc3Qgc2h1ZmZsZWQgPSB0aGlzLnNodWZmbGVBcnJheShkYXRhLnByb2R1Y3RzIHx8IFtdKVxuICAgICAgICBjb25zdCBhZnRlckZpbHRlciA9IHRoaXMuZmlsdGVyQ3VycmVudFByb2R1Y3Qoc2h1ZmZsZWQpXG4gICAgICAgIGNvbnNvbGUubG9nKCdwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogUmFuZG9tIGFmdGVyIGZpbHRlcmluZyBjdXJyZW50IHByb2R1Y3Q6JywgYWZ0ZXJGaWx0ZXIubGVuZ3RoLCAncHJvZHVjdHMnKVxuXG4gICAgICAgIHJldHVybiBhZnRlckZpbHRlclxuICAgICAgfVxuXG4gICAgICBmaWx0ZXJDdXJyZW50UHJvZHVjdChwcm9kdWN0cykge1xuICAgICAgICByZXR1cm4gcHJvZHVjdHMuZmlsdGVyKHByb2R1Y3QgPT5cbiAgICAgICAgICBwcm9kdWN0LmlkLnRvU3RyaW5nKCkgIT09IHRoaXMucHJvZHVjdElkICYmXG4gICAgICAgICAgcHJvZHVjdC5oYW5kbGUgIT09IHRoaXMucHJvZHVjdEhhbmRsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGZpbHRlckF2YWlsYWJsZVByb2R1Y3RzKHByb2R1Y3RzKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhdmFpbGFibGUgcHJvZHVjdHMgLSBoYW5kbGUgYm90aCBBUEkgcmVzcG9uc2UgZm9ybWF0c1xuICAgICAgICBjb25zdCBhdmFpbGFibGUgPSBwcm9kdWN0cy5maWx0ZXIocHJvZHVjdCA9PiB7XG4gICAgICAgICAgLy8gUmVjb21tZW5kYXRpb25zIEFQSSBpbmNsdWRlcyAnYXZhaWxhYmxlJyBmaWVsZFxuICAgICAgICAgIGlmICh0eXBlb2YgcHJvZHVjdC5hdmFpbGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb2R1Y3QuYXZhaWxhYmxlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29sbGVjdGlvbnMgQVBJIGRvZXNuJ3QgaW5jbHVkZSAnYXZhaWxhYmxlJywgY2hlY2sgdmFyaWFudHMgaW5zdGVhZFxuICAgICAgICAgIGlmIChwcm9kdWN0LnZhcmlhbnRzICYmIHByb2R1Y3QudmFyaWFudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2R1Y3QudmFyaWFudHMuc29tZSh2YXJpYW50ID0+IHZhcmlhbnQuYXZhaWxhYmxlID09PSB0cnVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIG5vIHZhcmlhbnRzIGRhdGEsIGFzc3VtZSBhdmFpbGFibGVcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGBwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogZmlsdGVyQXZhaWxhYmxlUHJvZHVjdHM6ICR7cHJvZHVjdHMubGVuZ3RofSAtPiAke2F2YWlsYWJsZS5sZW5ndGh9YClcbiAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVxuICAgICAgfVxuXG4gICAgICBmaWx0ZXJQcm9kdWN0c1dpdGhJbWFnZXMocHJvZHVjdHMpIHtcbiAgICAgICAgY29uc3Qgd2l0aEltYWdlcyA9IHByb2R1Y3RzLmZpbHRlcihwcm9kdWN0ID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGhhcyBhIHZhbGlkIGZlYXR1cmVkIGltYWdlXG4gICAgICAgICAgaWYgKHByb2R1Y3QuZmVhdHVyZWRfaW1hZ2UgJiYgdHlwZW9mIHByb2R1Y3QuZmVhdHVyZWRfaW1hZ2UgPT09ICdzdHJpbmcnICYmIHByb2R1Y3QuZmVhdHVyZWRfaW1hZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBwcm9kdWN0IGhhcyBhbnkgdmFsaWQgaW1hZ2VzIGluIGltYWdlcyBhcnJheVxuICAgICAgICAgIGlmIChwcm9kdWN0LmltYWdlcyAmJiBBcnJheS5pc0FycmF5KHByb2R1Y3QuaW1hZ2VzKSAmJiBwcm9kdWN0LmltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaXJzdCBpbWFnZSBpcyB2YWxpZFxuICAgICAgICAgICAgY29uc3QgZmlyc3RJbWFnZSA9IHByb2R1Y3QuaW1hZ2VzWzBdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0SW1hZ2UgPT09ICdzdHJpbmcnICYmIGZpcnN0SW1hZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIGlmIGltYWdlcyBhcmUgb2JqZWN0cyB3aXRoIHNyYyBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKGZpcnN0SW1hZ2UgJiYgdHlwZW9mIGZpcnN0SW1hZ2UgPT09ICdvYmplY3QnICYmIGZpcnN0SW1hZ2Uuc3JjICYmIGZpcnN0SW1hZ2Uuc3JjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHByb2R1Y3RzLmxlbmd0aCAtIHdpdGhJbWFnZXMubGVuZ3RoXG4gICAgICAgIGlmIChmaWx0ZXJlZCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgcHJvZHVjdC1yZWNvbW1lbmRhdGlvbnM6IGZpbHRlclByb2R1Y3RzV2l0aEltYWdlczogJHtwcm9kdWN0cy5sZW5ndGh9IC0+ICR7d2l0aEltYWdlcy5sZW5ndGh9IChmaWx0ZXJlZCAke2ZpbHRlcmVkfSBwcm9kdWN0cyB3aXRob3V0IGltYWdlcylgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aXRoSW1hZ2VzXG4gICAgICB9XG5cbiAgICAgIG1lcmdlUHJvZHVjdHMoZXhpc3RpbmcsIG5ld1Byb2R1Y3RzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSWRzID0gbmV3IFNldChleGlzdGluZy5tYXAocCA9PiBwLmlkKSlcbiAgICAgICAgY29uc3QgdW5pcXVlTmV3ID0gbmV3UHJvZHVjdHMuZmlsdGVyKHAgPT4gIWV4aXN0aW5nSWRzLmhhcyhwLmlkKSlcbiAgICAgICAgcmV0dXJuIFsuLi5leGlzdGluZywgLi4udW5pcXVlTmV3XVxuICAgICAgfVxuXG4gICAgICBzaHVmZmxlQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgY29uc3Qgc2h1ZmZsZWQgPSBbLi4uYXJyYXldXG4gICAgICAgIGZvciAobGV0IGkgPSBzaHVmZmxlZC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgIFtzaHVmZmxlZFtpXSwgc2h1ZmZsZWRbal1dID0gW3NodWZmbGVkW2pdLCBzaHVmZmxlZFtpXV1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2h1ZmZsZWRcbiAgICAgIH1cblxuICAgICAgYXN5bmMgcmVuZGVyUHJvZHVjdHMocHJvZHVjdHMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBSZW5kZXJpbmcnLCBwcm9kdWN0cy5sZW5ndGgsICdwcm9kdWN0cycpXG5cbiAgICAgICAgaWYgKHByb2R1Y3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9kdWN0LXJlY29tbWVuZGF0aW9uczogTm8gcHJvZHVjdHMgdG8gcmVuZGVyJylcbiAgICAgICAgICB0aGlzLmhpZGVMb2FkaW5nKClcbiAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBGZXRjaCBhbGwgcHJvZHVjdCBjYXJkcyBpbiBwYXJhbGxlbFxuICAgICAgICAgIGNvbnN0IGNhcmRQcm9taXNlcyA9IHByb2R1Y3RzLm1hcChwcm9kdWN0ID0+XG4gICAgICAgICAgICBmZXRjaChgL3Byb2R1Y3RzLyR7cHJvZHVjdC5oYW5kbGV9P3ZpZXc9Y2FyZGApXG4gICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBmZXRjaCBjYXJkIGZvciAke3Byb2R1Y3QuaGFuZGxlfWApXG4gICAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGZldGNoaW5nIGNhcmQgZm9yICR7cHJvZHVjdC5oYW5kbGV9OmAsIGVycilcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG5cbiAgICAgICAgICBjb25zdCBjYXJkcyA9IGF3YWl0IFByb21pc2UuYWxsKGNhcmRQcm9taXNlcylcblxuICAgICAgICAgIC8vIEluc2VydCBhbGwgY2FyZHNcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSBjYXJkcy5maWx0ZXIoY2FyZCA9PiBjYXJkKS5qb2luKCcnKVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBSZW5kZXJlZCcsIHRoaXMuY29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCwgJ3Byb2R1Y3QgY2FyZHMnKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3Byb2R1Y3QtcmVjb21tZW5kYXRpb25zOiBGYWlsZWQgdG8gcmVuZGVyIGNhcmRzJywgZXJyb3IpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhpZGVMb2FkaW5nKClcbiAgICAgIH1cblxuICAgICAgaGlkZUxvYWRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgICAgICB0aGlzLmxvYWRpbmcuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApXG59XG4iXSwibWFwcGluZ3MiOiJBQVlBLElBQUksQ0FBQyxlQUFlLElBQUkseUJBQXlCLEdBQUc7QUFDbEQsaUJBQWU7QUFBQSxJQUNiO0FBQUEsSUFDQSxNQUFNLCtCQUErQixZQUFZO0FBQUEsTUFDL0MsY0FBYztBQUNaLGNBQU07QUFDTixhQUFLLGdCQUFnQixLQUFLLFFBQVE7QUFDbEMsYUFBSyxZQUFZLEtBQUssUUFBUTtBQUM5QixhQUFLLG1CQUFtQixLQUFLLFFBQVE7QUFDckMsYUFBSyxjQUFjLEtBQUssUUFBUSxjQUFjLEtBQUssUUFBUSxZQUFZLE1BQU0sR0FBRyxFQUFFLElBQUksT0FBSyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUM7QUFDeEcsYUFBSyxjQUFjLFNBQVMsS0FBSyxRQUFRLFdBQVcsS0FBSztBQUN6RCxhQUFLLGNBQWMsU0FBUyxLQUFLLFFBQVEsV0FBVyxLQUFLO0FBQ3pELGFBQUssY0FBYyxLQUFLLFFBQVEsZ0JBQWdCO0FBQ2hELGFBQUssWUFBWSxLQUFLLFFBQVE7QUFDOUIsYUFBSyxZQUFZLEtBQUssY0FBYywwQkFBMEI7QUFDOUQsYUFBSyxVQUFVLEtBQUssY0FBYyxnQkFBZ0I7QUFBQSxNQUNwRDtBQUFBLE1BRUEsTUFBTSxvQkFBb0I7QUFDeEIsZ0JBQVEsSUFBSSx5Q0FBeUM7QUFBQSxVQUNuRCxXQUFXLEtBQUs7QUFBQSxVQUNoQixlQUFlLEtBQUs7QUFB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SSxTQUFTLFNBQVMsR0FBRyxJQUFJLEdBQUcsS0FBSztBQUM1QyxnQkFBTSxJQUFJLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxJQUFJLEVBQUU7QUFDNUMsV0FBQyxTQUFTLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7QUFBQSxRQUN4RDtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUEsTUFFQSxNQUFNLGVBQWUsVUFBVTtBQUM3QixnQkFBUSxJQUFJLHNDQUFzQyxTQUFTLFFBQVEsVUFBVTtBQUU3RSxZQUFJLFNBQVMsV0FBVyxHQUFHO0FBQ3pCLGtCQUFRLElBQUksZ0RBQWdEO0FBQzVELGVBQUssWUFBWTtBQUNqQixlQUFLLE1BQU0sVUFBVTtBQUNyQjtBQUFBLFFBQ0Y7QUFFQSxhQUFLLFVBQVUsWUFBWTtBQUUzQixZQUFJO0FBRUYsZ0JBQU0sZUFBZSxTQUFTO0FBQUEsWUFBSSxhQUNoQyxNQUFNLGFBQWEsUUFBUSxrQkFBa0IsRUFDMUMsS0FBSyxjQUFZO0FBQ2hCLGtCQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2hCLHdCQUFRLEtBQUssNEJBQTRCLFFBQVEsUUFBUTtBQUN6RCx1QkFBTztBQUFBLGNBQ1Q7QUFDQSxxQkFBTyxTQUFTLEtBQUs7QUFBQSxZQUN2QixDQUFDLEVBQ0EsTUFBTSxTQUFPO0FBQ1osc0JBQVEsS0FBSywyQkFBMkIsUUFBUSxXQUFXLEdBQUc7QUFDOUQscUJBQU87QUFBQSxZQUNULENBQUM7QUFBQSxVQUNMO0FBRUEsZ0JBQU0sUUFBUSxNQUFNLFFBQVEsSUFBSSxZQUFZO0FBRzVDLGVBQUssVUFBVSxZQUFZLE1BQU0sT0FBTyxVQUFRLElBQUksRUFBRSxLQUFLLEVBQUU7QUFFN0Qsa0JBQVEsSUFBSSxxQ0FBcUMsS0FBSyxVQUFVLFNBQVMsUUFBUSxlQUFlO0FBQUEsUUFDbEcsU0FBUyxPQUFQO0FBQ0Esa0JBQVEsTUFBTSxtREFBbUQsS0FBSztBQUFBLFFBQ3hFO0FBRUEsYUFBSyxZQUFZO0FBQUEsTUFDbkI7QUFBQSxNQUVBLGNBQWM7QUFDWixZQUFJLEtBQUssU0FBUztBQUNoQixlQUFLLFFBQVEsTUFBTSxVQUFVO0FBQUEsUUFDL0I7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjsiLCJuYW1lcyI6W10sImZpbGUiOiIuL3NyYy9lbnRyeXBvaW50cy9wcm9kdWN0LXJlY29tbWVuZGF0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/entrypoints/product-recommendations.js\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/entrypoints/product-recommendations.js"]();
/******/ 	
/******/ })()
;